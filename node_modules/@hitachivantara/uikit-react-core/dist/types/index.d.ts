import { ActionType } from 'react-table';
import { AvatarProps } from '@mui/material/Avatar';
import { Breakpoint as Breakpoint_2 } from '@mui/material/styles';
import { CardContentProps } from '@mui/material/CardContent';
import { CardHeaderProps } from '@mui/material/CardHeader';
import { CardMediaProps } from '@mui/material/CardMedia';
import { Cell } from 'react-table';
import { CheckboxProps } from '@mui/material/Checkbox';
import { ClickAwayListenerProps } from '@mui/base/ClickAwayListener';
import { ColumnInstance } from 'react-table';
import { ColumnInterface } from 'react-table';
import { ComponentProps } from 'react';
import { ContainerProps } from '@mui/material/Container';
import { Context } from 'react';
import { createClasses } from '@hitachivantara/uikit-react-utils';
import { default as default_2 } from 'embla-carousel-react';
import { defaultCacheKey } from '@hitachivantara/uikit-react-shared';
import { defaultEmotionCache } from '@hitachivantara/uikit-react-shared';
import { DialogActionsProps } from '@mui/material/DialogActions';
import { DialogContentProps } from '@mui/material/DialogContent';
import { DialogProps } from '@mui/material/Dialog';
import { DialogTitleProps } from '@mui/material/DialogTitle';
import { DividerProps } from '@mui/material/Divider';
import { DrawerProps } from '@mui/material/Drawer';
import { ds3 } from '@hitachivantara/uikit-styles';
import { ds5 } from '@hitachivantara/uikit-styles';
import { EmotionCache } from '@emotion/cache';
import { EmotionContext } from '@hitachivantara/uikit-react-shared';
import { ExtractNames } from '@hitachivantara/uikit-react-utils';
import { ForwardRefExoticComponent } from 'react';
import { GridProps } from '@mui/material/Grid';
import { Hooks } from 'react-table';
import { HvAccentColor } from '@hitachivantara/uikit-styles';
import { HvAtmosphereColor } from '@hitachivantara/uikit-styles';
import { HvBaseColor } from '@hitachivantara/uikit-styles';
import { HvBaseTheme } from '@hitachivantara/uikit-styles';
import { HvBreakpoints } from '@hitachivantara/uikit-styles';
import { HvCategoricalColor } from '@hitachivantara/uikit-styles';
import { HvColor } from '@hitachivantara/uikit-styles';
import { HvColorAny } from '@hitachivantara/uikit-styles';
import { HvExtraDeepProps } from '@hitachivantara/uikit-react-shared';
import { HvExtraProps } from '@hitachivantara/uikit-react-shared';
import { HvRadius } from '@hitachivantara/uikit-styles';
import { HvSemanticColor } from '@hitachivantara/uikit-styles';
import { HvSize } from '@hitachivantara/uikit-styles';
import { HvSupportColor } from '@hitachivantara/uikit-styles';
import { PluginHook as HvTablePluginHook } from 'react-table';
import { HvTheme } from '@hitachivantara/uikit-react-shared';
import { HvTheme as HvTheme_2 } from '@hitachivantara/uikit-styles';
import { HvThemeBreakpoint } from '@hitachivantara/uikit-styles';
import { HvThemeColorMode } from '@hitachivantara/uikit-styles';
import { HvThemeColorModeStructure } from '@hitachivantara/uikit-styles';
import { HvThemeContext } from '@hitachivantara/uikit-react-shared';
import { HvThemeContextValue } from '@hitachivantara/uikit-react-shared';
import { HvThemeStructure } from '@hitachivantara/uikit-styles';
import { IconBaseProps } from '@hitachivantara/uikit-react-icons';
import { IdType as IdType_2 } from 'react-table';
import { InputBaseProps } from '@mui/material/InputBase';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import { MutableRefObject } from 'react';
import { OptionGroupProps } from '@mui/base/OptionGroup';
import { OptionOwnProps } from '@mui/base/Option';
import { OptionsObject } from 'notistack';
import { pentahoPlus } from '@hitachivantara/uikit-styles';
import { PopperProps } from '@mui/base/Popper';
import { PopperProps as PopperProps_2 } from 'react-popper';
import { PropGetter } from 'react-table';
import { PropsWithoutRef } from 'react';
import { RadioProps } from '@mui/material/Radio';
import * as React_2 from 'react';
import { ReactNode } from 'react';
import { ReducerTableState } from 'react-table';
import { RefAttributes } from 'react';
import { Renderer } from 'react-table';
import { Row } from 'react-table';
import { SlideProps } from '@mui/material/Slide';
import { SliderProps } from 'rc-slider';
import { SliderRef } from 'rc-slider';
import { SnackbarCloseReason } from '@mui/material/Snackbar';
import { SnackbarContentProps } from '@mui/material/SnackbarContent';
import { SnackbarKey } from 'notistack';
import { SnackbarOrigin } from '@mui/material/Snackbar';
import { SnackbarProps } from '@mui/material/Snackbar';
import { SnackbarProviderProps } from 'notistack';
import { SwitchProps } from '@mui/material/Switch';
import { TableCellProps } from 'react-table';
import { TableCommonProps } from 'react-table';
import { TableExpandedToggleProps } from 'react-table';
import { TableFooterProps } from 'react-table';
import { TableHeaderProps } from 'react-table';
import { TableInstance } from 'react-table';
import { TableOptions } from 'react-table';
import { TableProps } from 'react-table';
import { TableRowProps } from 'react-table';
import { TableState } from 'react-table';
import { TabProps } from '@mui/material/Tab';
import { TabsProps } from '@mui/material/Tabs';
import { theme } from '@hitachivantara/uikit-styles';
import { themes } from '@hitachivantara/uikit-styles';
import { TooltipProps } from '@mui/material/Tooltip';
import { TransitionProps } from '@mui/material/transitions';
import { UseColumnOrderInstanceProps } from 'react-table';
import { UseColumnOrderState } from 'react-table';
import { useCss } from '@hitachivantara/uikit-react-utils';
import { useDefaultProps } from '@hitachivantara/uikit-react-utils';
import { UseExpandedHooks } from 'react-table';
import { UseExpandedInstanceProps } from 'react-table';
import { UseExpandedOptions } from 'react-table';
import { UseExpandedRowProps } from 'react-table';
import { UseExpandedState } from 'react-table';
import { UseFiltersColumnOptions } from 'react-table';
import { UseFiltersColumnProps } from 'react-table';
import { UseFiltersInstanceProps } from 'react-table';
import { UseFiltersOptions } from 'react-table';
import { UseFiltersState } from 'react-table';
import { UseGlobalFiltersColumnOptions } from 'react-table';
import { UseGlobalFiltersInstanceProps } from 'react-table';
import { UseGlobalFiltersOptions } from 'react-table';
import { UseGlobalFiltersState } from 'react-table';
import { UseGroupByCellProps } from 'react-table';
import { UseGroupByColumnOptions } from 'react-table';
import { UseGroupByColumnProps } from 'react-table';
import { UseGroupByHooks } from 'react-table';
import { UseGroupByInstanceProps } from 'react-table';
import { UseGroupByOptions } from 'react-table';
import { UseGroupByRowProps } from 'react-table';
import { UseGroupByState } from 'react-table';
import { useLayoutEffect } from 'react';
import { UsePaginationInstanceProps } from 'react-table';
import { UsePaginationOptions } from 'react-table';
import { UsePaginationState } from 'react-table';
import { UseResizeColumnsColumnOptions } from 'react-table';
import { UseResizeColumnsColumnProps } from 'react-table';
import { UseResizeColumnsOptions } from 'react-table';
import { UseResizeColumnsState } from 'react-table';
import { useRowState } from 'react-table';
import { UseRowStateInstanceProps } from 'react-table';
import { UseRowStateOptions } from 'react-table';
import { UseRowStateRowProps } from 'react-table';
import { UseRowStateState } from 'react-table';
import { UseSelectParameters } from '@mui/base/useSelect';
import { UseSortByColumnOptions } from 'react-table';
import { UseSortByColumnProps } from 'react-table';
import { UseSortByHooks } from 'react-table';
import { UseSortByInstanceProps } from 'react-table';
import { UseSortByOptions } from 'react-table';
import { UseSortByState } from 'react-table';
import { UseTableHeaderGroupProps } from 'react-table';
import { useTheme } from '@hitachivantara/uikit-react-utils';
import { UseTreeViewExpansionInstance } from '../internals/hooks/plugins/useTreeViewExpansion';
import { UseTreeViewFocusInstance } from '../internals/hooks/plugins/useTreeViewFocus';
import { UseTreeViewKeyboardNavigationInstance } from '../internals/hooks/plugins/useTreeViewKeyboardNavigation';
import { UseTreeViewNodesInstance } from '../internals/hooks/plugins/useTreeViewNodes';
import { UseTreeViewSelectionInstance } from '../internals/hooks/plugins/useTreeViewSelection';

declare type Accessor<D extends object> = (originalRow: D, index: number, sub: {
    subRows: D[];
    depth: number;
    data: D[];
}) => CellValue;

export declare const accordionClasses: {
    root: string;
    hidden: string;
    container: string;
    label: string;
    disabled: string;
};

export declare const actionBarClasses: {
    root: string;
};

export declare const actionClasses: {
    action: string;
    noIcon: string;
    minimized: string;
};

/** @private label structure action icon buttons */
declare interface ActionIconLabels extends DialogLabels {
    /** @deprecated use `tooltip` label instead */
    ariaLabel: string;
    tooltip?: string;
}

export declare const actionsClasses: {
    root: string;
    hide: string;
};

export declare const actionsGenericClasses: {
    root: string;
    button: string;
    actionContainer: string;
    dropDownMenu: string;
    dropDownMenuButton: string;
    dropDownMenuButtonSelected: string;
};

export declare const adornmentClasses: {
    root: string;
    icon: string;
    adornment: string;
    adornmentIcon: string;
    hideIcon: string;
    adornmentButton: string;
    disabled: string;
};

export declare const appSwitcherActionClasses: {
    root: string;
    icon: string;
    iconUrl: string;
    iconInfo: string;
    disabled: string;
    selected: string;
    typography: string;
    title: string;
    titleAnchor: string;
};

export declare const appSwitcherClasses: {
    root: string;
    item: string;
    itemSelected: string;
    itemDisabled: string;
    itemTrigger: string;
    itemIcon: string;
    itemTitle: string;
    itemInfoIcon: string;
    actionsContainer: string;
    footerContainer: string;
    open: string;
    closed: string;
    title: string;
    titleAnchor: string;
    single: string;
    dual: string;
    fluid: string;
};

export declare type Arrayable<T> = T | T[];

declare interface AskAction {
    actions: QueryAction[];
    dialog: DialogLabels;
}

declare type AsProp<C extends React.ElementType> = {
    /** Custom element type to override the root component */
    component?: C;
};

export declare const avatarClasses: {
    root: string;
    container: string;
    img: string;
    fallback: string;
    status: string;
    avatar: string;
    badge: string;
    xs: string;
    sm: string;
    md: string;
    lg: string;
    xl: string;
    circular: string;
    square: string;
};

export declare const avatarGroupClasses: {
    root: string;
    row: string;
    column: string;
    highlight: string;
    toBack: string;
};

export declare const badgeClasses: {
    root: string;
    badgeContainer: string;
    badgePosition: string;
    badge: string;
    badgeHidden: string;
    showCount: string;
    showLabel: string;
    badgeIcon: string;
    badgeOneDigit: string;
};

export declare const bannerClasses: {
    rootClosed: string;
    root: string;
    anchorOriginTopCenter: string;
    anchorOriginBottomCenter: string;
};

export declare const bannerContentClasses: {
    root: string;
    message: string;
    action: string;
    baseVariant: string;
    success: string;
    warning: string;
    error: string;
    default: string;
    outContainer: string;
    messageContainer: string;
    iconContainer: string;
    messageActions: string;
    actionContainer: string;
    actionsInnerContainer: string;
    closeAction: string;
};

declare interface BarProps extends HvBaseProps {
    data: HvHeaderNavigationItemProp[];
    type?: "menubar" | "menu";
    classes?: HvHeaderMenuBarClasses;
}

export declare const baseCheckBoxClasses: {
    root: string;
    disabled: string;
    focusVisible: string;
    icon: string;
    checked: string;
    indeterminate: string;
    semantic: string;
};

export declare const baseDropdownClasses: {
    root: string;
    rootDisabled: string;
    anchor: string;
    container: string;
    header: string;
    headerOpen: string;
    headerOpenUp: string;
    headerOpenDown: string;
    headerDisabled: string;
    headerReadOnly: string;
    arrowContainer: string;
    arrow: string;
    selection: string;
    selectionDisabled: string;
    placeholder: string;
    panel: string;
    panelOpenedUp: string;
    panelOpenedDown: string;
    inputExtensionOpen: string;
    inputExtensionLeftPosition: string;
    inputExtensionOpenShadow: string;
    inputExtensionFloatRight: string;
    inputExtensionFloatLeft: string;
};

export declare const baseInputClasses: {
    root: string;
    disabled: string;
    invalid: string;
    multiline: string;
    resizable: string;
    readOnly: string;
    focused: string;
    inputBorderContainer: string;
    inputRootInvalid: string;
    inputRootReadOnly: string;
    inputRoot: string;
    inputRootFocused: string;
    inputRootDisabled: string;
    inputRootMultiline: string;
    input: string;
    inputDisabled: string;
    inputReadOnly: string;
    inputResizable: string;
};

export declare const baseRadioClasses: {
    root: string;
    disabled: string;
    focusVisible: string;
    icon: string;
    checked: string;
    semantic: string;
};

export declare const baseSwitchClasses: {
    root: string;
    switch: string;
    switchBase: string;
    track: string;
    thumb: string;
    checked: string;
    disabled: string;
    readOnly: string;
    focusVisible: string;
};

export declare const breadCrumbClasses: {
    root: string;
    link: string;
    orderedList: string;
    currentPage: string;
    centerContainer: string;
    separatorContainer: string;
    a: string;
};

export declare interface Breakpoint {
    cols?: number;
    maxWidth?: number;
    minWidth?: number;
    spacing?: HvBreakpoints;
}

export declare const bulkActionsClasses: {
    root: string;
    semantic: string;
    actions: string;
    selectAllContainer: string;
    selectAll: string;
    selectAllPages: string;
    divider: string;
};

export declare const buttonBaseClasses: {
    root: string;
    disabled: string;
};

export declare const buttonClasses: {
    root: string;
    startIcon: string;
    endIcon: string;
    focusVisible: string;
    disabled: string;
    icon: string;
    contained: string;
    subtle: string;
    ghost: string;
    semantic: string;
    primary: string;
    primarySubtle: string;
    primaryGhost: string;
    secondarySubtle: string;
    secondaryGhost: string;
    secondary: string;
};

export declare const calendarClasses: {
    root: string;
    rangeCalendarContainer: string;
    singleCalendar: string;
    focusSelection: string;
    calendarMonthlyCell: string;
    calendarMonthlyCellSelected: string;
};

export declare const calendarHeaderClasses: {
    root: string;
    invalid: string;
    headerDayOfWeek: string;
};

export declare const cardClasses: {
    root: string;
    selected: string;
    selectable: string;
    semanticContainer: string;
    icon: string;
    semanticBar: string;
};

export declare const cardContentClasses: {
    content: string;
};

export declare const cardHeaderClasses: {
    root: string;
    titleShort: string;
    title: string;
    subheader: string;
    content: string;
    action: string;
};

export declare const cardMediaClasses: {
    root: string;
    media: string;
};

export declare const carouselClasses: {
    root: string;
    xs: string;
    fullscreen: string;
    title: string;
    actions: string;
    closeButton: string;
    mainContainer: string;
    controls: string;
    pageCounter: string;
    main: string;
    mainXs: string;
    mainFullscreen: string;
    counterContainer: string;
    counter: string;
    slideControls: string;
    slidesViewport: string;
    slidesContainer: string;
    dots: string;
    dotsXs: string;
    dot: string;
    dotSelected: string;
    panel: string;
    thumbnail: string;
    thumbnailSelected: string;
};

declare type CellValue<V = any> = V;

export declare const CellWithExpandButton: ({ row, cell, labels: labelsProp, }: HvCellProps<any>) => JSX_2.Element;

export declare const charCounterClasses: {
    root: string;
    counterDisabled: string;
    gutter: string;
    overloaded: string;
};

export declare const checkBoxClasses: {
    root: string;
    container: string;
    disabled: string;
    focusVisible: string;
    invalidContainer: string;
    checkbox: string;
    invalidCheckbox: string;
    label: string;
    checked: string;
    indeterminate: string;
    semantic: string;
};

export declare const checkBoxGroupClasses: {
    root: string;
    label: string;
    group: string;
    vertical: string;
    horizontal: string;
    invalid: string;
    selectAll: string;
    error: string;
};

export declare const checkValidHexColorValue: (value?: string) => boolean;

export declare const colorPickerClasses: {
    root: string;
    labelContainer: string;
    label: string;
    description: string;
    headerColorValue: string;
    headerColorIcon: string;
    panel: string;
    colorPicker: string;
    colorPickerIcon: string;
    recommendedColorsRoot: string;
    dropdownRootIconOnly: string;
    headerColorIconOnly: string;
    pickerFields: string;
};

export declare const containerClasses: {
    root: string;
    disableGutters: string;
    fixed: string;
    maxWidthXs: string;
    maxWidthSm: string;
    maxWidthMd: string;
    maxWidthLg: string;
    maxWidthXl: string;
};

export declare const controlsClasses: {
    root: string;
    section: string;
    rightSection: string;
    leftSection: string;
};

export { createClasses }

/**
 * Creates a customized theme based on the base theme and customizations given.
 * For the color modes, the colors that are not defined will be replaced by the values from the dawn mode of the base theme.
 */
export declare const createTheme: (props: HvCreateThemeProps) => HvTheme | HvThemeStructure;

export declare const datePickerClasses: {
    root: string;
    actionContainer: string;
    leftContainer: string;
    rightContainer: string;
    labelContainer: string;
    label: string;
    description: string;
    error: string;
    dropdown: string;
    panel: string;
    dropdownHeaderInvalid: string;
    dropdownHeaderOpen: string;
    icon: string;
    action: string;
    inputText: string;
    dateText: string;
    container: string;
};

export declare interface DateRangeProp {
    startDate: Date;
    endDate?: Date;
}

export declare const decreaseSize: (size: string) => "XS" | "S" | "M" | "L";

/** This type allows to do a deep partial by applying the Partial type to each key recursively */
export declare type DeepPartial<T> = T extends {} ? Partial<{
    [P in keyof T]: DeepPartial<T[P]>;
}> : T;

declare const DEFAULT_LABELS: {
    dropdownMenu: string;
};

declare const DEFAULT_LABELS_10: {
    /** Apply button label. */
    applyLabel: string;
    /** Cancel button label. */
    cancelLabel: string;
    /** Clear button label. */
    clearLabel: string;
    /** Placeholder label. */
    placeholder: string;
    /** SearchBox placeholder label. */
    searchBoxPlaceholder: string;
    /** Select All placeholder label. */
    selectAll: string;
    /** Multi selection conjunction placeholder label. */
    multiSelectionConjunction: string;
};

declare const DEFAULT_LABELS_11: {
    /** The text at the top of the kpi. */
    title: string;
    /** The text in the middle of the kpi. */
    indicator: string | undefined;
    /** The text to the right of the indicator. */
    unit: string | undefined;
    /** The text to the right of the visual comparison. */
    comparisonIndicatorInfo: string | undefined;
};

declare const DEFAULT_LABELS_12: {
    /** The label used for the All checkbox action. @deprecated no longer used */
    selectAll: string;
    /** The label used in the middle of the multi-selection count. */
    selectionConjunction: string;
};

declare const DEFAULT_LABELS_2: {
    close: string;
    fullscreen: string;
    backwards: string;
    forwards: string;
};

declare const DEFAULT_LABELS_3: {
    /** The show label. */
    pageSizePrev: string;
    /** Indicate the units of the page size selection. */
    pageSizeEntryName: string;
    /** Used for the aria-label of the selection of number of unit.s */
    pageSizeSelectorDescription: string;
    /** Separator of current page and total pages. */
    pagesSeparator: string;
    /** Title of button `firstPage`. @deprecated Use `firstPage` instead. */
    paginationFirstPageTitle: string;
    /** Title of button `previousPage`. @deprecated Use `previousPage` instead. */
    paginationPreviousPageTitle: string;
    /** Title of button `nextPage`. @deprecated Use `nextPage` instead. */
    paginationNextPageTitle: string;
    /** Title of button `lastPage`. @deprecated Use `lastPage` instead. */
    paginationLastPageTitle: string;
    /** Aria-label passed to the page input. */
    paginationInputLabel: string;
    /** Label of the first page button */
    firstPage: string;
    /** Label of the previous page button */
    previousPage: string;
    /** Label of the next page button */
    nextPage: string;
    /** Label of the last page button */
    lastPage: string;
};

declare const DEFAULT_LABELS_4: {
    /** The label of the clear button. */
    clearButtonLabel: string;
    /** The label of the reveal password button. */
    revealPasswordButtonLabel: string;
    /** The tooltip of the reveal password button when the password is hidden. */
    revealPasswordButtonClickToShowTooltip: string;
    /** The tooltip of the reveal password button when the password is revealed. */
    revealPasswordButtonClickToHideTooltip: string;
    /** The label of the search button. */
    searchButtonLabel: string;
};

declare const DEFAULT_LABELS_5: {
    backwards: string;
    forwards: string;
};

declare const DEFAULT_LABELS_6: {
    recommendedColorsLabel: string;
    customColorsLabel: string;
};

declare const DEFAULT_LABELS_7: {
    /** Label for overwrite the default header behavior. */
    select: string | undefined;
    /** Label used for the All checkbox action. @deprecated unused */
    selectAll: string;
    /** Cancel button label. */
    cancelLabel: string;
    /** Apply button label. */
    applyLabel: string;
    /** The label used in the middle of the multiSelection count. */
    searchPlaceholder: string;
    /** The label used in search. */
    multiSelectionConjunction: string;
};

declare const DEFAULT_LABELS_8: {
    /** Apply button label. */
    applyLabel: string;
    /** Cancel button label. */
    cancelLabel: string;
    /** Clear button label. */
    clearLabel: string;
    /** Invalid Date label. */
    invalidDateLabel: string;
};

declare const DEFAULT_LABELS_9: {
    /** Extensions of the accepted file types */
    acceptedFiles: string;
    /** Dropzone area label. @deprecated use `label` prop instead */
    dropzone: string;
    /** Size file warning label. */
    sizeWarning: string;
    /** Size file warning label. */
    drag: string;
    /** Size file warning label. */
    selectFiles: string;
    /** Theming sheet used to style components */
    dropFiles: string;
    /** Message to display when file size is greater than allowed */
    fileSizeError: string;
    /** Message to display when file type is greater than allowed */
    fileTypeError: string;
    removeFileButtonLabel: string;
};

declare type DefaultAttributes = (typeof defaultAttributes)[number];

declare const defaultAttributes: readonly ["boolean", "numeric", "dateandtime", "text", "textarea"];

export { defaultCacheKey }

export { defaultEmotionCache }

export declare const defaultGetHvPaginationProps: (props: any, { instance }: any) => any[];

export declare const defaultGetToggleAllPageRowsSelectedProps: (props: any, { instance }: any) => any[];

export declare const defaultGetToggleAllRowsSelectedProps: (props: any, { instance }: any) => any[];

export declare const defaultGetToggleRowSelectedProps: (props: any, meta: any) => any[];

declare interface DefaultTreeViewPluginParameters<Multiple extends boolean | undefined> extends UseTreeViewNodesParameters, UseTreeViewExpansionParameters, UseTreeViewFocusParameters, UseTreeViewSelectionParameters<Multiple>, UseTreeViewContextValueBuilderParameters {
}

export declare const dialogActionClasses: {
    root: string;
    fullscreen: string;
    spacing: string;
};

export declare const dialogClasses: {
    root: string;
    background: string;
    paper: string;
    fullscreen: string;
    fullHeight: string;
    closeButton: string;
    statusBar: string;
    success: string;
    error: string;
    warning: string;
};

export declare const dialogContentClasses: {
    root: string;
    textContent: string;
};

declare interface DialogLabels {
    dialogTitle: string;
    dialogMessage: string;
    dialogConfirm: string;
    dialogCancel: string;
    dialogCloseTooltip: string;
}

export declare const dialogTitleClasses: {
    root: string;
    fullscreen: string;
    messageContainer: string;
    textWithIcon: string;
    titleText: string;
};

export declare const dotPaginationClasses: {
    root: string;
    horizontal: string;
    radioRoot: string;
    radio: string;
    icon: string;
};

export declare const drawerClasses: {
    root: string;
    paper: string;
    background: string;
    closeButton: string;
};

export declare const dropdownClasses: {
    root: string;
    labelContainer: string;
    label: string;
    description: string;
    error: string;
    placeholder: string;
    placeholderClosed: string;
    selectionDisabled: string;
    dropdown: string;
    arrow: string;
    dropdownHeader: string;
    dropdownHeaderInvalid: string;
    dropdownHeaderOpen: string;
    dropdownListContainer: string;
    rootList: string;
    disabled: string;
    readOnly: string;
};

export declare const dropDownMenuClasses: {
    container: string;
    baseContainer: string;
    root: string;
    icon: string;
    iconSelected: string;
    menuListRoot: string;
    menuList: string;
};

export { ds3 }

export { ds5 }

export { EmotionContext }

export declare const emptyStateClasses: {
    root: string;
    container: string;
    containerMessageOnly: string;
    iconContainer: string;
    titleContainer: string;
    textContainer: string;
    messageContainer: string;
    actionContainer: string;
};

export { ExtractNames }

export declare const fileClasses: {
    root: string;
    progressbar: string;
    progressbarContainer: string;
    progressbarBack: string;
    nameText: string;
    progressTextContainer: string;
    removeButton: string;
    previewContainer: string;
    icon: string;
    fail: string;
};

export declare const fileUploaderClasses: {
    root: string;
};

export declare const fileUploaderPreviewClasses: {
    previewButton: string;
    overlay: string;
};

export declare const filterGroupClasses: {
    root: string;
    label: string;
    labelContainer: string;
    description: string;
    error: string;
};

declare type FixComponentProps<T> = T extends any ? T : never;

/** React.forwardRef with fixed type declarations */
export declare function fixedForwardRef<T, P = {}>(render: (props: P, ref: React.Ref<T>) => React.ReactElement | null): (props: P & React.RefAttributes<T>) => React.ReactElement | null;

export declare const focusClasses: {
    root: string;
    selected: string;
    disabled: string;
    focusDisabled: string;
    focused: string;
    externalReference: string;
    falseFocus: string;
    focus: string;
};

export declare const footerClasses: {
    root: string;
    name: string;
    rightContainer: string;
    copyright: string;
    separator: string;
    small: string;
};

export declare const formElementClasses: {
    root: string;
};

export declare const getComponentName: (Component: React.FC) => string;

/** Get the first and last focusable element from a node. */
export declare const getFirstAndLastFocus: (node: any) => {
    first: any;
    last: any;
};

/** Gets the list of focusable elements. */
export declare const getFocusableList: (node: any) => any;

/** Auxiliary function to find adjacent nodes to focus. */
export declare const getPrevNextFocus: (nodeId?: string) => {
    nextFocus: any;
    prevFocus: any;
};

export declare const getSelectorIcons: () => {
    radio: JSX_2.Element;
    radioChecked: JSX_2.Element;
};

export declare const getVarValue: (cssVar: string, rootElementId?: string) => string | undefined;

export declare const globalActionsClasses: {
    root: string;
    positionSticky: string;
    positionFixed: string;
    global: string;
    section: string;
    wrapper: string;
    globalSectionArea: string;
    globalWrapperComplement: string;
    backButton: string;
    name: string;
    sectionName: string;
    actions: string;
};

export declare const gridClasses: {
    root: string;
    container: string;
    item: string;
    zeroMinWidth: string;
    "direction-xs-column": string;
    "direction-xs-reverse": string;
    "direction-xs-row-reverse": string;
    "wrap-xs-nowrap": string;
    "wrap-xs-wrap-reverse": string;
    "spacing-xs-1": string;
    "spacing-xs-2": string;
    "spacing-xs-3": string;
    "spacing-xs-4": string;
    "spacing-xs-5": string;
    "spacing-xs-6": string;
    "spacing-xs-7": string;
    "spacing-xs-8": string;
    "spacing-xs-9": string;
    "spacing-xs-10": string;
    "grid-xs-auto": string;
    "grid-xs-true": string;
    "grid-xs-1": string;
    "grid-xs-2": string;
    "grid-xs-3": string;
    "grid-xs-4": string;
    "grid-xs-5": string;
    "grid-xs-6": string;
    "grid-xs-7": string;
    "grid-xs-8": string;
    "grid-xs-9": string;
    "grid-xs-10": string;
    "grid-xs-11": string;
    "grid-xs-12": string;
};

export declare const headerActionsClasses: {
    root: string;
};

export declare const headerBrandClasses: {
    root: string;
    separator: string;
    brandName: string;
};

export declare const headerClasses: {
    root: string;
    header: string;
    fixed: string;
    backgroundColor: string;
};

export declare const headerNavigationClasses: {
    root: string;
};

export declare const hexToRgbA: (hex: string, factor?: number) => string;

export declare const horizontalScrollListItemClasses: {
    root: string;
    button: string;
    text: string;
    selected: string;
    bullet: string;
    bulletSelected: string;
};

export { HvAccentColor }

export declare type HvAccentColorKeys = HvAccentColor;

export declare type HvAccentColors = Record<HvAccentColorKeys, string>;

/**
 * A accordion is a design element that expands in place to expose hidden information.
 */
export declare const HvAccordion: ForwardRefExoticComponent<HvAccordionProps & RefAttributes<HTMLDivElement>>;

export declare type HvAccordionClasses = ExtractNames<typeof useClasses_20>;

export declare interface HvAccordionProps extends HvBaseProps<HTMLDivElement, "onChange" | "children"> {
    /** Content to be rendered. */
    children: React.ReactNode;
    /** The accordion label button. */
    label?: string;
    /** The function that will be executed whenever the accordion toggles. It will receive the state of the accordion. */
    onChange?: (event: React.SyntheticEvent, value: boolean) => void;
    /** Whether the accordion is open or not. If this property is defined the accordion must be fully controlled. */
    expanded?: boolean;
    /** When uncontrolled, defines the initial expanded state. */
    defaultExpanded?: boolean;
    /** An object containing props to be passed onto container holding the accordion children. */
    containerProps?: React.HTMLAttributes<HTMLDivElement>;
    /** Heading level to apply to accordion button. If ´undefined´ the button won't have a header wrapper. */
    headingLevel?: 1 | 2 | 3 | 4 | 5 | 6;
    /** Whether the accordion is disabled. */
    disabled?: boolean;
    /** Typography variant for the label. */
    labelVariant?: HvTypographyVariants;
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvAccordionClasses;
    /** Whether to disable the internal usage of `preventDefault` and `stopPropagation` when the `onChange` event is triggered. */
    disableEventHandling?: boolean;
}

/**
 * The Action Bar accommodates all the actions related to a specific task on a screen or pattern.
 */
export declare const HvActionBar: ForwardRefExoticComponent<HvActionBarProps & RefAttributes<HTMLDivElement>>;

export declare type HvActionBarClasses = ExtractNames<typeof useClasses_21>;

export declare interface HvActionBarProps extends HvBaseProps {
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvActionBarClasses;
}

export declare interface HvActionGeneric {
    /** Action id. */
    id: string;
    /** Action label. */
    label: string;
    /** Action icon. */
    icon?: React.ReactNode | ((params: {
        isDisabled?: boolean;
    }) => React.ReactNode);
    /** Whether the action is disabled or not. */
    disabled?: boolean;
    /** When set to `true`, the button will have the icon has its content and a tooltip with the label will appear when the button is visible and hovered. */
    iconOnly?: boolean;
}

export declare const HvActionsGeneric: ForwardRefExoticComponent<HvActionsGenericProps & RefAttributes<HTMLDivElement>>;

export declare type HvActionsGenericClasses = ExtractNames<typeof useClasses_22>;

export declare interface HvActionsGenericProps extends HvBaseProps {
    /**
     * The button category for all actions.
     *
     * @deprecated Use `variant` instead.
     */
    category?: HvButtonVariant;
    /** The button variant for all actions. */
    variant?: HvButtonVariant;
    /** Whether the actions should be all disabled. */
    disabled?: boolean;
    /** Whether the actions should be all icon buttons when visible. */
    iconOnly?: boolean;
    /** The renderable content inside the actions slot of the footer, or an array of actions. */
    actions: React.ReactNode | HvActionGeneric[];
    /**
     * The callback function called when an action is triggered, receiving the `action` as parameter.
     *
     * @deprecated Use `onAction` instead.
     * */
    actionsCallback?: (event: React.SyntheticEvent, id: string, action: HvActionGeneric) => void;
    /** The callback function called when an action is triggered, receiving the `action` as parameter. */
    onAction?: (event: React.SyntheticEvent, action: HvActionGeneric) => void;
    /** The maximum number of visible actions before they're collapsed into a dropdown menu. */
    maxVisibleActions?: number;
    /** Props to be applied to the dropdown menu. */
    dropdownMenuProps?: Partial<HvDropDownMenuProps>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvActionsGenericClasses;
}

/**
 * Allows to add a decorative icon or an action to a form element, usually on the right side of an input.
 * E.g., the reveal password button.
 *
 * This component disables keyboard navigation by default, ensuring that it doesn't steal focus from the input.
 * As such, its functionality, if any, for accessibility purposes must be provided through an alternative mean.
 * This behavior can be overridden by providing an a `tabIndex={0}`.
 */
export declare const HvAdornment: ForwardRefExoticComponent<HvAdornmentProps & RefAttributes<HTMLButtonElement | HTMLDivElement>>;

export declare type HvAdornmentClasses = ExtractNames<typeof useClasses_7>;

export declare interface HvAdornmentProps extends HvBaseProps<HTMLDivElement | HTMLButtonElement, "onMouseDown" | "onKeyDown"> {
    /** The icon to be added into the input. */
    icon: React.ReactNode;
    /** Controls the visibility of the adornment based on the form element's status. `isVisible` overrides this behavior. */
    showWhen?: HvFormStatus;
    /** Function to be executed when this element is clicked. */
    onClick?: React.MouseEventHandler<HTMLButtonElement>;
    /** If this property is defined the adornment visibility will be exclusively controlled by this value. */
    isVisible?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvAdornmentClasses;
}

export declare const HvAppSwitcher: ForwardRefExoticComponent<HvAppSwitcherProps & RefAttributes<HTMLDivElement>>;

export declare const HvAppSwitcherAction: ({ id, className, classes: classesProp, application, onClickCallback, isSelectedCallback, }: HvAppSwitcherActionProps) => JSX_2.Element;

export declare interface HvAppSwitcherActionApplication {
    /** Id of the application. */
    id?: string;
    /** Name of the application, this is the value that will be displayed on the component. */
    name: string;
    /** URL with the icon location to be used to represent the application. iconUrl will only be used if no iconElement is provided. */
    iconUrl?: string;
    /** Element to be added as the icon representing the application. The iconElement will be the primary option to be displayed. */
    iconElement?: React.ReactElement;
    /** Small description of the application. */
    description?: string;
    /**  URL where the application is accessible. */
    url?: string;
    /** Defines if the application should be opened in the same tab or in a new one. */
    target?: "_top" | "_blank";
    /** If true, the item will be disabled. */
    disabled?: boolean;
    /** True when the application is selected, false otherwise. */
    isSelected?: boolean;
    /** The color of the application. */
    color?: HvColorAny;
}

export declare type HvAppSwitcherActionClasses = ExtractNames<typeof useClasses_25>;

export declare interface HvAppSwitcherActionProps extends HvBaseProps {
    /** The application data to be used to render the Action object. */
    application: HvAppSwitcherActionApplication;
    /** Callback triggered when the action is clicked. */
    onClickCallback?: (event: React.MouseEvent, application: HvAppSwitcherActionApplication) => void;
    /** Must return a boolean stating if the action element is selected or not. */
    isSelectedCallback?: (application: HvAppSwitcherActionApplication) => boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvAppSwitcherActionClasses;
}

export declare type HvAppSwitcherClasses = ExtractNames<typeof useClasses_24>;

export declare interface HvAppSwitcherProps extends HvBaseProps {
    /** Number of columns to render. One, two, or whatever fits the component's width. */
    layout?: "single" | "dual" | "fluid";
    /** Title to be displayed on the header of the component. */
    title?: string;
    /** The list of applications to be used to render the actions on the component. */
    applications?: HvAppSwitcherActionApplication[];
    /** Triggered when an action is clicked. */
    onActionClickedCallback?: (event: React.MouseEvent, application: HvAppSwitcherActionApplication) => void;
    /** Must return a boolean stating if the action element is selected or not. */
    isActionSelectedCallback?: (application: HvAppSwitcherActionApplication) => boolean;
    /** Element to be added to the header container, if none is provided a label with the title will be added. */
    header?: React.ReactNode;
    /** Element to be added to the footer container. */
    footer?: React.ReactNode;
    /**
     * Flag stating if the panel is opened or closed.
     *
     * @deprecated This logic should be external, i.e. using the HvAppSwitcher inside a Drawer component.
     */
    isOpen?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvAppSwitcherClasses;
}

export { HvAtmosphereColor }

export declare type HvAtmosphereColorKeys = HvAtmosphereColor;

export declare type HvAtmosphereColors = Record<HvAtmosphereColorKeys, string>;

/**
 * Avatars can be used to represent a user or a brand.
 * They can show an image, an icon or the initial letters of a name, for example.
 */
export declare const HvAvatar: ForwardRefExoticComponent<HvAvatarProps & RefAttributes<HTMLDivElement>>;

export declare type HvAvatarClasses = ExtractNames<typeof useClasses_26>;

/**
 * The AvatarGroup component is used to group multiple avatars.
 */
export declare const HvAvatarGroup: ForwardRefExoticComponent<HvAvatarGroupProps & RefAttributes<HTMLDivElement>>;

export declare type HvAvatarGroupClasses = ExtractNames<typeof useClasses_27>;

export declare interface HvAvatarGroupProps extends HvBaseProps {
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvAvatarGroupClasses;
    /** The avatar size. */
    size?: HvSize;
    /** The spacing between avatars. */
    spacing?: "compact" | "loose";
    /** The direction of the group. */
    direction?: "row" | "column";
    /** Whether the avatars display behind the previous avatar or on top. */
    toBack?: boolean;
    /**
     * The maximum number of visible avatars. If there are more avatars then the value of this property, an added avatar will
     * be added to the end of the list, indicating the number of hidden avatars.
     */
    maxVisible?: number;
    /**
     * What to show as an overflow representation.
     * If `undefined` a default `HvAvatar` will be displayed along with a HvTooltip with the count of overflowing items.
     * */
    overflowComponent?: (overflowCount: number) => React.ReactNode;
    /**
     * If `true` the avatars will be brought to the front when hovered.
     */
    highlight?: boolean;
}

export declare interface HvAvatarProps extends HvBaseProps {
    /** The component used for the root node. Either a string to use a DOM element or a component. */
    component?: React.ElementType;
    /** Sets one of the standard sizes of the icons */
    size?: HvSize;
    /** A color representing the foreground color of the avatar's letters or the generic User icon fallback. */
    color?: HvColorAny;
    /** A String representing the background color of the avatar. */
    backgroundColor?: HvColorAny;
    /** The `src` attribute for the `img` element. */
    src?: string;
    /** The `srcSet` attribute for the `img` element. Use this attribute for responsive image display. */
    srcSet?: string;
    /** The `sizes` attribute for the `img` element. */
    sizes?: string;
    /** Used in combination with `src` or `srcSet` to provide an alt attribute for the rendered `img` element. */
    alt?: string;
    /**
     * Attributes applied to the `img` element if the component is used to display an image.
     * It can be used to listen for the loading error event.
     */
    imgProps?: React.HTMLAttributes<HTMLImageElement>;
    /** A string representing the type of avatar to display, circular or square. */
    variant?: HvAvatarVariant;
    /** A string representing the color of the avatar border that represents its status. */
    status?: string;
    /** A string representing the color of the avatar badge. */
    badge?: string;
    /** Attributes applied to the avatar element. */
    avatarProps?: AvatarProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvAvatarClasses;
}

/** @deprecated use `HvSize` instead */
export declare type HvAvatarSize = "xs" | "sm" | "md" | "lg" | "xl";

export declare type HvAvatarVariant = "circular" | "square";

/**
 * The badge is a component used to notify the user that something has occurred, in the app context.
 */
export declare const HvBadge: ForwardRefExoticComponent<HvBadgeProps & RefAttributes<HTMLDivElement>>;

export declare type HvBadgeClasses = ExtractNames<typeof useClasses_28>;

export declare interface HvBadgeProps extends HvBaseProps {
    /**
     * Count is the number of unread notifications.
     * Note count and label are mutually exclusive.
     * count is ignored when label is specified at the same time.
     * @deprecated use numeric `label` instead
     */
    count?: number;
    /**
     * True if `count` should be displayed.
     *
     * NOTE: `showCount` is ignored when a **non-numeric** `label` is specified.
     */
    showCount?: boolean;
    /** The maximum number of unread notifications to be displayed */
    maxCount?: number;
    /**
     * Badge content to show in.
     *
     * If value is numeric, then `showCount` and `maxCount` will show or limit the value respectively.
     */
    label?: React.ReactNode;
    /** Icon which the notification will be attached. */
    icon?: React.ReactNode;
    /** Text which the notification will be attached. @deprecated use `children` instead. */
    text?: string;
    /** Text variant. @deprecated use a `HvTypography` on `children` instead. */
    textVariant?: HvTypographyVariants;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvBadgeClasses;
}

/**
 * A Banner displays an important and succinct message. It can also provide actions for the user to address, or dismiss.
 * It requires a user action, for it to be dismissed. Banners should appear at the top of the screen, below a top app bar.
 */
export declare const HvBanner: ForwardRefExoticComponent<Omit<HvBannerProps, "ref"> & RefAttributes<unknown>>;

export declare type HvBannerActionPosition = "auto" | "inline" | "bottom-right";

export declare type HvBannerClasses = ExtractNames<typeof useClasses_29>;

export declare const HvBannerContent: ForwardRefExoticComponent<Omit<HvBannerContentProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvBannerContentClasses = ExtractNames<typeof useClasses_30>;

export declare interface HvBannerContentProps extends Omit<SnackbarContentProps, "variant" | "classes" | "onClose"> {
    /** The message to display. @deprecated use `children` instead */
    content?: string;
    /** The message to display. */
    children?: React.ReactNode;
    /** Variant of the snackbar. */
    variant?: HvBannerVariant;
    /** Controls if the associated icon to the variant should be shown. */
    showIcon?: boolean;
    /** Custom icon to replace the variant default. */
    customIcon?: React.ReactNode;
    /** Function called when clicking on the close button. */
    onClose?: (event: React.MouseEvent<HTMLButtonElement>) => void;
    /** Actions to display on the right side. */
    actions?: HvActionsGenericProps["actions"];
    /**
     * The callback function called when an action is triggered, receiving `action` as parameter.
     *
     * @deprecated Use `onAction` instead.
     * */
    actionsCallback?: HvActionsGenericProps["actionsCallback"];
    /** The callback function called when an action is triggered, receiving `action` as parameter. */
    onAction?: HvActionsGenericProps["onAction"];
    /** The position property of the header. */
    actionsPosition?: HvBannerActionPosition;
    /** The props to pass down to the Action Container. */
    actionProps?: Partial<HvButtonProps>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvBannerContentClasses;
}

export declare interface HvBannerProps extends Omit<SnackbarProps, "anchorOrigin" | "classes" | "onClose"> {
    /** If true, the snackbar is open. */
    open: boolean;
    /**
     * Callback fired when the component requests to be closed.
     * Typically onClose is used to set state in the parent component, which is used to control the Snackbar open prop.
     * The reason parameter can optionally be used to control the response to onClose, for example ignoring click away.
     * */
    onClose?: (event: React.MouseEvent<HTMLButtonElement>) => void;
    /** The message to display. */
    label?: string;
    /** The anchor of the Snackbar. */
    anchorOrigin?: "top" | "bottom";
    /** Variant of the snackbar. */
    variant?: HvBannerVariant;
    /** Custom icon to replace the variant default. */
    customIcon?: React.ReactNode;
    /** Controls if the associated icon to the variant should be shown. */
    showIcon?: boolean;
    /** Actions to display on the right side. */
    actions?: HvActionsGenericProps["actions"];
    /**
     * The callback function called when an action is triggered, receiving `action` as parameter.
     *
     * @deprecated Use `onAction` instead.
     * */
    actionsCallback?: HvActionsGenericProps["actionsCallback"];
    /** The callback function called when an action is triggered, receiving `action` as parameter. */
    onAction?: HvActionsGenericProps["onAction"];
    /** The position property of the header. */
    actionsPosition?: HvBannerActionPosition;
    /** How much the transition animation last in milliseconds, if 0 no animation is played. */
    transitionDuration?: number;
    /** Direction of slide transition. */
    transitionDirection?: "up" | "down" | "left" | "right";
    /** The container the banner should slide from. */
    container?: SlideProps["container"];
    /** Offset from top/bottom of the page, in px. Defaults to 60px. */
    offset?: number;
    /** Props to pass down to the banner Wrapper. An object `actionProps` can be included to be passed as others to actions. */
    bannerContentProps?: HvBannerContentProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvBannerClasses;
    /** @ignore */
    ref?: SnackbarProps["ref"];
}

export declare type HvBannerVariant = "success" | "warning" | "error" | "default";

/**
 * A Checkbox is a mechanism that allows user to select one or more options.
 *
 * The Base Checkbox is a building block of the Checkbox form element. Don't use unless
 * implementing a custom use case not covered by the Checkbox form element.
 */
export declare const HvBaseCheckBox: ForwardRefExoticComponent<Omit<HvBaseCheckBoxProps, "ref"> & RefAttributes<HTMLButtonElement>>;

export declare type HvBaseCheckBoxClasses = ExtractNames<typeof useClasses_31>;

export declare interface HvBaseCheckBoxProps extends Omit<CheckboxProps, "onChange" | "classes"> {
    /**
     * The input name.
     */
    name?: string;
    /**
     * The value of the input.
     *
     * Is up to the application's logic when to consider the submission of this value.
     * Generally it should be used only when the checkbox is neither unchecked nor indeterminate.
     *
     * The default value is "on".
     */
    value?: any;
    /**
     * Indicates that the input is disabled.
     */
    disabled?: boolean;
    /**
     * Indicates that the input is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required.
     */
    required?: boolean;
    /**
     * If `true` the checkbox is selected, if set to `false` the checkbox is not selected.
     *
     * When defined the checkbox state becomes controlled.
     */
    checked?: boolean;
    /**
     * When uncontrolled, defines the initial checked state.
     */
    defaultChecked?: boolean;
    /**
     * If `true` the checkbox visually shows the indeterminate state.
     */
    indeterminate?: boolean;
    /**
     * The callback fired when the checkbox is pressed.
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>, checked: boolean, value: any) => void;
    /**
     * Whether the selector should use semantic colors.
     */
    semantic?: boolean;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible?: (event: React.FocusEvent<any>) => void;
    /**
     * Callback fired when the component is blurred.
     */
    onBlur?: (event: React.FocusEvent<HTMLButtonElement>) => void;
    /**
     * A Jss Object used to override or extend the styles applied to the checkbox.
     */
    classes?: HvBaseCheckBoxClasses;
}

export { HvBaseColor }

export declare type HvBaseColorKeys = HvBaseColor;

export declare type HvBaseColors = Record<HvBaseColorKeys, string>;

export declare const HvBaseDropdown: ForwardRefExoticComponent<Omit<HvBaseDropdownProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvBaseDropdownClasses = ExtractNames<typeof useClasses_19>;

export declare interface HvBaseDropdownProps extends HvBaseProps<HTMLDivElement, "onToggle"> {
    /**
     * The role of the element that triggers the popup.
     *
     * Defaults to "combobox" if `component` and the default
     * "textbox" header is used, undefined otherwise.
     */
    role?: string;
    /**
     * Header placeholder.
     */
    placeholder?: React.ReactNode;
    /**
     * If `true` the dropdown is disabled unable to be interacted, if `false` it is enabled.
     */
    disabled?: boolean;
    /**
     * If `true` the dropdown will be in read only mode, unable to be interacted.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required on the form element.
     */
    required?: boolean;
    /**
     * Disable the portal behavior.
     * The children stay within it's parent DOM hierarchy.
     */
    disablePortal?: boolean;
    /**
     * If `true` the dropdown width depends size of content if `false` the width depends on the header size.
     * Defaults to `false`.
     */
    variableWidth?: boolean;
    /**
     * If `true` the dropdown starts opened if `false` it starts closed.
     */
    expanded?: boolean;
    /**
     * When uncontrolled, defines the initial expanded state.
     */
    defaultExpanded?: boolean;
    /**
     * An object containing props to be wired to the popper component.
     */
    popperProps?: Partial<PopperProps_2<any>>;
    /**
     * Placement of the dropdown.
     */
    placement?: "left" | "right";
    /**
     * Replacement for the header component.
     * @deprecated use `headerComponent` instead
     */
    component?: React.ReactNode;
    /** Replacement for the header component */
    headerComponent?: React.ElementType;
    /**
     * Adornment to replace the default arrows.
     */
    adornment?: React.ReactNode;
    /**
     * When dropdown changes the expanded state.
     */
    onToggle?: (event: Event, open: boolean) => void;
    /**
     * When user click outside the open container.
     */
    onClickOutside?: (event: Event) => void;
    /**
     * Callback called when the dropdown is opened and ready,
     * commonly used to set focus to the content.
     */
    onContainerCreation?: (container: HTMLElement | null) => void;
    /**
     * Attributes applied to the dropdown header element.
     */
    dropdownHeaderProps?: React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>;
    /**
     * Pass a ref to the dropdown header element.
     */
    dropdownHeaderRef?: React.Ref<HTMLDivElement>;
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvBaseDropdownClasses;
    /** @ignore */
    ref?: React.Ref<HTMLDivElement>;
}

/**
 * An Input component that only posses the most basic functionalities.
 * It should be used alongside the other form elements to construct a proper accessible form.
 */
export declare const HvBaseInput: ForwardRefExoticComponent<HvBaseInputProps & RefAttributes<HTMLInputElement>>;

export declare type HvBaseInputClasses = ExtractNames<typeof useClasses_18>;

export declare interface HvBaseInputProps extends Omit<InputBaseProps, "onChange" | "classes" | "ref" | "color" | "size"> {
    /** The input name. */
    name?: string;
    /** The value of the input, when controlled. */
    value?: React.InputHTMLAttributes<HTMLInputElement>["value"];
    /** The initial value of the input, when uncontrolled. */
    defaultValue?: React.InputHTMLAttributes<HTMLInputElement>["value"];
    /** If `true` the input is disabled. */
    disabled?: boolean;
    /** Indicates that the input is not editable. */
    readOnly?: boolean;
    /** If true, the input element will be required. */
    required?: boolean;
    /**
     * Callback fired when the value is changed.
     *
     * You can pull out the new value by accessing `event.target.value` (string),
     * or using the second callback argument.
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>, value: string) => void;
    /** If true, a textarea element will be rendered. */
    multiline?: boolean;
    /** If true and multiline is also true the textarea element will be resizable. */
    resizable?: boolean;
    /** Denotes if the input is in an invalid state. */
    invalid?: boolean;
    /**
     * Allows passing a ref to the underlying input
     * @deprecated Use `ref` directly instead
     * */
    inputRef?: InputBaseProps["inputRef"];
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvBaseInputClasses;
}

/** HV Base Props. Extends `React.HTMLAttributes` of an element `E`, and filters `K` keys. */
export declare type HvBaseProps<E extends HTMLElement = HTMLDivElement, K extends keyof React.HTMLAttributes<E> = never> = Omit<React.HTMLAttributes<E>, K>;

/**
 * A Radio Button is a mechanism that allows user to select one or more options.
 *
 * The Base Radio Button is a building block of the Radio Button form element. Don't
 * use unless implementing a custom use case not covered by the Radio Button form element.
 */
export declare const HvBaseRadio: ForwardRefExoticComponent<Omit<HvBaseRadioProps, "ref"> & RefAttributes<HTMLButtonElement>>;

export declare type HvBaseRadioClasses = ExtractNames<typeof useClasses_32>;

export declare interface HvBaseRadioProps extends Omit<RadioProps, "onChange" | "classes"> {
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the radio button.
     */
    classes?: HvBaseRadioClasses;
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * The input name.
     */
    name?: string;
    /**
     * The value of the input.
     *
     * The default value is "on".
     */
    value?: any;
    /**
     * Indicates that user input is required.
     */
    required?: boolean;
    /**
     * Indicates that the input is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that the input is disabled.
     */
    disabled?: boolean;
    /**
     * If `true` the radio button is selected, if set to `false` the radio button is not selected.
     *
     * When defined the radio button state becomes controlled.
     */
    checked?: boolean;
    /**
     * When uncontrolled, defines the initial checked state.
     */
    defaultChecked?: boolean;
    /**
     * The callback fired when the radio button is pressed.
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>, checked: boolean, value: any) => void;
    /**
     * Whether the selector should use semantic colors.
     */
    semantic?: boolean;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible?: (event: React.FocusEvent<any>) => void;
    /**
     * @ignore
     */
    onBlur?: (event: React.FocusEvent<any>) => void;
}

/**
 * A Switch is <b>binary</b> and work as a digital on/off button.
 *
 * The Base Switch is a building block of the Switch form element. Don't use unless
 * implementing a custom use case not covered by the Switch form element.
 */
export declare const HvBaseSwitch: ForwardRefExoticComponent<Omit<HvBaseSwitchProps, "ref"> & RefAttributes<HTMLButtonElement>>;

export declare type HvBaseSwitchClasses = ExtractNames<typeof useClasses_33>;

export declare interface HvBaseSwitchProps extends Omit<SwitchProps, "onChange" | "classes"> {
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the switch.
     */
    classes?: HvBaseSwitchClasses;
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * The input name.
     */
    name?: string;
    /**
     * The value of the input.
     *
     * Is up to the application's logic when to consider the submission of this value.
     * Generally it should be used only when the switch is neither unchecked nor indeterminate.
     *
     * The default value is "on".
     */
    value?: any;
    /**
     * Indicates that user input is required.
     */
    required?: boolean;
    /**
     * Indicates that the input is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that the input is disabled.
     */
    disabled?: boolean;
    /**
     * If `true` the switch is selected, if set to `false` the switch is not selected.
     *
     * When defined the switch state becomes controlled.
     */
    checked?: boolean;
    /**
     * When uncontrolled, defines the initial checked state.
     */
    defaultChecked?: boolean;
    /**
     * The callback fired when the switch is pressed.
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>, checked: boolean, value: any) => void;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible?: (event: React.FocusEvent<any>) => void;
    /**
     * @ignore
     */
    onBlur?: (event: React.FocusEvent<any>) => void;
}

export { HvBaseTheme }

/**
 * Customizable layout component that can be used to wrap other components.
 * It can be used to add styles to the wrapped components.
 * It can also be used to create a layout using the flexbox properties.
 * @deprecated use native elements instead (e.g. `div`)
 */
export declare const HvBox: <C extends React.ElementType = "div">(props: {
    style?: React.CSSProperties;
    sx?: React.CSSProperties | ((theme: HvTheme_2) => React.CSSProperties);
} & {
    component?: C | undefined;
} & {
    children?: ReactNode | undefined;
} & (Omit<PropsWithoutRef<ComponentProps<C>>, "style" | "component" | "sx"> extends infer T ? T extends Omit<PropsWithoutRef<ComponentProps<C>>, "style" | "component" | "sx"> ? T extends any ? T : never : never : never) & {
    ref?: PolymorphicRef<C> | undefined;
} & RefAttributes<unknown>) => React.ReactElement | null;

export declare type HvBoxProps<C extends React.ElementType = "div"> = PolymorphicComponentRef<C, {
    style?: React.CSSProperties;
    sx?: React.CSSProperties | ((theme: HvTheme_2) => React.CSSProperties);
}>;

/**
 * A breadcrumb is a graphical control element frequently used as a navigational aid.
 */
export declare const HvBreadCrumb: ForwardRefExoticComponent<HvBreadCrumbProps & RefAttributes<HTMLElement>>;

export declare type HvBreadCrumbClasses = ExtractNames<typeof useClasses_34>;

export declare interface HvBreadCrumbPathElement extends Record<string, any> {
    label: string;
    path: string;
}

export declare interface HvBreadCrumbProps extends HvBaseProps<HTMLDivElement, "onClick"> {
    /** List of breadcrumb. */
    listRoute?: HvBreadCrumbPathElement[];
    /** URL to build the breadcrumb. */
    url?: string;
    /** Number of pages visible. */
    maxVisible?: number;
    /** The component used for the link node. Either a string to use a DOM element or a component. */
    component?: React.ElementType;
    /** Function passed to the component. If defined the component prop is used as the link node. */
    onClick?: (event: React.MouseEvent<HTMLElement>, data: any) => void;
    /** Props passed down to the DropDownMenu sub-menu component. */
    dropDownMenuProps?: Partial<HvDropDownMenuProps>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvBreadCrumbClasses;
}

export { HvBreakpoints }

/**
 * Bulk Actions allow users to perform an action on a single or multiple items.
 * Also known as "batch production" of multiple items at once, one stage at a time.
 */
export declare const HvBulkActions: ForwardRefExoticComponent<HvBulkActionsProps & RefAttributes<HTMLDivElement>>;

export declare type HvBulkActionsClasses = ExtractNames<typeof useClasses_35>;

export declare type HvBulkActionsPropGetter<D extends object> = PropGetter<D, HvTAbleBulkActionsProps>;

export declare interface HvBulkActionsProps extends HvBaseProps {
    /** Custom label for select all checkbox. @deprecated no longer used */
    selectAllLabel?: React.ReactNode;
    /** Custom label for select all checkbox conjunction */
    selectAllConjunctionLabel?: string;
    /** Custom label for select all pages button */
    selectAllPagesLabel?: React.ReactNode;
    /** Whether select all pages element should be visible */
    showSelectAllPages?: boolean;
    /** The total number of elements */
    numTotal?: number;
    /** The number of elements currently selected */
    numSelected?: number;
    /** Function called when the "select all" Checkbox is toggled. */
    onSelectAll?: HvCheckBoxProps["onChange"];
    /** Function called when the "select all pages" button is clicked toggled. */
    onSelectAllPages?: HvButtonProps["onClick"];
    /** Whether the bulk actions should use the semantic styles when there are selected elements. */
    semantic?: boolean;
    /** The renderable content inside the right actions slot, or an array of actions `{ id, label, icon, disabled, ... }` */
    actions?: HvActionsGenericProps["actions"];
    /** Whether actions should be all disabled */
    actionsDisabled?: boolean;
    /**
     * The callback function called when an action is triggered, receiving `action` as parameter.
     *
     * @deprecated Use `onAction` instead.
     * */
    actionsCallback?: HvActionsGenericProps["actionsCallback"];
    /** The callback function called when an action is triggered, receiving `action` as parameter. */
    onAction?: HvActionsGenericProps["onAction"];
    /** The number of maximum visible actions before they're collapsed into a `DropDownMenu`. */
    maxVisibleActions?: number;
    /** Properties to be passed onto the checkbox component, the values of the object are equivalent to the HvCheckbox API. */
    checkboxProps?: HvCheckBoxProps;
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvBulkActionsClasses;
}

/**
 * Button component is used to trigger an action or event.
 */
export declare const HvButton: <C extends React.ElementType = "button">(props: {
    /** Use the variant prop to change the visual style of the button. */
    variant?: HvButtonVariant;
    /** Whether the button is an icon-only button. */
    icon?: boolean;
    /** Whether the button is disabled or not. */
    disabled?: boolean;
    /** Class names to be applied. */
    className?: string;
    /** Element placed before the children. */
    startIcon?: React.ReactNode;
    /** Element placed after the children. */
    endIcon?: React.ReactNode;
    /** Color of the button. */
    color?: HvColorAny;
    /** Button size. */
    size?: HvSize;
    /** Button border radius. */
    radius?: HvRadius;
    /** Defines the default colors of the button are forced into the icon. */
    overrideIconColors?: boolean;
    /** A Jss Object used to override or extend the styles applied. */
    classes?: Partial<{
        root: string;
        startIcon: string;
        endIcon: string;
        focusVisible: string;
        disabled: string;
        icon: string;
        contained: string;
        subtle: string;
        ghost: string;
        semantic: string;
        primary: string;
        primarySubtle: string;
        primaryGhost: string;
        secondarySubtle: string;
        secondaryGhost: string;
        secondary: string;
    }>;
    /** Whether the button is selected or not. */
    selected?: boolean;
    /**
     * Whether the button is focusable when disabled.
     * Without this property, the accessibility of the button decreases when disabled since it's not read by screen readers.
     * Set this property to `true` when you need the button to still be focusable when disabled for accessibility purposes.
     */
    focusableWhenDisabled?: boolean;
} & {
    component?: C | undefined;
} & {
    children?: ReactNode | undefined;
} & (Omit<PropsWithoutRef<ComponentProps<C>>, "color" | "classes" | "disabled" | "icon" | "selected" | "variant" | "size" | "component" | "className" | "radius" | "focusableWhenDisabled" | "startIcon" | "endIcon" | "overrideIconColors"> extends infer T ? T extends Omit<PropsWithoutRef<ComponentProps<C>>, "color" | "classes" | "disabled" | "icon" | "selected" | "variant" | "size" | "component" | "className" | "radius" | "focusableWhenDisabled" | "startIcon" | "endIcon" | "overrideIconColors"> ? T extends any ? T : never : never : never) & {
    ref?: PolymorphicRef<C> | undefined;
} & RefAttributes<unknown>) => React.ReactElement | null;

/**
 * Button component is used to trigger an action or event.
 */
export declare const HvButtonBase: <C extends React.ElementType = "button">(props: {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: Partial<{
        root: string;
        disabled: string;
    }>;
    /** Whether the button is selected or not. */
    selected?: boolean;
    /** Whether the button is disabled or not. */
    disabled?: boolean;
    /**
     * Whether the button is focusable when disabled.
     * Without this property, the accessibility of the button decreases when disabled since it's not read by screen readers.
     * Set this property to `true` when you need the button to still be focusable when disabled for accessibility purposes.
     */
    focusableWhenDisabled?: boolean;
} & {
    component?: C | undefined;
} & {
    children?: ReactNode | undefined;
} & (Omit<PropsWithoutRef<ComponentProps<C>>, "classes" | "disabled" | "selected" | "component" | "focusableWhenDisabled"> extends infer T ? T extends Omit<PropsWithoutRef<ComponentProps<C>>, "classes" | "disabled" | "selected" | "component" | "focusableWhenDisabled"> ? T extends any ? T : never : never : never) & {
    ref?: PolymorphicRef<C> | undefined;
} & RefAttributes<unknown>) => React.ReactElement | null;

export declare type HvButtonBaseClasses = ExtractNames<typeof useClasses_2>;

export declare type HvButtonBaseProps<C extends React.ElementType = "button"> = PolymorphicComponentRef<C, {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvButtonBaseClasses;
    /** Whether the button is selected or not. */
    selected?: boolean;
    /** Whether the button is disabled or not. */
    disabled?: boolean;
    /**
     * Whether the button is focusable when disabled.
     * Without this property, the accessibility of the button decreases when disabled since it's not read by screen readers.
     * Set this property to `true` when you need the button to still be focusable when disabled for accessibility purposes.
     */
    focusableWhenDisabled?: boolean;
}>;

export declare type HvButtonClasses = ExtractNames<typeof useClasses_13>;

export declare type HvButtonProps<C extends React.ElementType = "button"> = PolymorphicComponentRef<C, {
    /** Use the variant prop to change the visual style of the button. */
    variant?: HvButtonVariant;
    /** Whether the button is an icon-only button. */
    icon?: boolean;
    /** Whether the button is disabled or not. */
    disabled?: boolean;
    /** Class names to be applied. */
    className?: string;
    /** Element placed before the children. */
    startIcon?: React.ReactNode;
    /** Element placed after the children. */
    endIcon?: React.ReactNode;
    /** Color of the button. */
    color?: HvColorAny;
    /** Button size. */
    size?: HvSize;
    /** Button border radius. */
    radius?: HvRadius;
    /** Defines the default colors of the button are forced into the icon. */
    overrideIconColors?: boolean;
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvButtonClasses;
    /** Whether the button is selected or not. */
    selected?: boolean;
    /**
     * Whether the button is focusable when disabled.
     * Without this property, the accessibility of the button decreases when disabled since it's not read by screen readers.
     * Set this property to `true` when you need the button to still be focusable when disabled for accessibility purposes.
     */
    focusableWhenDisabled?: boolean;
}>;

/** @deprecated use `HvRadius` */
export declare type HvButtonRadius = HvRadius;

/** @deprecated use `HvSize` */
export declare type HvButtonSize = HvSize;

export declare type HvButtonVariant = "contained" | "subtle" | "ghost" | `primary${TypeSuffix}` | `secondary${TypeSuffix}` | `positive${TypeSuffix}` | `negative${TypeSuffix}` | `warning${TypeSuffix}` | "semantic";

export declare const HvCalendar: (props: HvCalendarProps) => JSX_2.Element;

export declare type HvCalendarClasses = ExtractNames<typeof useClasses_37>;

export declare const HvCalendarHeader: {
    (props: HvCalendarHeaderProps): JSX_2.Element;
    formElementType: string;
};

export declare type HvCalendarHeaderClasses = ExtractNames<typeof useClasses_38>;

export declare interface HvCalendarHeaderProps extends Pick<HvSingleCalendarProps, "id" | "value" | "locale" | "onChange" | "showEndDate" | "showDayOfWeek" | "invalidDateLabel"> {
    /**
     * A Jss Object used to override or extend the component styles.
     */
    classes?: HvCalendarHeaderClasses;
    /**
     * Callback to handle input onFocus.
     */
    onFocus?: (event: React.FocusEvent<HTMLTextAreaElement | HTMLInputElement>, formattedDate: string | null) => void;
}

export declare interface HvCalendarProps extends Omit<React.HTMLAttributes<HTMLDivElement>, "onChange"> {
    /**
     * Styles applied from the theme.
     */
    classes?: HvCalendarClasses;
    /**
     * The calendar locale.
     */
    locale?: string;
    /**
     * Date that the calendar would show.
     * if using the object format the calendar enter in range mode showing two calendars
     */
    value?: DateRangeProp | Date;
    /**
     * Controls the visible month of the Calendar
     */
    visibleMonth?: number;
    /**
     * Controls the visible year of the Calendar
     */
    visibleYear?: number;
    /**
     * Controls the visible month of the Calendar on the right side of the datepicker
     */
    rightVisibleMonth?: number;
    /**
     * Controls the visible year of the Calendar on the right side of the datepicker
     */
    rightVisibleYear?: number;
    /**
     * Callback function to be triggered when the selected date has changed.
     */
    onChange?: (event: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement> | undefined, value: Date | DateRangeProp) => void;
    /**
     * Callback function to be triggered when the selected date input has changed.
     */
    onInputChange?: (event: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement | HTMLButtonElement> | undefined, value: Date | DateRangeProp, position: "left" | "right") => void;
    /**
     * Callback function to be triggered when the user clicks on the month or year selector.
     * it receives the action that was pressed:
     * previous_month, next_month, previous_year, next_year,month
     */
    onVisibleDateChange?: (event: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement> | undefined, action: VisibilitySelectorActions, value?: Date | DateRangeProp | number, position?: "left" | "right") => void;
    /**
     * The maximum selectable date after this all values are disabled.
     */
    maximumDate?: Date;
    /**
     * The minimum selectable date before this all values are disabled.
     */
    minimumDate?: Date;
    /**
     * An element placed before the Calendar
     */
    startAdornment?: React.ReactNode;
    /**
     * Indicates if header should display the day of week.
     */
    showDayOfWeek?: boolean;
    /**
     * Label shown when date is invalid.
     */
    invalidDateLabel?: string;
}

/**
 * A card is a container for a few short and related pieces of content.
 * It roughly resembles a playing card in size and shape and is intended as a
 * linked short representation of a conceptual unit. For that reason,
 * this pattern must be used as an entry-point for further information.
 */
export declare const HvCard: ForwardRefExoticComponent<HvCardProps & RefAttributes<HTMLDivElement>>;

export declare type HvCardClasses = ExtractNames<typeof useClasses_40>;

export declare const HvCardContent: (props: HvCardContentProps) => JSX_2.Element;

export declare type HvCardContentClasses = ExtractNames<typeof useClasses_42>;

export declare interface HvCardContentProps extends Omit<CardContentProps, "classes"> {
    /** The function that will be executed when this section is clicked. */
    onClick?: (event: React.SyntheticEvent) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvCardContentClasses;
}

export declare const HvCardHeader: (props: HvCardHeaderProps) => JSX_2.Element;

export declare type HvCardHeaderClasses = ExtractNames<typeof useClasses_41>;

export declare interface HvCardHeaderProps extends Omit<CardHeaderProps, "classes"> {
    /** The renderable content inside the title slot of the header. */
    title: React.ReactNode;
    /** The renderable content inside the subheader slot of the header. */
    subheader?: React.ReactNode;
    /** The renderable content inside the icon slot of the header. */
    icon?: React.ReactNode;
    /** The function that will be executed when this section is clicked. */
    onClick?: React.MouseEventHandler<HTMLDivElement> | undefined;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvCardHeaderClasses;
}

export declare const HvCardMedia: ({ classes: classesProp, className, children, ...others }: HvCardMediaProps) => JSX_2.Element;

export declare type HvCardMediaClasses = ExtractNames<typeof useClasses_43>;

export declare interface HvCardMediaProps extends Omit<CardMediaProps, "classes">, React.ImgHTMLAttributes<HTMLDivElement> {
    /** The title of the media. */
    title?: string;
    /** The function that will be executed when this section is clicked. */
    onClick?: React.MouseEventHandler<HTMLDivElement> | undefined;
    /** The component used for the root node. Either a string to use a HTML element or a component. */
    component?: React.ElementType;
    /** The image to display. */
    image?: string;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvCardMediaClasses;
}

export declare interface HvCardProps extends HvBaseProps {
    /** The renderable content inside the icon slot of the header. */
    icon?: React.ReactNode;
    /** Whether the card is selectable. */
    selectable?: boolean;
    /** Whether the card is currently selected. */
    selected?: boolean;
    /** The background color of the card. */
    bgcolor?: "sema0" | HvColorAny;
    /**
     *  The border color at the top of the card. Must be one of palette semantic or atmosphere colors.
     *  To set another color, the borderTop should be override.
     */
    statusColor?: "sema0" | HvColorAny;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvCardClasses;
}

/**
 * A Carousel is commonly used to browse images, it can also be used to browse any kind of content like text, video, or charts.
 * It allows you to focus on a particular content while having a notion of how many you have to explore.
 */
export declare const HvCarousel: ForwardRefExoticComponent<HvCarouselProps & RefAttributes<HTMLDivElement>>;

export declare type HvCarouselClasses = ExtractNames<typeof useClasses_44>;

export declare const HvCarouselControls: (props: HvCarouselControlsProps) => JSX_2.Element;

declare interface HvCarouselControlsProps extends HvBaseProps<HTMLDivElement>, Pick<HvPaginationProps, "page" | "pages" | "canPrevious" | "canNext"> {
    showDots?: boolean;
    classes?: ExtractNames<typeof useClasses_44>;
    actions?: React.ReactNode;
    onPreviousClick?: React.MouseEventHandler<HTMLButtonElement>;
    onNextClick?: React.MouseEventHandler<HTMLButtonElement>;
    /** Labels used on the component. */
    labels?: Partial<typeof DEFAULT_LABELS_5>;
}

export declare interface HvCarouselProps extends HvBaseProps<HTMLDivElement, "title" | "onChange"> {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvCarouselClasses;
    /** Height of the Slider container. If `undefined`, images will keep a 16/9 aspect-ratio */
    height?: React.CSSProperties["height"];
    /** Width of the thumbnail. Height will try to maintain a 16/9 aspect-ratio */
    thumbnailWidth?: React.CSSProperties["width"];
    /** Title of the carousel */
    title?: React.ReactNode;
    /** Content slides to be displayed. @see `<HvCarouselSlide />` */
    children?: React.ReactNode;
    /** Custom content to render in the actions area */
    actions?: React.ReactNode;
    /** Whether Carousel is in "xs mode" - to use in embedded contexts */
    xs?: boolean;
    /** Whether to show dots instead of arrow pagination. Defaults to true under 5 elements */
    showDots?: boolean;
    /** Whether to show the counter on the top-right corner of the active slide */
    showCounter?: boolean;
    /** Whether to show the back/forwards buttons over the active slide */
    showSlideControls?: boolean;
    /** Whether to enable the fullscreen toggle button */
    showFullscreen?: boolean;
    /** Whether to hide the thumbnails. Hidden by default in "xs" mode */
    hideThumbnails?: boolean;
    /** Controls position. */
    controlsPosition?: "top" | "bottom";
    /** Thumbnails position. */
    thumbnailsPosition?: "top" | "bottom";
    /** Carousel configuration options. @see https://www.embla-carousel.com/api/options/ */
    carouselOptions?: Parameters<typeof default_2>[0];
    /** Function that renders the thumbnail.  */
    renderThumbnail?: (index: number) => React.ReactNode;
    /** The callback fired when the active slide changes. */
    onChange?: (index: number) => void;
    /** The callback fired fullscreen is toggled. */
    onFullscreen?: (event: React.MouseEvent<HTMLButtonElement>, isFullscreen: boolean) => void;
    /** Labels used on the component. */
    labels?: Partial<typeof DEFAULT_LABELS_2>;
}

/**
 * A container to use as `children` of `HvCarousel`.
 * Pass `img` props directly to it, or `children` for any custom content
 */
export declare const HvCarouselSlide: ({ classes: classesProp, className, children, size: flexBasis, src, alt, ...props }: HvCarouselSlideProps) => JSX_2.Element;

export declare type HvCarouselSlideClasses = ExtractNames<typeof useClasses_45>;

export declare interface HvCarouselSlideProps extends React.ImgHTMLAttributes<HTMLImageElement> {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvCarouselSlideClasses;
    /** The width of the Slide. Defaults to `100%` */
    size?: string;
    /** Content of a slide to be displayed */
    children?: React.ReactNode;
}

export declare const HvCarouselThumbnails: ForwardRefExoticComponent<HvCarouselThumbnailsProps & RefAttributes<HTMLDivElement>>;

declare interface HvCarouselThumbnailsProps extends HvBaseProps<HTMLDivElement, "children">, Pick<HvPaginationProps, "page" | "pages" | "canPrevious" | "canNext"> {
    width?: React.CSSProperties["width"];
    classes?: ExtractNames<typeof useClasses_44>;
    onThumbnailClick?: (event: React.MouseEvent<HTMLButtonElement>, index: number) => void;
    thumbnailProps?: Partial<HvButtonProps>;
    showDots?: boolean;
    renderThumbnail?: (index: number) => React.ReactNode;
}

export { HvCategoricalColor }

export declare type HvCategoricalColorKeys = HvCategoricalColor;

export declare interface HvCellInstance<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, V = any> extends Omit<Cell<D, V>, "column" | "row" | "getCellProps">, Partial<UseGroupByCellProps<D>> {
    column: HvColumnInstance<D, H>;
    row: HvRowInstance<D, H>;
    getCellProps: (propGetter?: HvCellPropGetter<D, H>) => HvUseTableCellProps;
}

declare type HvCellPropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvPropGetter<D, H, HvUseTableCellProps, {
    cell: HvCellInstance<D, H>;
}>;

export declare interface HvCellProps<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, V = any> extends HvTableInstance<D, H> {
    column: HvColumnInstance<D, H>;
    row: HvRowInstance<D, H>;
    cell: HvCellInstance<D, H, V>;
    value: CellValue<V>;
}

/**
 * Displays the capacity and current usage of a text input box (character count by default).
 *
 * Use the character counter when there is a character or word limit.
 * By itself it doesn't block the user from going above the limit.
 */
export declare const HvCharCounter: (props: HvCharCounterProps) => JSX_2.Element;

export declare type HvCharCounterClasses = ExtractNames<typeof useClasses_6>;

export declare interface HvCharCounterProps extends HvBaseProps {
    /** The string that separates the current char quantity from the max quantity. */
    separator?: string;
    /** The maximum allowed length of the characters. */
    maxCharQuantity: number;
    /** The current char quantity to be rendered. */
    currentCharQuantity?: number;
    /** If `true` the counter is disabled. */
    disabled?: boolean;
    /** If `true` the info message won't have margins. */
    disableGutter?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvCharCounterClasses;
}

/**
 * A Checkbox is a mechanism that allows the user to select one or more options.
 *
 * Usually used in a Checkbox Group to present the user with a range of options from
 * which the user **may select any number of options** to complete their task.
 *
 * It can also be used individually to represent the toggle of a single option, when
 * the Toggle Switch and Toggle Button aren't more appropriate.
 */
export declare const HvCheckBox: ForwardRefExoticComponent<Omit<HvCheckBoxProps, "ref"> & RefAttributes<HTMLButtonElement>>;

export declare type HvCheckBoxClasses = ExtractNames<typeof useClasses_36>;

/**
 * A checkbox group is a type of selection list that allows the user to select multiple options through the use of checkboxes.
 */
export declare const HvCheckBoxGroup: ForwardRefExoticComponent<HvCheckBoxGroupProps & RefAttributes<HTMLDivElement>>;

export declare type HvCheckBoxGroupClasses = ExtractNames<typeof useClasses_48>;

export declare interface HvCheckBoxGroupProps extends HvBaseProps<HTMLDivElement, "onChange"> {
    /**
     * The form element name.
     *
     * It is propagated to the children checkboxes, unless they already have one.
     */
    name?: string;
    /**
     * The value of the form element. An array of values represented in the child checkboxes.
     *
     * When defined the checkbox group state becomes controlled.
     */
    value?: any[];
    /**
     * When uncontrolled, defines the initial value.
     */
    defaultValue?: any[];
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /**
     * Provide additional descriptive text for the form element.
     */
    description?: React.ReactNode;
    /**
     * Indicates that the form element is disabled.
     * If `true` the state is propagated to the children checkboxes.
     */
    disabled?: boolean;
    /**
     * Indicates that the form element is not editable.
     * If `true` the state is propagated to the children checkboxes.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required on the form element.
     */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when the validation status is "invalid".
     *
     * Defaults to "Required" when the status is uncontrolled and no `aria-errormessage` is provided.
     */
    statusMessage?: React.ReactNode;
    /**
     * The callback fired when the value changes.
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>, value: any[]) => void;
    /**
     * Indicates whether the checkbox group's orientation is horizontal or vertical.
     *
     * Defaults to vertical.
     */
    orientation?: "vertical" | "horizontal";
    /**
     * Indicates if an additional select all checkbox should be shown.
     */
    showSelectAll?: boolean;
    /**
     * The label of the select all checkbox. Defaults to "All". @deprecated no longer used
     */
    selectAllLabel?: string;
    /**
     * Custom label for select all checkbox conjunction
     */
    selectAllConjunctionLabel?: string;
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvCheckBoxGroupClasses;
}

export declare interface HvCheckBoxProps extends Omit<HvBaseCheckBoxProps, "classes"> {
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be inputted via inputProps.
     */
    label?: React.ReactNode;
    /**
     * Properties passed on to the label element.
     */
    labelProps?: HvLabelProps;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when the validation status is "invalid".
     *
     * Defaults to "Required" when the status is uncontrolled and no `aria-errormessage` is provided.
     */
    statusMessage?: React.ReactNode;
    /**
     * A Jss Object used to override or extend the styles applied to the checkbox.
     */
    classes?: HvCheckBoxClasses;
}

export declare type HvClickOutsideEvent = MouseEvent | KeyboardEvent | TouchEvent;

export { HvColor }

export { HvColorAny }

/**
 * A color picker component which allows the user to select a color from a list of pre-defined colors or freely select one color via the Hue and Saturation.
 * It receives a color string in HEX format and outputs an HEX formatted color.
 */
export declare const HvColorPicker: ForwardRefExoticComponent<HvColorPickerProps & RefAttributes<HTMLDivElement>>;

export declare type HvColorPickerClasses = ExtractNames<typeof useClasses_49>;

export declare interface HvColorPickerProps {
    "aria-label"?: string;
    "aria-labelledby"?: string;
    "aria-describedby"?: string;
    /** Class names to be applied. */
    className?: string;
    /** Id to be applied to the form element root node. */
    id?: string;
    /** The form element name. */
    name?: string;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /** Provide additional descriptive text for the form element. */
    description?: React.ReactNode;
    /** Indicates that user input is required on the form element. */
    required?: boolean;
    /** The value color, in HEX format. */
    value?: string;
    /** The default value color, in HEX format. */
    defaultValue?: string;
    /** If `true` the dropdown is disabled unable to be interacted, if `false` it is enabled. */
    disabled?: boolean;
    /** If `true` the dropdown starts opened if `false` it starts closed. */
    expanded?: boolean;
    /** When uncontrolled, defines the initial expanded state. */
    defaultExpanded?: boolean;
    /** A function to be executed whenever the color changes. */
    onChange?: (color: string) => void;
    /** A function to be executed whenever the color change is complete. */
    onChangeComplete?: (color: string) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvColorPickerClasses;
    /** The placeholder value when nothing is selected. */
    placeholder?: string;
    /** Recommended colors. The colors are HEX values. */
    recommendedColors?: string[];
    /** Recommended colors position. */
    recommendedColorsPosition?: "top" | "bottom";
    /** If `true`, the labels are shown. If `false`, they are not shown. */
    showLabels?: boolean;
    /** An object containing all the labels. */
    labels?: Partial<typeof DEFAULT_LABELS_6>;
    /** Icon type for the input's end adornment. */
    dropdownIcon?: "arrow" | "colorPicker";
    /** If `true`, the input only shows an icon. If `false`, the input shows text and icons. */
    iconOnly?: boolean;
    /** If `true`, the saved colors area is shown. If `false`, it is not shown. */
    showSavedColors?: boolean;
    /** If `true`, the custom colors area is shown. If `false`, it is not shown. */
    showCustomColors?: boolean;
    /** The saved colors. The colors are HEX values. */
    savedColorsValue?: string[];
    /** The default saved colors. The colors are HEX values. */
    defaultSavedColorsValue?: string[];
    /** Callback fired when a new saved color is added. */
    onSavedColorAdded?: (color?: string) => void;
    /** Callback fired when a new saved color is removed. */
    onSavedColorRemoved?: (color?: string) => void;
    /** Aria label to apply to delete saved color button. */
    deleteSavedColorButtonArialLabel?: string;
    /** Aria label to apply to add saved color button. */
    addSavedColorButtonAriaLabel?: string;
}

declare type HvColumnGroup<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvTableColumnOptions<D, H> & HvColumnGroupInterface<D, H> & ({
    Header: H;
} | ({
    id: IdType<D>;
} & {
    Header: H;
})) & {
    accessor?: Accessor<D>;
};

declare interface HvColumnGroupInterface<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> {
    columns: Array<HvTableColumnConfig<D, H>>;
}

export declare interface HvColumnInstance<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<ColumnInstance<D>, "Cell" | "columns" | "parent" | "placeholderOf" | "id" | "Header" | "getHeaderProps" | "getFooterProps" | "Footer">, HvTableColumnOptions<D, H>, Partial<UseFiltersColumnProps<D>>, Partial<UseGroupByColumnProps<D>>, Partial<UseResizeColumnsColumnProps<D>>, Partial<UseSortByColumnProps<D>> {
    Cell?: Renderer<HvCellProps<D, H>>;
    columns: Array<HvColumnInstance<D, H>>;
    parent: HvColumnInstance<D, H>;
    placeholderOf?: HvColumnInstance<D, H>;
    getHeaderProps: (propGetter?: HvHeaderPropGetter<D, H>) => HvUseTableHeaderProps;
    getFooterProps: (propGetter?: HvFooterPropGetter<D, H>) => HvUseTableFooterProps;
}

declare interface HvColumnInterfaceBasedOnValue<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, V = any> {
    Cell?: Renderer<HvCellProps<D, H, V>>;
}

declare type HvColumnWithLooseAccessor<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvTableColumnOptions<D, H> & HvColumnInterfaceBasedOnValue<D, H> & ({
    Header: H;
} | {
    id: IdType<D>;
} | {
    accessor: keyof D extends never ? IdType<D> : never;
}) & {
    accessor?: keyof D extends never ? IdType<D> | Accessor<D> : Accessor<D>;
};

declare type HvColumnWithStrictAccessor<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvTableColumnOptions<D, H> & ValueOf<{
    [K in keyof D]: {
        accessor: K;
    } & HvColumnInterfaceBasedOnValue<D, H, D[K]>;
}>;

/** The container enables you to center your content horizontally and bound it to a specific breakpoint. */
export declare const HvContainer: ForwardRefExoticComponent<Omit<HvContainerProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvContainerClasses = ExtractNames<typeof useClasses_50>;

export declare interface HvContainerProps extends Omit<ContainerProps, "classes"> {
    /**
     * The component used for the root node.
     * Either a string to use a DOM element or a component.
     */
    component?: React.ElementType;
    /**
     * Determine the max-width of the container.
     * The container width grows with the size of the screen.
     * Set to `false` to disable `maxWidth`.
     */
    maxWidth?: "xs" | "sm" | "md" | "lg" | "xl" | false;
    /** If `true`, the left and right padding is removed. */
    disableGutters?: boolean;
    /**
     * Set the max-width to match the min-width of the current breakpoint.
     * This is useful if you'd prefer to design for a fixed set of sizes
     * instead of trying to accommodate a fully fluid viewport.
     * It's fluid by default.
     */
    fixed?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvContainerClasses;
}

export declare const HvControls: (props: HvControlsProps) => JSX_2.Element;

export declare type HvControlsClasses = ExtractNames<typeof useClasses_51>;

export declare interface HvControlsProps extends HvBaseProps {
    /**
     * An instance of useHvTable or useTable used to manage the data
     * if this is not provided data sorting and search must be handled externally
     */
    callbacks?: {
        setSortBy?: HvTableInstance["setSortBy"];
        setGlobalFilter?: HvTableInstance["setGlobalFilter"];
    };
    /**
     * Views configuration required for the view buttons
     */
    views?: HvControlsViewConfiguration[];
    /**
     * What view is selected by default
     */
    defaultView?: string;
    /**
     * Sets the selected view to be the one specified
     * if specified the component is in a controlled state and it won't change it state
     * unless specified externally
     */
    selectedView?: string;
    /**
     * Callback called when the view switcher button is pressed
     */
    onViewChange?: (event: React.MouseEvent<HTMLButtonElement>, id: string) => void;
    /**
     * if `true` the button to switch views is not rendered
     */
    hideViewSwitcher?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvControlsClasses;
}

export declare interface HvControlsViewConfiguration extends Record<string, any> {
    id?: string;
    label?: string;
    icon?: React.ReactNode;
}

/**
 * Create theme props
 */
export declare interface HvCreateThemeProps extends HvThemeCustomizationProps {
    /**
     * The name used for the theme.
     *
     * This is a required property to create a theme.
     */
    name: string;
    /**
     * The theme to be used as base.
     *
     * `"ds5"` will be used as default if no value is provided.
     */
    base?: HvBaseTheme;
    /**
     * If `true` the default color modes (dawn and wicked) of the base theme will be inherited while creating the theme.
     * If `false`, the new theme doesn't inherit the default color modes.
     *
     * By default the color modes are inherited.
     */
    inheritColorModes?: boolean;
}

export declare function hvDateColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, dateFormat?: string): HvTableColumnConfig<D, H>;

export declare const HvDateColumnCell: ({ date, dateFormat, }: HvDateColumnCellProp) => JSX.Element;

export declare interface HvDateColumnCellProp {
    /** The date's text representation format. */
    dateFormat?: string;
    /** Date to render. */
    date?: string;
}

/**
 * A date picker, popup calendar or date range picker is a graphical user
 * interface widget which allows the user to select a date from a calendar.
 */
export declare const HvDatePicker: ForwardRefExoticComponent<HvDatePickerProps & RefAttributes<HTMLDivElement>>;

export declare type HvDatePickerClasses = ExtractNames<typeof useClasses_60>;

export declare interface HvDatePickerProps extends Omit<HvFormElementProps, "onChange">, Pick<HvBaseDropdownProps, "disablePortal" | "expanded" | "defaultExpanded" | "onToggle" | "placeholder"> {
    /**
     * Identifies the element that provides an error message for the date picker.
     *
     * Will only be used when the validation status is invalid.
     */
    "aria-errormessage"?: string;
    /**
     * The callback fired when the value changes.
     */
    onChange?: (date?: Date, endDate?: Date) => void;
    /**
     * The callback fired when user clicks on cancel.
     */
    onCancel?: () => void;
    /**
     * The callback fired when user clicks on clear.
     */
    onClear?: () => void;
    /**
     * An object containing all the labels for the datepicker.
     */
    labels?: Partial<typeof DEFAULT_LABELS_8>;
    /**
     * The initial value of the input when in single calendar mode.
     */
    value?: Date;
    /**
     * The initial value for the start date when in range mode.
     */
    startValue?: Date;
    /**
     * The initial value for the end date when in range mode.
     */
    endValue?: Date;
    /**
     * Flag informing if the the component should be in range mode or in single mode.
     */
    rangeMode?: boolean;
    /**
     * The placement where the calendar should be placed according to the input. Options are `left` or `right`.
     * Note this prop only affects the calendar when in `rangeMode`.
     */
    horizontalPlacement?: "left" | "right";
    /**
     * The calendar locale. If undefined, it uses calendar default
     */
    locale?: string;
    /**
     * Controls if actions buttons are visible at the calendar.
     */
    showActions?: boolean;
    /**
     * Controls if clear button is visible at the calendar,
     * only works if showing actions or in range mode.
     */
    showClear?: boolean;
    /**
     * Sets if the calendar container should follow the date picker input out of the screen or stay visible.
     */
    escapeWithReference?: boolean;
    /**
     * An element placed before the Calendar
     */
    startAdornment?: React.ReactNode;
    /**
     * An object containing props to be passed onto the baseDropdown.
     */
    dropdownProps?: Partial<HvBaseDropdownProps>;
    /**
     * Additional props passed to the HvCalendar component.
     */
    calendarProps?: Partial<HvCalendarProps>;
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvDatePickerClasses;
}

/** @deprecated use `HvFormStatus` instead */
export declare type HvDatePickerStatus = HvFormStatus;

/**
 * A Dialog is a graphical control element in the form of a small panel that communicates information and prompts for a response.
 */
export declare const HvDialog: (props: HvDialogProps) => JSX_2.Element;

export declare type HvDialogActionClasses = ExtractNames<typeof useClasses_63>;

export declare const HvDialogActions: (props: HvDialogActionsProps) => JSX_2.Element;

export declare interface HvDialogActionsProps extends Omit<DialogActionsProps, "classes"> {
    /** Set the dialog to fullscreen mode. @deprecated set `fullscreen` in `HvDialog` */
    fullscreen?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvDialogActionClasses;
}

export declare type HvDialogClasses = ExtractNames<typeof useClasses_64>;

export declare const HvDialogContent: (props: HvDialogContentProps) => JSX_2.Element;

export declare type HvDialogContentClasses = ExtractNames<typeof useClasses_62>;

export declare interface HvDialogContentProps extends Omit<DialogContentProps, "classes"> {
    /** Content should be indented in relationship to the Dialog title. */
    indentContent?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvDialogContentClasses;
}

export declare interface HvDialogProps extends Omit<DialogProps, "fullScreen" | "classes" | "open"> {
    /** Current state of the Dialog. */
    open?: boolean;
    /** Callback fired when the component requests to be closed. */
    onClose?: (event: React.MouseEvent<HTMLButtonElement> | {}, reason?: "escapeKeyDown" | "backdropClick") => void;
    /** @inheritdoc */
    maxWidth?: DialogProps["maxWidth"];
    /** @inheritdoc */
    fullWidth?: DialogProps["fullWidth"];
    /** If true, the dialog stretches vertically, limited by the margins. @default false */
    fullHeight?: boolean;
    /**
     * Element id that should be focus when the Dialog opens.
     * Auto-focusing elements can cause usability issues, so this should be avoided.
     * @deprecated Use `autoFocus` on the element instead, if auto-focusing is required.
     */
    firstFocusable?: string;
    /** Title for the button close. */
    buttonTitle?: string;
    /** Set the dialog to fullscreen mode. */
    fullscreen?: boolean;
    /** Prevent closing the dialog when clicking on the backdrop. */
    disableBackdropClick?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvDialogClasses;
    /** Variant of the dialog. Adds a status bar to the top of the dialog. If not provided, no status bar is added. */
    variant?: "success" | "error" | "warning";
    /** @ignore */
    ref?: DialogProps["ref"];
    /** @ignore */
    component?: DialogProps["component"];
}

export declare const HvDialogTitle: (props: HvDialogTitleProps) => JSX_2.Element;

export declare type HvDialogTitleClasses = ExtractNames<typeof useClasses_61>;

export declare interface HvDialogTitleProps extends Omit<DialogTitleProps, "variant" | "classes"> {
    /** Variant of the dialog title. */
    variant?: HvDialogTitleVariant;
    /** Controls if the associated icon to the variant should be shown. */
    showIcon?: boolean;
    /** Custom icon to replace the variant default. */
    customIcon?: React.ReactNode;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvDialogTitleClasses;
}

export declare type HvDialogTitleVariant = "success" | "warning" | "error" | "info" | "default";

/**
 * Pagination is the process of dividing a document into discrete pages. It relates to how users interact with structured content on a website or application.
 * This component uses Radio Buttons to represent each page.
 */
export declare const HvDotPagination: (props: HvDotPaginationProps) => JSX_2.Element;

export declare type HvDotPaginationClasses = ExtractNames<typeof useClasses_65>;

export declare interface HvDotPaginationProps extends Omit<HvRadioGroupProps, "classes"> {
    /**
     * Icon to override the default one used for the unselected state.
     *
     * The default icon is `OtherStep`.
     */
    unselectedIcon?: React.ReactElement;
    /**
     * Icon to override the default one used for the selected state.
     *
     * The default icon is `CurrentStep`.
     */
    selectedIcon?: React.ReactElement;
    /**
     *  The number of pages the component has.
     */
    pages?: number;
    /**
     * The currently selected page.
     */
    page?: number;
    /**
     * The callback fired when the page value changes.
     */
    onPageChange?: (event: React.ChangeEvent<HTMLInputElement>, page: number) => void;
    /**
     * The callback fired to get the page aria label.
     */
    getItemAriaLabel?: (page: number) => string;
    /**
     * A Jss Object used to override or extend the styles applied.
     */
    classes?: HvDotPaginationClasses;
}

/**
 * The Drawer component provides a foundation to create a sliding pane.
 * It only provides the pane with a close button, the rest of the
 * content can be customized.
 */
export declare const HvDrawer: ForwardRefExoticComponent<Omit<HvDrawerProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvDrawerClasses = ExtractNames<typeof useClasses_67>;

export declare interface HvDrawerProps extends Omit<DrawerProps, "classes"> {
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * A Jss Object used to override or extend the styles applied.
     */
    classes?: HvDrawerClasses;
    /**
     * Components of the Drawer.
     */
    children?: React.ReactNode;
    /**
     * Current state of the Drawer.
     */
    open?: boolean;
    /**
     * Function executed on close.
     * Extended from Modal from material-ui
     *
     */
    onClose?: (event: React.SyntheticEvent, reason?: "escapeKeyDown" | "backdropClick") => void;
    /**
     * The side the drawer opens from.
     */
    anchor?: "left" | "top" | "right" | "bottom";
    /**
     * Title for the button close.
     */
    buttonTitle?: string;
    /**
     * Show backdrop when drawer is open.
     * @deprecated Use `hideBackdrop` instead.
     */
    showBackdrop?: boolean;
    /**
     * Prevent closing the dialog when clicking on the backdrop.
     */
    disableBackdropClick?: boolean;
    /** @ignore */
    ref?: DrawerProps["ref"];
    /** @ignore */
    component?: DrawerProps["component"];
}

/**
 * A dropdown list is a graphical control element, similar to a list box, that allows the user to choose one value from a list.
 */
export declare const HvDropdown: <Multiple extends boolean = false, OptionValue extends HvListValue = HvListValue>(props: HvDropdownProps<Multiple, OptionValue> & RefAttributes<HTMLDivElement>) => React.ReactElement | null;

export declare type HvDropdownClasses = ExtractNames<typeof useClasses_58>;

export declare function hvDropdownColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, id: string | undefined, placeholder: string, disabledPlaceholder: string, onChange?: (identifier: string, value: HvListValue) => void, dropdownProps?: HvDropdownProps<false>): HvTableColumnConfig<D, H>;

export declare const HvDropdownColumnCell: ({ dropdownProps, ...others }: HvDropdownColumnCellProp) => JSX_2.Element;

export declare interface HvDropdownColumnCellProp extends HvDropdownProps<false> {
    /** Extra props to be passed onto the dropdown. @deprecated pass props directly */
    dropdownProps?: HvDropdownProps<false>;
}

export declare type HvDropdownLabels = Partial<typeof DEFAULT_LABELS_7>;

/** @deprecated use `HvDropdownLabels` instead */
export declare type HvDropdownLabelsProps = HvDropdownLabels;

declare type HvDropdownListClasses = ExtractNames<typeof useClasses_59>;

declare interface HvDropdownListProps {
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * A Jss Object used to override or extend the component styles.
     */
    classes?: HvDropdownListClasses;
    /**
     * The list to be rendered.
     */
    values?: HvListValue[];
    /**
     * If true renders a multi select list.
     */
    multiSelect?: boolean;
    /**
     * If true renders the search component.
     */
    showSearch?: boolean;
    /**
     * A function to be executed whenever a item is selected in the list
     * or the Apply button is activated (when `multiSelect` is `true`).
     */
    onChange: (
    /** An array containing the selected values */
    listValues: HvListValue[], 
    /** If `true` the selection if finally committed the dropdown header text should reflect the new selection */
    commitChanges: boolean, 
    /** If `true` the dropdown should toggle it's current state */
    toggle: boolean, 
    /** If `true` the dropdown will call onChange */
    notifyChanges: boolean) => void;
    /**
     * A function to be executed whenever the Cancel button is activated.
     */
    onCancel: (event: React.MouseEvent) => void;
    /**
     * An object containing all the labels for the dropdown.
     */
    labels?: HvDropdownLabels;
    /**
     * If 'true' the dropdown will notify on the first render.
     */
    notifyChangesOnFirstRender?: boolean;
    /**
     * If `true` the dropdown will show tooltips when user mouseenter text in list
     */
    hasTooltips?: boolean;
    /**
     * If `true`, selection can be toggled when single selection.
     */
    singleSelectionToggle?: boolean;
    /**
     * Experimental. Height of the dropdown, in case you want to control it from a prop. Styles can also be used through dropdownListContainer class. Required in case virtualized is used
     */
    height?: number;
    /**
     * Experimental. Max height of the dropdown, in case you want to control it from a prop. Styles can also be used through dropdownListContainer class.
     */
    maxHeight?: number;
    /**
     * Experimental. Uses dropdown in a virtualized form, where not all options are rendered initially. Good for use cases with a lot of options.
     */
    virtualized?: boolean;
}

/**
 * A dropdown menu is a graphical control element, similar to a list box, that allows the user to choose a value from a list.
 */
export declare const HvDropDownMenu: ForwardRefExoticComponent<HvDropDownMenuProps & RefAttributes<HTMLDivElement>>;

export declare type HvDropDownMenuClasses = ExtractNames<typeof useClasses_23>;

export declare interface HvDropDownMenuProps extends HvBaseProps<HTMLDivElement, "onClick" | "onToggle"> {
    /** Icon. */
    icon?: React.ReactElement;
    /**
     * A list containing the elements to be rendered.
     *
     * - label: The label of the element to be rendered.
     * - selected: The selection state of the element.
     * - disabled: The disabled state of the element.
     * - icon: The icon node to be rendered on the left.
     * - showNavIcon: If true renders the navigation icon on the right.
     */
    dataList: HvListValue[];
    /** Placement of the dropdown. */
    placement?: "left" | "right";
    /** Disable the portal behavior. The children stay within it's parent DOM hierarchy. */
    disablePortal?: boolean;
    /** Function executed on toggle of the dropdown. Should receive the open status. */
    onToggle?: (event: Event | React.KeyboardEvent<HTMLUListElement> | React.ChangeEvent<HTMLInputElement> | React.MouseEvent<HTMLLIElement>, open: boolean) => void;
    /** Function executed in each onClick. Should received the clicked element. */
    onClick?: (event: React.ChangeEvent<HTMLInputElement> | React.MouseEvent<HTMLLIElement>, value: HvListValue) => void;
    /** Keep the Dropdown Menu opened after clicking one option */
    keepOpened?: boolean;
    /** Defines if the component is disabled. */
    disabled?: boolean;
    /** If true it should be displayed open. */
    expanded?: boolean;
    /** When uncontrolled, defines the initial expanded state. */
    defaultExpanded?: boolean;
    /**
     * The variant to be used in the header.
     * @deprecated Use `variant` instead
     */
    category?: HvButtonVariant;
    /** The variant to be used in the header. */
    variant?: HvButtonVariant;
    /** Button size. */
    size?: HvSize;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvDropDownMenuClasses;
    /** An object containing all the labels. */
    labels?: Partial<typeof DEFAULT_LABELS>;
}

export declare interface HvDropdownProps<Multiple extends boolean = boolean, OptionValue extends HvListValue = HvListValue> extends Omit<HvFormElementProps, "value" | "onChange">, Pick<HvBaseDropdownProps, "placement" | "popperProps" | "disablePortal" | "variableWidth" | "expanded" | "defaultExpanded"> {
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvDropdownClasses;
    /**
     * The placeholder value when nothing is selected.
     */
    placeholder?: string;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvDropdownStatus;
    /**
     * The error message to show when the validation status is "invalid".
     *
     * Defaults to "Required" when the status is uncontrolled and no `aria-errormessage` is provided.
     */
    statusMessage?: any;
    /**
     * Identifies the element that provides an error message for the dropdown.
     *
     * Will only be used when the validation status is invalid.
     */
    "aria-errormessage"?: string;
    /**
     * The callback fired when the value changes.
     */
    onChange?: (selected: Multiple extends true ? OptionValue[] : OptionValue | undefined) => void;
    /**
     * The list to be rendered by the dropdown.
     */
    values?: OptionValue[];
    /**
     * If `true` the dropdown is multiSelect, if `false` the dropdown is single select.
     */
    multiSelect?: Multiple;
    /**
     * If `true` the dropdown is rendered with a search bar, if `false` there won't be a search bar.
     */
    showSearch?: boolean;
    /**
     * If 'true' the dropdown will notify on the first render.
     */
    notifyChangesOnFirstRender?: boolean;
    /**
     * An object containing all the labels for the dropdown.
     */
    labels?: HvDropdownLabels;
    /**
     * If `true` the dropdown will show tooltips when user mouseenter text in list
     */
    hasTooltips?: boolean;
    /**
     * If `true`, selection can be toggled when single selection.
     */
    singleSelectionToggle?: boolean;
    /**
     * Callback called when the user cancels the changes.
     *
     * Called when the cancel button is used and when the user clicks outside the open container.
     *
     * @param {object} event The event source of the callback.
     */
    onCancel?: (event: Event) => void;
    /**
     * Callback called when dropdown changes the expanded state.
     *
     * @param {object} event The event source of the callback.
     * @param {boolean} open If the dropdown new state is open (`true`) or closed (`false`).
     */
    onToggle?: (event: Event, open: boolean) => void;
    /**
     * Callback called when the user clicks outside the open container.
     *
     * @param {object} event The event source of the callback.
     */
    onClickOutside?: (event: Event) => void;
    /**
     * @ignore
     */
    onFocus?: React.FocusEventHandler<any>;
    /**
     * @ignore
     */
    onBlur?: React.FocusEventHandler<any>;
    /**
     * Experimental. Height of the dropdown, in case you want to control it from a prop. Styles can also be used through dropdownListContainer class. Required in case virtualized is used
     */
    height?: number;
    /**
     * Experimental. Height of the dropdown, in case you want to control it from a prop. Styles can also be used through dropdownListContainer class. Required in case virtualized is used
     */
    maxHeight?: number;
    /**
     * Experimental. Uses dropdown in a virtualized form, where not all options are rendered initially. Good for use cases with a lot of options.
     */
    virtualized?: boolean;
    /**
     * Extra props passed to the dropdown.
     */
    baseDropdownProps?: Partial<HvBaseDropdownProps>;
    /**
     * Extra props passed to the list.
     */
    listProps?: Partial<HvDropdownListProps>;
}

export declare type HvDropdownStatus = "standBy" | "valid" | "invalid";

declare type HvDropZoneClasses = ExtractNames<typeof useClasses_72>;

declare type HvDropZoneLabels = Partial<typeof DEFAULT_LABELS_9>;

declare interface HvDropZoneProps extends Pick<HvFormElementProps, "id" | "disabled" | "label"> {
    /**
     * Labels to present in FileUploader.
     */
    labels?: HvDropZoneLabels;
    /**
     * Whether the Dropzone should accept multiple files at once.
     */
    multiple?: boolean;
    /**
     * Files extensions accepted for upload.
     */
    accept?: React.InputHTMLAttributes<HTMLInputElement>["accept"];
    /**
     * Max upload size
     * */
    maxFileSize: number;
    /**
     * Function responsible for processing files added to the drop zone.
     */
    onFilesAdded?: HvFilesAddedEvent;
    /**
     * Whether the DropZone should hide labels or not.
     */
    hideLabels?: boolean;
    /**
     * Attributes applied to the input element.
     */
    inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
    /**
     * A Jss Object used to override or extend the styles applied to the component.
     */
    classes?: HvDropZoneClasses;
}

/**
 * Empty states communicate that there’s no information, data or values to display in a given context.
 */
export declare const HvEmptyState: ForwardRefExoticComponent<HvEmptyStateProps & RefAttributes<HTMLDivElement>>;

export declare type HvEmptyStateClasses = ExtractNames<typeof useClasses_68>;

export declare interface HvEmptyStateProps extends HvBaseProps<HTMLDivElement, "title"> {
    /** Icon to be presented. */
    icon: React.ReactNode;
    /** The title to be shown. */
    title?: React.ReactNode;
    /** The message to be shown. */
    message?: React.ReactNode;
    /** The action message to be shown. */
    action?: React.ReactNode;
    /** A Jss Object used to override or extend the styles applied to the empty state component. */
    classes?: HvEmptyStateClasses;
}

export declare function hvExpandColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, expandRowButtonAriaLabel: string, collapseRowButtonAriaLabel: string, getCanRowExpand?: (row: HvRowInstance<D, H>) => boolean, ExpandedIcon?: React.ReactNode, CollapsedIcon?: React.ReactNode): HvTableColumnConfig<D, H>;

/** This type extends DeepPartial to allow any extra properties */
export declare type HvExtraDeepPartialProps<T> = Partial<{
    [P in keyof T]: DeepPartial<T[P]> & Record<string, any>;
}> & Record<string, any>;

export { HvExtraDeepProps }

export { HvExtraProps }

export declare const HvFile: (props: HvFileProps) => JSX_2.Element;

export declare type HvFileClasses = ExtractNames<typeof useClasses_70>;

export declare interface HvFileData extends Omit<File, "name" | "size"> {
    /**
     * The file id.
     */
    id?: string;
    /**
     * The file name.
     */
    name?: string;
    /**
     * The upload status.
     */
    status?: "progress" | "success" | "fail";
    /**
     * The file size in bytes.
     */
    size?: number;
    /**
     * Upload progress in bytes.
     */
    progress?: number;
    /**
     * Optional node representing a preview of the uploaded file.
     */
    preview?: React.ReactNode;
    /**
     * Error message when the upload failed.
     */
    errorMessage?: string;
}

export declare type HvFileProps = {
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * File information to be displayed.
     */
    data: HvFileData;
    /**
     * Callback fired when file is removed from list.
     */
    onFileRemoved?: HvFileRemovedEvent;
    /**
     * Value of aria-label to apply to remove file button in file list.
     * */
    removeFileButtonLabel?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the component.
     */
    classes?: HvFileClasses;
};

export declare type HvFileRemovedEvent = (file: HvFileData) => void;

export declare type HvFilesAddedEvent = (files: HvFileData[]) => void;

/**
 * Lets the user choose one or more files from their device storage. Once chosen,
 * the files can be uploaded to a server or manipulated on the client side.
 *
 * Accepted file types follow the format of the html [input accept attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).
 */
export declare const HvFileUploader: (props: HvFileUploaderProps) => JSX_2.Element;

export declare type HvFileUploaderClasses = ExtractNames<typeof useClasses_71>;

export declare interface HvFileUploaderLabels extends HvDropZoneLabels {
    /** Value of aria-label to apply to remove file button in FileList */
    removeFileButtonLabel?: string;
}

/**
 * The `HvFileUploaderPreview` component is available to facilitate the styling
 * of the button (when clickable) and the detection of image unloading.
 */
export declare const HvFileUploaderPreview: (props: HvFileUploaderPreviewProps) => JSX_2.Element;

export declare type HvFileUploaderPreviewClasses = ExtractNames<typeof useClasses_69>;

export declare interface HvFileUploaderPreviewProps extends Omit<HvButtonProps, "children" | "classes"> {
    /**
     * Content that represents the preview of an uploaded file.
     */
    children: React.ReactElement;
    /**
     * Callback executed when the preview is unmounted.
     *
     * Should be used for cleaning up client-side image URLs created by `URL.createObjectURL()`.
     */
    onUnload?: () => void;
    /**
     * If `true`, doesn't show an overlay on top of the preview when hovering.
     *
     * Only applies when `onClick` is set.
     */
    disableOverlay?: boolean;
    /**
     * A Jss Object used to override or extend the styles applied to the component.
     */
    classes?: HvFileUploaderPreviewClasses;
}

export declare interface HvFileUploaderProps extends HvFormElementProps {
    /**
     * An object containing all the labels.
     */
    labels?: HvFileUploaderLabels;
    /**
     * An object used to override or extend the styles applied to the component.
     */
    classes?: HvFileUploaderClasses;
    /**
     * The files to upload.
     */
    fileList?: HvFileData[];
    /**
     * Whether the Dropzone should accept multiple files at once.
     */
    multiple?: boolean;
    /**
     * If the input is disabled or not
     */
    disabled?: boolean;
    /**
     * Max upload size
     * */
    maxFileSize?: number;
    /** File types accepted for uploading. @see [HTML input file accept](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#accept) */
    accept?: HvDropZoneProps["accept"];
    /** Files extensions accepted for upload. @deprecated use `accept` instead */
    acceptedFiles?: string[];
    /**
     * Callback fired when files are added.
     */
    onFilesAdded?: HvFilesAddedEvent;
    /**
     * Callback fired when file is removed from list.
     */
    onFileRemoved?: HvFileRemovedEvent;
    /**
     * Whether the DropZone should hide labels or not.
     */
    hideLabels?: boolean;
    /**
     * Attributes applied to the input element.
     */
    inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
}

/**
 * This component implements one potential use-case of the Filter Group pattern Design System Specifies.
 * Due to the enormous variety of capabilities required for this, we strongly recommend checking the code of the component and extend it yourself,
 * while we do not provide a better approach for building this component with smaller and more composable parts.
 */
export declare const HvFilterGroup: ForwardRefExoticComponent<HvFilterGroupProps & RefAttributes<HTMLDivElement>>;

export declare type HvFilterGroupClasses = ExtractNames<typeof useClasses_73>;

declare type HvFilterGroupContentClasses = ExtractNames<typeof useClasses_74>;

declare interface HvFilterGroupContentProps extends Omit<HvBaseDropdownProps, "onChange"> {
    description?: React.ReactNode;
    status?: HvFormStatus;
    onChange?: (event: React.MouseEvent<HTMLButtonElement>, value?: HvFilterGroupValue) => void;
    onCancel?: (event: React.MouseEvent<HTMLButtonElement> | Event) => void;
    onClear?: (event: React.MouseEvent<HTMLButtonElement>) => void;
    labels?: HvFilterGroupLabels;
    horizontalPlacement?: HvFilterGroupHorizontalPlacement;
    disablePortal?: boolean;
    escapeWithReference?: boolean;
    height?: string | number;
    leftEmptyElement?: React.ReactNode;
    rightEmptyElement?: React.ReactNode;
    disabled?: boolean;
    classes?: HvFilterGroupContentClasses;
}

export declare type HvFilterGroupFilters = {
    id: string;
    name: string;
    data: {
        id: string | number;
        name: string;
        disabled?: boolean;
    }[];
}[];

export declare type HvFilterGroupHorizontalPlacement = "left" | "right";

export declare type HvFilterGroupLabels = Partial<typeof DEFAULT_LABELS_10>;

export declare interface HvFilterGroupProps extends Omit<HvFormElementProps, "classes" | "onChange" | "defaultValue" | "statusMessage"> {
    /** The initial value of the input when in single calendar mode. */
    filters: HvFilterGroupFilters;
    /** The form element name. */
    name?: string;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /**  Provide additional descriptive text for the form element. */
    description?: React.ReactNode;
    /** Indicates that the form element is disabled. */
    disabled?: boolean;
    /** Indicates that user input is required on the form element. */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**  The error message to show when `status` is "invalid". Defaults to "Required". */
    statusMessage?: React.ReactNode;
    /** The callback fired when the cancel button is clicked. */
    onCancel?: (event: React.MouseEvent<HTMLButtonElement> | Event) => void;
    /** The callback fired when the clear filters button is clicked. */
    onClear?: (event: React.MouseEvent<HTMLButtonElement>) => void;
    /** The callback fired when the value changes. */
    onChange?: (event: React.MouseEvent<HTMLButtonElement>, value?: HvFilterGroupValue) => void;
    /** An Object containing the various text associated with the input. */
    labels?: HvFilterGroupLabels;
    /** The placeholder value when nothing is selected. */
    placeholder?: string;
    /** The default value of the filter group. If defined the clear action will reset to it. */
    defaultValue?: HvFilterGroupValue;
    /** The value of the filter group. */
    value?: HvFilterGroupValue;
    /** The placement where the filter group should be placed according to the input. Options are `left` or `right`. */
    horizontalPlacement?: HvFilterGroupHorizontalPlacement;
    /** Disable the portal behavior. The children stay within it's parent DOM hierarchy. */
    disablePortal?: boolean;
    /** Sets if the filter container should be out of the screen or stay visible. */
    escapeWithReference?: boolean;
    /** The height of the filter panel, between 295 and 425. Defaults to 350 */
    height?: number | string;
    /** The filter content props */
    filterContentProps?: Partial<HvFilterGroupContentProps>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvFilterGroupClasses;
}

export declare type HvFilterGroupValue = (string | number)[][];

/** @deprecated internal use only. this component has navigation issues. */
export declare const HvFocus: ({ classes: classesProp, children, configuration, disabledClass, selected, disabled, rootRef, focusOnClick, focusDisabled, strategy, useFalseFocus, filterClass, navigationJump, }: HvFocusProps) => JSX_2.Element;

export declare type HvFocusClasses = ExtractNames<typeof useClasses_3>;

export declare interface HvFocusProps extends HvBaseProps<HTMLElement, "children"> {
    children: React.ReactElement;
    /** Extra configuration for the child element. */
    configuration?: {
        tabIndex?: number;
    };
    /** Indicates that the disabled class should be applied. */
    disabledClass?: boolean;
    /** Whether the focus is selected. */
    selected?: boolean;
    /** Whether the focus is disabled. */
    disabled?: boolean;
    /** The reference to the root element to hold all Focus' context. */
    rootRef?: React.RefObject<HTMLElement>;
    /** Show focus when click element. v */
    focusOnClick?: boolean;
    /** Show focus when click element. v */
    focusDisabled?: boolean;
    /** Focus and navigation strategy to be used. v */
    strategy?: HvFocusStrategies;
    /** Uses an absolute positioned div as a focus. v */
    useFalseFocus?: boolean;
    /** Narrows the results of the focus to only theses class v */
    filterClass?: string;
    /** How much the navigation will skip when using the arrows. v */
    navigationJump?: number;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvFocusClasses;
}

export declare type HvFocusStrategies = "listbox" | "menu" | "card" | "grid";

/**
 * A Footer is a way of providing extra information at the end of a page.
 */
export declare const HvFooter: ForwardRefExoticComponent<HvFooterProps & RefAttributes<HTMLElement>>;

export declare type HvFooterClasses = ExtractNames<typeof useClasses_75>;

declare type HvFooterPropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvPropGetter<D, H, HvUseTableFooterProps, {
    column: HvHeaderGroup<D, H>;
}>;

export declare interface HvFooterProps extends HvBaseProps {
    /** Footer name. */
    name?: React.ReactNode;
    /** Footer copyright. */
    copyright?: React.ReactNode;
    /** Footer links. */
    links?: React.ReactNode;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvFooterClasses;
}

declare type HvFooterProps_2<D extends object = Record<string, unknown>> = HvTableInstance<D> & {
    column: HvColumnInstance<D>;
};

/**
 * Provides form-related context (ie. required/disabled/readOnly) for building form components,
 * analogous to MUI's [`FormControl`](https://mui.com/material-ui/api/form-control/) component.
 *
 * It is used internally to build UI Kit's form components (eg. `HvInput`, `HvDatePicker`), and can be used to build custom form components.
 */
export declare const HvFormElement: {
    (props: HvFormElementProps): JSX_2.Element;
    formElementType: string;
};

export declare type HvFormElementClasses = ExtractNames<typeof useClasses_8>;

declare interface HvFormElementContextValue {
    /** id to be applied to the form element root node. */
    id?: string;
    /**
     * Name of the form element.
     *
     * Part of a name/value pair, should be the name property of the underling native input.
     */
    name?: string;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /** Whether the form element is disabled. */
    disabled?: boolean;
    /** Indicates that user input is required on the form element. */
    required?: boolean;
    /** Indicates that the form element is not editable. */
    readOnly?: boolean;
}

export declare interface HvFormElementProps extends HvFormElementContextValue, HvBaseProps<HTMLDivElement, "onChange" | "onToggle"> {
    /**
     * Current value of the form element.
     *
     * Part of a name/value pair, should be the value property of the underling native input.
     */
    value?: any;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /** Provide additional descriptive text for the form element. */
    description?: React.ReactNode;
    /** The error message to show when `status` is "invalid". */
    statusMessage?: string;
    /** The callback fired when the value changes. */
    onChange?: (event: React.FormEvent<HTMLDivElement>) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvFormElementClasses;
}

export declare type HvFormStatus = "standBy" | "valid" | "invalid" | "empty";

/**
 * Global Actions are actions that affect the entire page they live in.
 * They should persist while scrolling down the screen.
 */
export declare const HvGlobalActions: ForwardRefExoticComponent<HvGlobalActionsProps & RefAttributes<HTMLDivElement>>;

export declare type HvGlobalActionsClasses = ExtractNames<typeof useClasses_76>;

export declare type HvGlobalActionsHeadingLevel = 1 | 2 | 3 | 4 | 5 | 6;

export declare type HvGlobalActionsPosition = "sticky" | "fixed" | "relative";

export declare interface HvGlobalActionsProps extends HvBaseProps<HTMLDivElement, "title"> {
    /** Text to display in the component. */
    title?: React.ReactNode;
    /** Denotes if this is a global or section component. */
    variant?: HvGlobalActionsVariant;
    /** User can pass in a fully customized button or false for when the back button should not be rendered. */
    backButton?: React.ReactNode;
    /** Heading Level to apply to Title Area. */
    headingLevel?: HvGlobalActionsHeadingLevel;
    /**
     * Position of the Global Actions.
     * @default variant === "global" ? "sticky" : "relative"
     */
    position?: HvGlobalActionsPosition;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvGlobalActionsClasses;
}

export declare type HvGlobalActionsVariant = "global" | "section";

/**
 * The grid creates visual consistency between layouts while allowing flexibility
 * across a wide variety of designs. This component is based on a 12-column grid layout.
 *
 * It's based on the [Material UI Grid](https://mui.com/material-ui/react-grid/).
 *
 * However, the number of columns is set to 12 for all breakpoints, as it serves most
 * of the use cases and simplifies the implementation.
 * To opt-in to the Design System directives, you can set the `columns` prop to `auto`.
 *
 * Also, the Design System specifications are omissive about the horizontal gutters.
 * The HvGrid sets them to the same value as the vertical gutters, depending on the breakpoint.
 * It can be overridden by setting the `rowSpacing` prop.
 */
export declare const HvGrid: ForwardRefExoticComponent<Omit<HvGridProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvGridClasses = ExtractNames<typeof useClasses_77>;

export declare type HvGridDirection = "row" | "row-reverse" | "column" | "column-reverse";

export declare interface HvGridProps extends Omit<GridProps, "classes" | "columns"> {
    /**
     * If `true`, the component will have the flex *container* behavior.
     * You should be wrapping *items* with a *container*.
     */
    container?: boolean;
    /**
     * If `true`, the component will have the flex *item* behavior.
     * You should be wrapping *items* with a *container*.
     */
    item?: boolean;
    /**
     * Defines the space between the type item component. It can only be used on a type container component.
     * Based in the 8x factor defined in the theme, it allows the definition of this factor based on the factor
     * (number between 0 and 10), breakpoint or auto.
     */
    spacing?: HvGridSpacing | number;
    /**
     * Defines the vertical space between the type item component. It can only be used on a type container component.
     * Based in the 8x factor defined in the theme, it allows the definition of this factor based on the factor
     * (number between 0 and 10), breakpoint or auto.
     * It overrides the value of the spacing prop.
     */
    rowSpacing?: HvGridSpacing | number;
    /**
     * Defines the horizontal space between the type item component. It can only be used on a type container component.
     * Based in the 8x factor defined in the theme, it allows the definition of this factor based on the factor
     * (number between 0 and 10), breakpoint or auto.
     * It overrides the value of the spacing prop.
     */
    columnSpacing?: HvGridSpacing | number;
    /**
     * The number of columns.
     * Defaults to a 12-column grid.
     * The value "auto" implements the Design System directives in terms of variable number of columns.
     * @default 12
     */
    columns?: "auto" | GridProps["columns"];
    /**
     * Defines the `flex-direction` style property.
     * It is applied for all screen sizes.
     */
    direction?: HvGridDirection;
    /**
     * Defines the `justify-content` style property.
     * It is applied for all screen sizes.
     */
    justify?: "flex-start" | "center" | "flex-end" | "space-between" | "space-around" | "space-evenly";
    /**
     * Defines the number of grids the component is going to use.
     * It's applied for all the screen sizes with the lowest priority.
     */
    xs?: number | boolean;
    /**
     * Defines the number of grids the component is going to use.
     * It's applied for the `sm` breakpoint and wider screens if not overridden.
     */
    sm?: number | boolean;
    /**
     * Defines the number of grids the component is going to use.
     * It's applied for the `md` breakpoint and wider screens if not overridden.
     */
    md?: number | boolean;
    /**
     * Defines the number of grids the component is going to use.
     * It's applied for the `lg` breakpoint and wider screens if not overridden.
     */
    lg?: number | boolean;
    /**
     * Defines the number of grids the component is going to use.
     * It's applied for the `xl` breakpoint and wider screens.
     */
    xl?: number | boolean;
    /**
     * Defines the `flex-wrap` style property.
     * It's applied for all screen sizes.
     */
    wrap?: "nowrap" | "wrap" | "wrap-reverse";
    /**
     * If `true`, it sets `min-width: 0` on the item.
     * Refer to the limitations section of the documentation to better understand the use case.
     */
    zeroMinWidth?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvGridClasses;
}

export declare type HvGridSpacing = "xs" | "sm" | "md" | "lg" | "xl" | "auto" | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;

/**
 * Header component is used to render a header bar with logo and brand name, navigation and actions.
 */
export declare const HvHeader: ForwardRefExoticComponent<HvHeaderProps & RefAttributes<HTMLElement>>;

export declare const HvHeaderActions: ForwardRefExoticComponent<HvHeaderActionsProps & RefAttributes<HTMLDivElement>>;

export declare type HvHeaderActionsClasses = ExtractNames<typeof useClasses_79>;

export declare interface HvHeaderActionsProps extends HvBaseProps {
    classes?: HvHeaderActionsClasses;
}

/**
 * Header component is used to render a header bar with logo and brand name, navigation and actions.
 */
export declare const HvHeaderBrand: ForwardRefExoticComponent<HvHeaderBrandProps & RefAttributes<HTMLDivElement>>;

export declare type HvHeaderBrandClasses = ExtractNames<typeof useClasses_80>;

export declare interface HvHeaderBrandProps extends HvBaseProps {
    logo?: React.ReactNode;
    name?: string;
    classes?: HvHeaderBrandClasses;
}

export declare type HvHeaderClasses = ExtractNames<typeof useClasses_78>;

declare interface HvHeaderGroup<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends HvColumnInstance<D, H>, Omit<UseTableHeaderGroupProps<D>, "headers"> {
    headers: Array<HvHeaderGroup<D, H>>;
}

export declare const HvHeaderMenuBar: (props: HvHeaderMenuBarProps) => JSX_2.Element;

declare type HvHeaderMenuBarClasses = ExtractNames<typeof useClasses_81>;

declare interface HvHeaderMenuBarProps extends HvBaseProps<HTMLDivElement, "onClick"> {
    data: HvHeaderNavigationItemProp[];
    type?: BarProps["type"];
    onClick?: (event: React.MouseEvent, selection: HvHeaderNavigationItemProp) => void;
    levels: number;
    currentLevel: number;
    classes?: HvHeaderMenuBarClasses;
}

export declare const HvHeaderMenuItem: (props: HvHeaderMenuItemProps) => JSX_2.Element;

declare type HvHeaderMenuItemClasses = ExtractNames<typeof useClasses_82>;

declare interface HvHeaderMenuItemProps extends HvBaseProps<HTMLDivElement, "onClick"> {
    item: HvHeaderNavigationItemProp;
    type?: string;
    onClick?: (event: React.MouseEvent, selection: HvHeaderNavigationItemProp) => void;
    levels: number;
    currentLevel: number;
    classes?: HvHeaderMenuItemClasses;
}

export declare const HvHeaderNavigation: ForwardRefExoticComponent<HvHeaderNavigationProps & RefAttributes<HTMLElement>>;

export declare type HvHeaderNavigationClasses = ExtractNames<typeof useClasses_83>;

export declare interface HvHeaderNavigationItemProp {
    id: string;
    label: string;
    path?: string;
    href?: string;
    target?: string;
    data?: HvHeaderNavigationItemProp[];
}

export declare interface HvHeaderNavigationProps extends HvBaseProps<HTMLDivElement, "onClick"> {
    data: HvHeaderNavigationItemProp[];
    selected?: string;
    onClick?: (event: React.MouseEvent, selection: HvHeaderNavigationItemProp) => void;
    classes?: HvHeaderNavigationClasses;
    /**
     * The number of levels to show: the first level (1) or the first and second level (2).
     *
     * Defaults to `2`.
     * */
    levels?: 1 | 2;
}

export declare type HvHeaderPosition = "fixed" | "absolute" | "sticky" | "static" | "relative";

declare type HvHeaderPropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvPropGetter<D, H, HvUseTableHeaderProps, {
    column: HvHeaderGroup<D, H>;
}>;

export declare interface HvHeaderProps extends HvBaseProps {
    /** The position of the header bar */
    position?: HvHeaderPosition;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvHeaderClasses;
}

declare type HvHeaderProps_2<D extends object = Record<string, unknown>> = HvTableInstance<D> & {
    column: HvColumnInstance<D>;
};

export declare interface HvHooks<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<Hooks<D>, "useOptions">, Partial<UseExpandedHooks<D>>, Partial<UseGroupByHooks<D>>, Partial<UseSortByHooks<D>>, Partial<UseHvRowSelectionHooks<D>>, Partial<UseHvTableStickyHooks<D>>, Partial<UseHvPaginationHooks<D>>, Partial<UseHvBulkActionsHooks<D>> {
    useOptions: Array<(options: HvTableOptions<D, H>, args: HvTableOptions<D, H>) => HvTableOptions<D, H>>;
    stateReducers: Array<(newState: HvTableState<D>, action: ActionType, previousState?: HvTableState<D>, instance?: HvTableState<D>) => ReducerTableState<D> | undefined>;
    columns: Array<(columns: Array<HvTableColumnConfig<D, H>>, meta: HvMeta<D, H>) => Array<HvTableColumnConfig<D, H>>>;
    allColumns: Array<(allColumns: Array<HvColumnInstance<D, H>>, meta: HvMeta<D, H>) => Array<HvTableColumnConfig<D, H>>>;
    visibleColumns: Array<(allColumns: Array<HvColumnInstance<D, H>>, meta: HvMeta<D, H>) => Array<HvTableColumnConfig<D, H>>>;
    headerGroups: Array<(allColumns: Array<HvHeaderGroup<D, H>>, meta: HvMeta<D, H>) => Array<HvHeaderGroup<D, H>>>;
    useInstanceBeforeDimensions: Array<(instance: HvTableInstance<D, H>) => void>;
    useInstance: Array<(instance: HvTableInstance<D, H>) => void>;
    useControlledState: Array<(state: HvTableState<D>, meta: HvMeta<D, H>) => HvTableState<D>>;
    getTableProps: Array<HvTablePropGetter<D, H>>;
    getHeaderProps: Array<HvHeaderPropGetter<D>>;
    getFooterProps: Array<HvFooterPropGetter<D>>;
    getRowProps: Array<HvRowPropGetter<D>>;
    getCellProps: Array<HvCellPropGetter<D>>;
    useFinalInstance: Array<(instance: HvTableInstance<D, H>) => void>;
}

export declare type HvHorizontalScrollListItemClasses = ExtractNames<typeof useClasses_98>;

/**
 * The `HvIconButton` component wraps a `HvTooltip` with a label around a `HvButton` with only an icon as its content.
 * As defined by Design System, a tooltip with the button’s label should always be displayed when hovering an icon only button.
 * This component provides this behavior out of the box.
 */
export declare const HvIconButton: <C extends React.ElementType = "button">(props: Omit<HvButtonProps<C>, "icon" | "title" | "children" | "ref" | "component" | "focusableWhenDisabled" | "startIcon" | "endIcon"> & {
    /** Label to be displayed in the tooltip when hovered. This label will be used as the button's `aria-label`. */
    title: React.ReactNode;
    /** Number of milliseconds to wait before showing the tooltip. @default 500 */
    enterDelay?: HvTooltipProps["enterDelay"];
    /** Tooltip placement. @default top */
    placement?: HvTooltipProps["placement"];
    /** Extra tooltip properties. */
    tooltipProps?: Omit<Partial<HvTooltipProps>, "children">;
} & {
    component?: C | undefined;
} & {
    children?: ReactNode | undefined;
} & (Omit<PropsWithoutRef<ComponentProps<C>>, "color" | "classes" | "disabled" | "title" | "selected" | "variant" | "size" | "component" | "className" | "radius" | "overrideIconColors" | "placement" | "enterDelay" | "tooltipProps" | Exclude<keyof (Omit<PropsWithoutRef<ComponentProps<C>>, "color" | "classes" | "disabled" | "icon" | "selected" | "variant" | "size" | "component" | "className" | "radius" | "focusableWhenDisabled" | "startIcon" | "endIcon" | "overrideIconColors"> extends infer T ? T extends Omit<PropsWithoutRef<ComponentProps<C>>, "color" | "classes" | "disabled" | "icon" | "selected" | "variant" | "size" | "component" | "className" | "radius" | "focusableWhenDisabled" | "startIcon" | "endIcon" | "overrideIconColors"> ? T extends any ? T : never : never : never), "icon" | "title" | "children" | "ref" | "component" | "focusableWhenDisabled" | "startIcon" | "endIcon">> extends infer T_1 ? T_1 extends Omit<PropsWithoutRef<ComponentProps<C>>, "color" | "classes" | "disabled" | "title" | "selected" | "variant" | "size" | "component" | "className" | "radius" | "overrideIconColors" | "placement" | "enterDelay" | "tooltipProps" | Exclude<keyof (Omit<PropsWithoutRef<ComponentProps<C>>, "color" | "classes" | "disabled" | "icon" | "selected" | "variant" | "size" | "component" | "className" | "radius" | "focusableWhenDisabled" | "startIcon" | "endIcon" | "overrideIconColors"> extends infer T_2 ? T_2 extends Omit<PropsWithoutRef<ComponentProps<C>>, "color" | "classes" | "disabled" | "icon" | "selected" | "variant" | "size" | "component" | "className" | "radius" | "focusableWhenDisabled" | "startIcon" | "endIcon" | "overrideIconColors"> ? T_2 extends any ? T_2 : never : never : never), "icon" | "title" | "children" | "ref" | "component" | "focusableWhenDisabled" | "startIcon" | "endIcon">> ? T_1 extends any ? T_1 : never : never : never) & {
    ref?: PolymorphicRef<C> | undefined;
} & RefAttributes<unknown>) => React.ReactElement | null;

export declare type HvIconButtonProps<C extends React.ElementType = "button"> = PolymorphicComponentRef<C, Omit<HvButtonProps<C>, "icon" | "focusableWhenDisabled" | "title" | "startIcon" | "endIcon" | "children" | "ref" | "component"> & {
    /** Label to be displayed in the tooltip when hovered. This label will be used as the button's `aria-label`. */
    title: React.ReactNode;
    /** Number of milliseconds to wait before showing the tooltip. @default 500 */
    enterDelay?: HvTooltipProps["enterDelay"];
    /** Tooltip placement. @default top */
    placement?: HvTooltipProps["placement"];
    /** Extra tooltip properties. */
    tooltipProps?: Omit<Partial<HvTooltipProps>, "children">;
}>;

/**
 * Provides the user with additional descriptive text for the form element.
 */
export declare const HvInfoMessage: (props: HvInfoMessageProps) => JSX_2.Element;

export declare type HvInfoMessageClasses = ExtractNames<typeof useClasses_10>;

export declare interface HvInfoMessageProps extends HvTypographyProps<"label"> {
    /** If `true` the label is disabled. */
    disabled?: boolean;
    /** If `true` the info message won't have margins. */
    disableGutter?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvInfoMessageClasses;
}

/**
 * An Inline Editor allows the user to edit a record without making a major switch
 * between viewing and editing, making it an efficient method of updating a record.
 */
export declare const HvInlineEditor: <C extends React.ElementType = <InputElement extends HTMLElement = HTMLInputElement | HTMLTextAreaElement>(props: HvInputProps<InputElement> & RefAttributes<InputElement>) => React.ReactElement | null>(props: {
    /** The value of the form element. */
    value?: string;
    /** The default value of the form element. */
    defaultValue?: string;
    /** Whether the Edit icon should always be visible */
    showIcon?: boolean;
    /** Variant of the HvTypography to display */
    variant?: HvTypographyVariants;
    /** Called when the input is blurred. */
    onBlur?: (event: React.FocusEvent<HTMLTextAreaElement | HTMLInputElement>, value: string) => void;
    /** Called when the input value changes. */
    onChange?: (event: React.SyntheticEvent, value: string) => void;
    /** Called when there's a keydown event on the input. */
    onKeyDown?: (event: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement> | React.MouseEvent, value: string) => void;
    /** Props passed to the HvButton component */
    buttonProps?: HvButtonProps;
    /** Props passed to the HvTypography text component */
    typographyProps?: HvTypographyProps;
    /** Whether the editor is disabled or not. */
    disabled?: boolean;
    /** A Jss Object used to override or extend the styles applied to the empty state component. */
    classes?: Partial<{
        root: string;
        inputBorderContainer: string;
        input: string;
        inputRoot: string;
        text: string;
        largeText: string;
        textEmpty: string;
        button: string;
        icon: string;
        iconVisible: string;
    }>;
    /** The placeholder value of the input. */
    placeholder?: string;
} & {
    component?: C | undefined;
} & {
    children?: ReactNode | undefined;
} & (Omit<PropsWithoutRef<ComponentProps<C>>, "value" | "classes" | "placeholder" | "disabled" | "variant" | "component" | "onBlur" | "onChange" | "onKeyDown" | "defaultValue" | "buttonProps" | "showIcon" | "typographyProps"> extends infer T ? T extends Omit<PropsWithoutRef<ComponentProps<C>>, "value" | "classes" | "placeholder" | "disabled" | "variant" | "component" | "onBlur" | "onChange" | "onKeyDown" | "defaultValue" | "buttonProps" | "showIcon" | "typographyProps"> ? T extends any ? T : never : never : never) & {
    ref?: PolymorphicRef<C> | undefined;
} & RefAttributes<unknown>) => React.ReactElement | null;

export declare type HvInlineEditorClasses = ExtractNames<typeof useClasses_84>;

export declare type HvInlineEditorProps<C extends React.ElementType = typeof HvInput> = PolymorphicComponentRef<C, {
    /** The value of the form element. */
    value?: string;
    /** The default value of the form element. */
    defaultValue?: string;
    /** Whether the Edit icon should always be visible */
    showIcon?: boolean;
    /** Variant of the HvTypography to display */
    variant?: HvTypographyVariants;
    /** Called when the input is blurred. */
    onBlur?: (event: React.FocusEvent<HTMLTextAreaElement | HTMLInputElement>, value: string) => void;
    /** Called when the input value changes. */
    onChange?: (event: React.SyntheticEvent, value: string) => void;
    /** Called when there's a keydown event on the input. */
    onKeyDown?: (event: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement> | React.MouseEvent, value: string) => void;
    /** Props passed to the HvButton component */
    buttonProps?: HvButtonProps;
    /** Props passed to the HvTypography text component */
    typographyProps?: HvTypographyProps;
    /** Whether the editor is disabled or not. */
    disabled?: boolean;
    /** A Jss Object used to override or extend the styles applied to the empty state component. */
    classes?: HvInlineEditorClasses;
    /** The placeholder value of the input. */
    placeholder?: string;
}>;

/**
 * A text input box is a graphical control element intended to enable the user to input text information to be used by the software.
 */
export declare const HvInput: <InputElement extends HTMLElement = HTMLInputElement | HTMLTextAreaElement>(props: HvInputProps<InputElement> & RefAttributes<InputElement>) => React.ReactElement | null;

export declare type HvInputClasses = ExtractNames<typeof useClasses_46>;

export declare type HvInputLabels = Partial<typeof DEFAULT_LABELS_4>;

export declare interface HvInputProps<InputElement extends HTMLElement = HTMLInputElement | HTMLTextAreaElement> extends Omit<HvBaseInputProps, "onChange" | "onBlur" | "onFocus" | "onKeyDown"> {
    /** @inheritdoc */
    name?: string;
    /** @inheritdoc */
    value?: React.InputHTMLAttributes<InputElement>["value"];
    /** @inheritdoc */
    defaultValue?: React.InputHTMLAttributes<InputElement>["value"];
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be inputted via inputProps.
     */
    label?: React.ReactNode;
    /** Provide additional descriptive text for the form element. */
    description?: React.ReactNode;
    /** @inheritdoc */
    disabled?: boolean;
    /** @inheritdoc */
    readOnly?: boolean;
    /** @inheritdoc */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to `checked`, depending of the values of both `required` and `checked`.
     */
    status?: HvFormStatus;
    /** The error message to show when `status` is "invalid". */
    statusMessage?: string;
    /** @inheritdoc */
    onChange?: (event: React.ChangeEvent<InputElement>, value: string) => void;
    /**
     * Callback called when the user submits the value by pressing Enter/Return.
     *
     * Also called when the search button is clicked (when `type="search"`).
     */
    onEnter?: (event: React.KeyboardEvent<InputElement>, value: string) => void;
    /**
     * The function that will be executed onBlur, allows checking the validation state,
     * it receives the value and the validation state.
     */
    onBlur?: (event: React.FocusEvent<InputElement>, value: string, validationState: HvInputValidity) => void;
    /**
     * The function that will be executed onBlur, allows checking the value state,
     * it receives the value.
     */
    onFocus?: (event: React.FocusEvent<InputElement>, value: string) => void;
    /**
     * The function that will be executed onKeyDown, allows checking the value state,
     * it receives the event and value.
     */
    onKeyDown?: (event: React.KeyboardEvent<InputElement>, value: string) => void;
    /** The input type. */
    type?: React.HTMLInputTypeAttribute;
    /** The placeholder value of the input. */
    placeholder?: string;
    /** Internal labels?. */
    labels?: HvInputLabels & Record<string, any>;
    /** An Object containing the various texts associated with the input. */
    validationMessages?: HvValidationMessages;
    /** The function that will be executed to received an array of objects that has a label and id to create list of suggestion */
    suggestionListCallback?: (value: string) => HvInputSuggestion[] | null;
    /**
     * If enabled, the suggestions list will be rendered using a portal.
     * If disabled, it will be under the DOM hierarchy of the parent component.
     * @default false
     * */
    enablePortal?: boolean;
    /**
     * Whether the suggestions should be triggered once the input is focused and not only when typing.
     * @default false
     * */
    suggestOnFocus?: boolean;
    /**
     * The custom validation function, it receives the value and must return
     * either `true` for valid or `false` for invalid, default validations would only
     * occur if this function is null or undefined
     */
    validation?: (value: string) => boolean;
    /** If `true` it should autofocus. */
    autoFocus?: boolean;
    /** If `true` the clear button is disabled. */
    disableClear?: boolean;
    /** If `true` the reveal password button is disabled. Valid only when type is "password". */
    disableRevealPassword?: boolean;
    /** If `true` the search button is disabled. Valid only when type is "search". */
    disableSearchButton?: boolean;
    /**
     * If `true` the validation icon adornment is visible. Defaults to `false`.
     *
     * Currently, DS specifications define only a positive feedback icon;
     * errors are signaled through the border style and by displaying the error message.
     */
    showValidationIcon?: boolean;
    /** A custom icon to be added into the input. */
    endAdornment?: React.ReactNode;
    /** The maximum allowed length of the characters, if this value is null no check will be performed. */
    maxCharQuantity?: number;
    /** The minimum allowed length of the characters, if this value is null no check will be perform. */
    minCharQuantity?: number;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvInputClasses;
}

export declare interface HvInputSuggestion {
    id: string;
    label: string;
    value?: string;
}

declare interface HvInputValidity extends Partial<Mutable<ValidityState>> {
}

export declare interface HvKnobProperty {
    color?: string;
    defaultValue?: number;
    hidden?: boolean;
    fixed?: boolean;
    hoverColor?: string;
    trackColor?: string;
    dragColor?: string;
}

/**
 * Key Performance Indicator is a type of performance measurement. It monitors a business indicator
 * and its success/failure against a given target. KPIs are the first item read on a dashboard.
 * Communicates simple, immediate and vital information for operational decision making.
 * @deprecated build KPIs with `HvCard`, or with your custom layouts
 */
export declare const HvKpi: (props: HvKpiProps) => JSX_2.Element;

export declare type HvKpiClasses = ExtractNames<typeof useClasses_85>;

export declare type HvKpiLabelProps = Partial<typeof DEFAULT_LABELS_11>;

export declare interface HvKpiProps extends HvBaseProps<HTMLDivElement, "children"> {
    /**
     * An Element that will be rendered to the left of the kpi indicator text.
     */
    trendIndicator?: React.ReactNode;
    /**
     * An Element that will be rendered to the left of the kpi indicator text.
     */
    visualIndicator?: React.ReactNode;
    /**
     * An Element that will be rendered below the kpi indicator text.
     */
    visualComparison?: React.ReactNode;
    /**
     * The object that contains the different labels inside the kpi.
     */
    labels?: HvKpiLabelProps;
    /**
     *  The typography variant used in the main text indicator of the KPI
     */
    indicatorTextVariant?: "display" | "title1" | "title2";
    /**
     *  The typography variant used in the main text indicator of the KPI
     */
    indicatorUnitTextVariant?: "title2" | "body";
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvKpiClasses;
}

/**
 * Provides the user with a recognizable name for a given form element.
 */
export declare const HvLabel: (props: HvLabelProps) => JSX_2.Element;

export declare type HvLabelClasses = ExtractNames<typeof useClasses_9>;

export declare interface HvLabelProps extends HvTypographyProps<"label"> {
    /** Id to be applied to the root node */
    id?: string;
    /** The text to be shown by the label. */
    label?: React.ReactNode;
    /** Whether to give label gutter spacing */
    showGutter?: boolean;
    /** The id of the form element the label is bound to. */
    htmlFor?: string;
    /** If `true` the label is displayed with a disabled style. */
    disabled?: boolean;
    /** If `true`, the label will indicate that the form element is required (an `*` after the label text). */
    required?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvLabelClasses;
}

export declare const HvLeftControl: ({ id, classes: classesProp, className, children, placeholder, onSearch, hideSearch, searchProps, ...others }: HvLeftControlProps) => JSX_2.Element;

export declare type HvLeftControlClasses = ExtractNames<typeof useClasses_56>;

export declare interface HvLeftControlProps extends HvBaseProps {
    /** if `true` the hide sort by dropdown is not rendered */
    hideSearch?: boolean;
    /** placeholder of the input */
    placeholder?: string;
    /** Callback called when a search action occurs */
    onSearch?: (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>, value: string) => void;
    /** Extra props passed to input */
    searchProps?: HvInputProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvLeftControlClasses;
}

/** @deprecated use `<HvTypography link component="a" />` instead */
export declare const HvLink: (props: HvLinkProps) => JSX_2.Element;

export declare type HvLinkClasses = ExtractNames<typeof useClasses_86>;

export declare interface HvLinkProps extends HvBaseProps<HTMLAnchorElement, "onClick"> {
    onClick?: (event: React.MouseEvent<HTMLAnchorElement>, data: any) => void;
    route?: string;
    data?: any;
    children: any;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvLinkClasses;
}

/**
 * Component used to show a set of related data to the user.
 * @deprecated use `HvListContainer` + `HvListItem` instead
 */
export declare const HvList: (props: HvListProps) => JSX_2.Element | null;

export declare type HvListClasses = ExtractNames<typeof useClasses_87>;

/**
 * A <b>list</b> is any enumeration of a set of items.
 * The simple list is for continuous <b>vertical indexes of text or icons+text</b>. The content of these lists must be simple: ideally simples fields.
 * This pattern is ideal for <b>selections</b>. It should be used inside a HvPanel.
 */
export declare const HvListContainer: ForwardRefExoticComponent<HvListContainerProps & RefAttributes<HTMLUListElement>>;

export declare type HvListContainerClasses = ExtractNames<typeof useClasses_4>;

export declare interface HvListContainerProps extends HvBaseProps<HTMLUListElement> {
    /**
     * If the list items should be focusable and react to mouse over events.
     * Defaults to true if the list is selectable, false otherwise.
     */
    interactive?: boolean;
    /** If `true` compact the vertical spacing between list items. */
    condensed?: boolean;
    /** If `true`, the list items are _visually_ selectable. To enable selection, use `HvSelectionList` */
    selectable?: boolean;
    /** If `true`, the list items' left and right padding is removed. */
    disableGutters?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvListContainerClasses;
}

/**
 * Implements the listitem pattern, akin to the `<li>` element.
 * Should be composed within a `<HvListContainer>` component.
 */
export declare const HvListItem: ForwardRefExoticComponent<HvListItemProps & RefAttributes<HTMLLIElement>>;

export declare type HvListItemClasses = ExtractNames<typeof useClasses_5>;

export declare interface HvListItemProps extends HvBaseProps<HTMLLIElement> {
    /** Indicates if the list item is selected. */
    selected?: boolean;
    /** Indicated if the list item is _visually_ selectable */
    selectable?: boolean;
    /** If true, the list item will be disabled. */
    disabled?: boolean;
    /**
     * If the list item is focusable and reacts to mouse over events.
     * Defaults to true if the container list is interactive, false otherwise.
     */
    interactive?: boolean;
    /**
     * If `true` compacts the vertical spacing intended to separate the list items.
     * Defaults to the value set in container list.
     */
    condensed?: boolean;
    /**
     * If `true`, the left and right padding is removed.
     * Defaults to the value set in container list.
     */
    disableGutters?: boolean;
    /**
     * Element placed before the children.
     * Also removes the left padding (gutter).
     *
     * Some modifications are applied, assuming that it is either an icon (changing the color when the item is disabled)
     * or a selector (preventing the double focus ring, propagating the checked and disabled states and wiring the onChange event).
     * If unwanted, the element should be placed directly as a child.
     */
    startAdornment?: React.ReactNode;
    /**
     * Element placed after the children and aligned next to the margin.
     * Also removes the right padding (gutter).
     *
     * Some modifications are applied, assuming that it is an icon (changing the color when the item is disabled).
     * If unwanted, the element should be placed directly as a child.
     */
    endAdornment?: React.ReactNode;
    /** The value to be set on the 'li' element */
    value?: any;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvListItemClasses;
}

export declare type HvListLabels = Partial<typeof DEFAULT_LABELS_12>;

export declare interface HvListProps extends HvBaseProps<HTMLUListElement, "onChange" | "onClick"> {
    /**
     * A list containing the elements to be rendered.
     *
     * - id: The id of the item.
     * - label: The label of the element to be rendered.
     * - selected: The selection state of the element.
     * - disabled: The disabled state of the element.
     * - isHidden: Is item visible.
     * - icon: The icon.
     * - showNavIcon: If true renders the navigation icon on the right.
     * - path: The path to navigate to.
     */
    values: HvListValue[];
    /** If true renders a multi select list. */
    multiSelect?: boolean;
    /**
     * If true renders select all option for multi selection lists with selectors.
     * note: It will only be rendered if multiSelect and useSelector props are set to true.
     */
    showSelectAll?: boolean;
    /** An object containing all the labels for the dropdown. */
    labels?: HvListLabels;
    /** If true renders list items with radio or checkbox selectors. */
    useSelector?: boolean;
    /** Call back fired when list item is selected. Returns selection state. */
    onChange?: (value: HvListValue[]) => void;
    /** Call back fired when list item is selected. Returns selected item. */
    onClick?: (event: React.ChangeEvent<HTMLInputElement> | React.MouseEvent<HTMLLIElement>, value: HvListValue) => void;
    /** If `true` the list items will show the selection state. */
    selectable?: boolean;
    /** If `true`, selection can be toggled when single selection. */
    singleSelectionToggle?: boolean;
    /** If `true` the list will be rendered without vertical spacing. */
    condensed?: boolean;
    /** If `true` the dropdown will show tooltips when user mouseenter text in list. @deprecated this is always enabled */
    hasTooltips?: boolean;
    /** Experimental. Height of the dropdown, in case you want to control it from a prop. Styles can also be used through dropdownListContainer class. Required in case virtualized is used */
    height?: number;
    /** Experimental. Uses dropdown in a virtualized form, where not all options are rendered initially. Good for use cases with a lot of options. */
    virtualized?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvListClasses;
}

export declare interface HvListValue extends Record<string, any> {
    id?: string | number;
    label: React.ReactNode;
    searchValue?: string;
    selected?: boolean;
    disabled?: boolean;
    isHidden?: boolean;
    icon?: React.ReactNode | ((params: {
        isDisabled?: boolean;
        isSelected?: boolean;
    }) => React.ReactNode);
    showNavIcon?: boolean;
    path?: string;
    params?: object;
    tabIndex?: number;
}

/**
 * Loading provides feedback about a process that is taking place in the application.
 */
export declare const HvLoading: ForwardRefExoticComponent<HvLoadingProps & RefAttributes<HTMLDivElement>>;

export declare type HvLoadingClasses = ExtractNames<typeof useClasses_88>;

/**
 * A component that wraps `children` with an `HvLoading` component and
 * and an overlay background with opacity.
 *
 * @example
 * <HvLoadingContainer label="Loading..." hidden={!isLoading}>
 *  <MyComponent>
 * </HvLoadingContainer>
 * */
export declare const HvLoadingContainer: ForwardRefExoticComponent<HvLoadingContainerProps & RefAttributes<HTMLDivElement>>;

export declare type HvLoadingContainerClasses = ExtractNames<typeof useClasses_89>;

export declare interface HvLoadingContainerProps extends HvBaseProps<HTMLDivElement>, Pick<HvLoadingProps, "label" | "small" | "hidden"> {
    opacity?: number;
    classes?: HvLoadingContainerClasses;
}

export declare interface HvLoadingProps extends HvBaseProps {
    /** Indicates if the component should be render in a small size. */
    small?: boolean;
    /** The label to be displayed.  */
    label?: React.ReactNode;
    /** Whether the loading animation is hidden. */
    hidden?: boolean;
    /** Color applied to the bars. */
    color?: HvColorAny;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvLoadingClasses;
}

/**
 * Container layout for the login form.
 */
export declare const HvLogin: ForwardRefExoticComponent<HvLoginProps & RefAttributes<HTMLDivElement>>;

export declare type HvLoginClasses = ExtractNames<typeof useClasses_90>;

export declare interface HvLoginProps extends HvBaseProps {
    /**
     *  The path for the background image.
     */
    background?: string;
    /**
     * Class names to be applied.
     */
    classes?: HvLoginClasses;
}

export declare interface HvMarkProperty {
    position?: number;
    label?: string;
}

export declare type HvMeta<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, Extension = never, M = HvMetaBase<D, H>> = [Extension] extends [never] ? M : M & Extension;

declare interface HvMetaBase<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> {
    instance: HvTableInstance<D, H>;
    userProps: any;
}

/**
 * Multi-buttons are grouped sets of buttons displayed horizontally or vertically in the same container.
 */
export declare const HvMultiButton: (props: HvMultiButtonProps) => JSX_2.Element;

export declare type HvMultiButtonClasses = ExtractNames<typeof useClasses_91>;

export declare interface HvMultiButtonProps extends HvBaseProps {
    /** If all the buttons are disabled. */
    disabled?: boolean;
    /** If the MultiButton is to be displayed vertically. */
    vertical?: boolean;
    /** Button variant to use when in `split` mode */
    variant?: HvButtonVariant;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvMultiButtonClasses;
    /** Button size when in `split` mode. */
    size?: HvSize;
    /** Add a split between buttons */
    split?: boolean;
}

export declare const hvNodeFallback: (value: any) => any;

export declare interface HvNotistackSnackMessageProps extends OptionsObject {
    /** Id to be applied to the root node. */
    id?: string;
    /** class name to apply on the root node */
    className?: string;
    /** Your component tree. */
    message?: React.ReactNode;
    /** Variant of the snackbar. */
    variant?: HvSnackbarVariant;
    /** Extra values to pass to the snackbar. */
    snackbarContentProps?: HvSnackbarContentProps;
}

export declare function hvNumberColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>): HvTableColumnConfig<D, H>;

export declare const hvNumberFallback: (value: any) => number | "—";

export declare const HvOption: <OptionValue extends {}>(props: HvOptionProps<OptionValue> & RefAttributes<HTMLLIElement>) => React.ReactElement | null;

/**
 * Optional
 * @desc From `T` make a set of properties by key `K` become optional
 * @example
 *    type Props = {
 *      name: string;
 *      age: number;
 *      visible: boolean;
 *    };
 *
 *    // Expect: { name?: string; age?: number; visible?: boolean; }
 *    type Props = Optional<Props>;
 *
 *    // Expect: { name: string; age?: number; visible?: boolean; }
 *    type Props = Optional<Props, 'age' | 'visible'>;
 */
export declare type HvOptional<T extends object, K extends keyof T = keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export declare type HvOptionClasses = ExtractNames<typeof useClasses_14>;

export declare const HvOptionGroup: ForwardRefExoticComponent<Omit<HvOptionGroupProps, "ref"> & RefAttributes<HTMLLIElement>>;

export declare type HvOptionGroupClasses = ExtractNames<typeof useClasses_15>;

export declare interface HvOptionGroupProps extends OptionGroupProps {
    classes?: HvOptionGroupClasses;
}

export declare interface HvOptionProps<OptionValue extends {}> extends Omit<HvListItemProps, "value" | "disabled">, Pick<OptionOwnProps<OptionValue>, "disabled" | "label" | "value"> {
    classes?: HvOptionClasses;
}

/**
 * This component generates a tooltip whenever the text is overflowed.
 */
export declare const HvOverflowTooltip: (props: HvOverflowTooltipProps) => JSX_2.Element;

export declare type HvOverflowTooltipClasses = ExtractNames<typeof useClasses_92>;

export declare interface HvOverflowTooltipProps extends HvBaseProps {
    /** The node that will be rendered inside the tooltip. */
    data: React.ReactNode;
    /** If true, the tooltip is shown. */
    open?: boolean;
    /** If `true`, the overflow tooltip will always use the paragraph overflow style. */
    paragraphOverflow?: boolean;
    /** Tooltip placement. */
    placement?: "bottom-end" | "bottom-start" | "bottom" | "left-end" | "left-start" | "left" | "right-end" | "right-start" | "right" | "top-end" | "top-start" | "top";
    /** Extra properties to add to the tooltip. */
    tooltipsProps?: Partial<HvTooltipProps>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvOverflowTooltipClasses;
}

/**
 * Pagination is the process of dividing a document into discrete pages. It relates to how users interact
 * with structured content on a website or application.
 */
export declare const HvPagination: ForwardRefExoticComponent<HvPaginationProps & RefAttributes<HTMLDivElement>>;

export declare type HvPaginationClasses = ExtractNames<typeof useClasses_47>;

export declare type HvPaginationLabels = Partial<typeof DEFAULT_LABELS_3>;

export declare type HvPaginationPropGetter<D extends object> = PropGetter<D, HvTablePaginationProps>;

export declare interface HvPaginationProps extends HvBaseProps {
    /** The number of pages the component has. */
    pages?: number;
    /** The currently selected page (0-indexed). */
    page?: number;
    /** Controls whether the left page size mechanism should be visible. */
    showPageSizeOptions?: boolean;
    /** The array of possible page sizes for the dropdown. */
    pageSizeOptions?: number[];
    /** The currently selected page size. */
    pageSize?: number;
    /** Controls whether the central page changing mechanism should be visible. */
    showPageJump?: boolean;
    /** Controls whether the previous/first page buttons are enabled. */
    canPrevious?: boolean;
    /** Controls whether the next/last page buttons are enabled. */
    canNext?: boolean;
    /** Function called when the page changes. */
    onPageChange?: (page: number) => void;
    /** Function called when the page size changes. */
    onPageSizeChange?: (pageSize: number) => void;
    /** An object containing all the labels for the component. */
    labels?: HvPaginationLabels;
    /** Other props to show page component. */
    showPageProps?: React.HTMLAttributes<HTMLDivElement>;
    /** Other props to pagination component. */
    navigationProps?: React.HTMLAttributes<HTMLDivElement>;
    /** Extra properties passed to the input component representing the current pages. */
    currentPageInputProps?: HvInputProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvPaginationClasses;
}

/**
 * A panel is a container used in a variety of patterns (e.g. dropdown, filter group, details section).
 * It can be horizontal or vertical and its size is defined by its content and how it relates to surrounding patterns.
 * Regardless of its content, a panel look and feel should be consistent.
 */
export declare const HvPanel: ForwardRefExoticComponent<HvPanelProps & RefAttributes<HTMLDivElement>>;

export declare type HvPanelClasses = ExtractNames<typeof useClasses_94>;

export declare interface HvPanelProps extends HvBaseProps {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvPanelClasses;
}

export declare type HvPolarizedColorKeys = "positive" | "positive_120" | "positive_80" | "warning" | "warning_120" | "warning_140" | "negative" | "cat21" | "cat22" | "cat23" | "cat24" | "cat25" | "cat26" | "cat27" | "cat28" | "catastrophic";

export declare const HvProgressBar: (props: HvProgressBarProps) => JSX_2.Element;

export declare type HvProgressBarClasses = ExtractNames<typeof useClasses_95>;

/**
 * ProgressBar provides feedback about a process that is taking place in the application.
 */
export declare interface HvProgressBarProps extends HvBaseProps {
    /** The value of the progress bar. */
    value: number;
    /**
     * The status of the progress bar.
     *
     * inProgress is black, error is red and completed is green.
     *
     * When uncontrolled and unspecified it will default to "inProgress".
     */
    status?: HvProgressBarStatus;
    /** Aria Properties passed on to the progress bar. */
    labelProps?: HvTypographyProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvProgressBarClasses;
    /**
     * True if the text label should not be displayed.
     */
    hideLabel?: boolean;
}

export declare type HvProgressBarStatus = "inProgress" | "completed" | "error";

export declare function hvProgressColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, getPartial?: (row: HvRowInstance<D, H>) => number, getTotal?: (row: HvRowInstance<D, H>) => number, color?: "primary" | "secondary"): HvTableColumnConfig<D, H>;

export declare const HvProgressColumnCell: ({ partial, total, color, "aria-labelledby": ariaLabelledBy, }: HvProgressColumnCellProp) => JSX.Element;

export declare interface HvProgressColumnCellProp {
    /** Current value of the bar. */
    partial: number;
    /** Maximum value of the bar. */
    total: number;
    /** The color of the bar. */
    color?: "primary" | "secondary";
    "aria-labelledby"?: string;
}

export declare type HvPropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, Props extends object = Record<string, unknown>, T extends object = never, P = Partial<Props>> = ((props: P, meta: HvMeta<D, H, T>) => P | P[]) | P | P[];

/**
 * Enables theming capabilities and makes cross-component theme properties available down the tree.
 */
export declare const HvProvider: ({ children, rootElementId, cssBaseline, cssTheme, themes, theme, colorMode, emotionCache: emotionCacheProp, classNameKey, }: HvProviderProps) => JSX_2.Element;

export declare interface HvProviderProps {
    /**
     * Your component tree.
     */
    children?: React.ReactNode;
    /**
     * Id of your root element.
     */
    rootElementId?: string;
    /**
     * By default the baseline styles are applied globally, `global`, to the application for the UI Kit components to work properly.
     * If you need to scope the baseline styles to avoid styling conflicts, you can set this property to `scoped`.
     * To scope the baseline to your root, you need to add the `rootElementId` property.
     * If the `rootElementId` property is not set, the baseline will be scoped to a new container, `hv-uikit-scoped-root*`, created around your content.
     * If you are providing your own baseline styles, you can set this property to `none` to disable the baseline styles.
     */
    cssBaseline?: "global" | "scoped" | "none";
    /**
     * By default the theme styles are applied globally, `global`, to the application.
     * If you need to scope the theme styles to avoid styling conflicts, you can set this property to `scoped`.
     * To scope the theme to your root, you need to add the `rootElementId` property.
     * If the `rootElementId` property is not set, the theme will be scoped to a new container, `hv-uikit-scoped-root*`, created around your content.
     */
    cssTheme?: "global" | "scoped";
    /**
     * The string used to prefix the class names and uniquely identify them. The key can only contain lower case alphabetical characters.
     * This is useful to avoid class name collisions.
     *
     * If `emotionCache` is passed, this is value is ignored.
     *
     * @default "hv"
     */
    classNameKey?: string;
    /**
     * The emotion cache instance to use. If no value is provided, the default cache is used.
     */
    emotionCache?: EmotionCache;
    /**
     * List of themes to be used by UI Kit.
     * You can provide your own themes created with the `createTheme` utility and/or the default themes `ds3` and `ds5` provided by UI Kit.
     *
     * If no value is provided, the `ds5` theme will be used.
     */
    themes?: (HvTheme | HvThemeStructure)[];
    /**
     * The active theme. It must be one of the themes passed to `themes`.
     *
     * If no value is provided, the first theme from the `themes` list is used. If no `themes` list is provided, the `ds5` theme will be used.
     */
    theme?: string;
    /**
     * The active color mode. It must be one of the color modes of the active theme.
     *
     * If no value is provided, the first color mode defined in the active theme is used.
     * For the default themes `ds3` and `ds5`, the `dawn` color mode is the one used.
     */
    colorMode?: string;
}

/**
 * This component allows you to create conditions and group them using logical operators.
 * It outputs a structured set of rules which can be easily parsed to create SQL/NoSQL/whatever queries.
 *
 * Take a look at the [usage page](https://lumada-design.github.io/uikit/master/?path=/docs/widgets-query-builder-usage--docs) to learn more about this component.
 */
export declare const HvQueryBuilder: (props: HvQueryBuilderProps) => JSX_2.Element;

export declare interface HvQueryBuilderAttribute extends Record<string, unknown> {
    id?: string;
    label: string;
    type: DefaultAttributes | (string & {});
}

/** @deprecated */
export declare interface HvQueryBuilderChangedQuery extends Omit<HvQueryBuilderQuery, "id" | "rules"> {
    rules: Array<Omit<HvQueryBuilderQueryRule, "id"> | HvQueryBuilderChangedQuery>;
}

export declare type HvQueryBuilderClasses = ExtractNames<typeof useClasses_96>;

declare interface HvQueryBuilderContextValue {
    dispatchAction: React.Dispatch<QueryAction>;
    askAction: React.Dispatch<React.SetStateAction<AskAction | undefined>>;
    selectLocation?: React.Dispatch<unknown>;
    attributes?: Record<string, HvQueryBuilderAttribute>;
    operators: Record<string, HvQueryBuilderQueryOperator[]>;
    combinators: HvQueryBuilderQueryCombinator[];
    maxDepth: number;
    labels: HvQueryBuilderLabels;
    initialTouched: boolean;
    readOnly: boolean;
    disableConfirmation: boolean;
    allowRepeatedAttributes?: boolean;
    renderers?: HvQueryBuilderRenderers;
    emptyRenderer?: string[];
}

export declare interface HvQueryBuilderDateTimeRange {
    start?: HvQueryBuilderDateTimeStrings;
    end?: HvQueryBuilderDateTimeStrings;
}

export declare interface HvQueryBuilderDateTimeStrings {
    date?: string;
    time?: string;
}

export declare const hvQueryBuilderDefaultCombinators: {
    operand: string;
    label: string;
}[];

export declare const hvQueryBuilderDefaultLabels: HvQueryBuilderLabels;

export declare const hvQueryBuilderDefaultOperators: {
    numeric: {
        operator: string;
        label: string;
        combinators: string[];
    }[];
    text: {
        operator: string;
        label: string;
        combinators: string[];
    }[];
    textarea: {
        operator: string;
        label: string;
        combinators: string[];
    }[];
    boolean: {
        operator: string;
        label: string;
        combinators: string[];
    }[];
    dateandtime: {
        operator: string;
        label: string;
        combinators: string[];
    }[];
};

export declare interface HvQueryBuilderLabels {
    query?: {
        delete?: ActionIconLabels;
        addRule?: {
            label: string;
        };
        addGroup?: {
            label: string;
        };
    };
    rule: {
        attribute: {
            exists: string;
            label: string;
            placeholder: string;
        };
        operator: {
            label: string;
            placeholder: string;
        };
        value: {
            distance: {
                label: string;
                placeholder?: string;
                connectorText: string;
                button: string;
                validation: {
                    required: string;
                    invalid: string;
                };
            };
            text: {
                label: string;
                placeholder: string;
                validation: {
                    required: string;
                };
            };
            boolean: {
                label: string;
                placeholder: string;
                options: Record<string, string>;
            };
            numeric: {
                label: string;
                placeholder: string;
                validation: {
                    required: string;
                    invalid: string;
                    equal: string;
                    greaterThan: string;
                };
                range: {
                    leftLabel: string;
                    rightLabel: string;
                };
            };
            datetime: {
                dateLabel: string;
                datePlaceholder: string;
                timeLabel: string;
                timePlaceholder: string;
                startDateLabel: string;
                startDatePlaceholder: string;
                startTimeLabel: string;
                startTimePlaceholder: string;
                endDateLabel: string;
                endDatePlaceholder: string;
                endTimeLabel: string;
                endTimePlaceholder: string;
                validation: {
                    required: string;
                    invalidInterval: string;
                };
            };
        };
        delete: ActionIconLabels;
    };
    group: {
        delete: ActionIconLabels;
        reset: ActionIconLabels;
        addRule: {
            label: string;
        };
        addGroup: {
            label: string;
        };
    };
    empty: {
        title: string;
        createCondition: string;
        createGroup: string;
        spacer: string;
    };
}

export declare interface HvQueryBuilderNumericRange {
    from: number | string;
    to: number | string;
}

export declare interface HvQueryBuilderProps {
    /** The query attribute types. */
    attributes?: Record<string, HvQueryBuilderAttribute>;
    /** The query rules operators by attribute type and combinator. */
    operators?: Record<string, HvQueryBuilderQueryOperator[]>;
    /** The query combinators operands. */
    combinators?: HvQueryBuilderQueryCombinator[];
    /** The query when the component is controlled. */
    value?: HvQueryBuilderQuery;
    /** The initial query when the component is uncontrolled. */
    defaultValue?: HvQueryBuilderQuery;
    /**
     * The initial query when the component is uncontrolled.
     *
     * @deprecated Use `defaultValue` instead.
     * */
    query?: HvQueryBuilderQuery;
    /** Callback fired when the query changes. */
    onChange?: (value: HvQueryBuilderQuery) => void;
    /** Max depth of nested query groups. */
    maxDepth?: number;
    /** Object containing all the labels. */
    labels?: DeepPartial<HvQueryBuilderLabels>;
    /** Whether the query builder is in read-only mode. */
    readOnly?: boolean;
    /**
     * Operators that should use the empty value renderer when selected.
     *
     * When one of the listed operators is selected, the rule value is reset and an empty component is rendered.
     * This property takes priority over `renderers`.
     *
     * @default ["Empty", "IsNotEmpty"]
     * */
    emptyRenderer?: string[];
    /** Custom renderers for the rules' value. */
    renderers?: HvQueryBuilderRenderers;
    /** Whether to opt-out of the confirmation dialogs shown before removing rules and rule groups. @default false. */
    disableConfirmation?: boolean;
    /**
     * Whether to allow attributes to be repeated in AND conditions.
     * By default an error is shown when the selected attribute already exists in an AND conditions.
     * @default false
     */
    allowRepeatedAttributes?: boolean;
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvQueryBuilderClasses;
}

export declare type HvQueryBuilderQuery = HvQueryBuilderQueryGroup;

export declare interface HvQueryBuilderQueryCombinator {
    operand: string;
    label: string;
}

export declare interface HvQueryBuilderQueryGroup extends Omit<HvOptional<QueryGroup, "id">, "rules"> {
    rules: Array<HvQueryBuilderQueryRule | HvQueryBuilderQueryGroup>;
}

export declare interface HvQueryBuilderQueryOperator {
    operator: string;
    label: string;
    combinators: string[];
}

export declare type HvQueryBuilderQueryRule = HvOptional<QueryRule, "id">;

export declare type HvQueryBuilderQueryRuleValue = string | number | boolean | HvQueryBuilderNumericRange | HvQueryBuilderDateTimeStrings | HvQueryBuilderDateTimeRange;

export declare interface HvQueryBuilderRendererProps<V = any> {
    id: React.Key;
    attribute: string;
    operator?: string;
    value?: V;
}

export declare type HvQueryBuilderRenderers = Record<string, ValueRenderer>;

/**
 * A Radio Button is a mechanism that allows user to select just an option from a group of options.
 *
 * It should used in a Radio Button Group to present the user with a range of options from
 * which the user **may select just one option** to complete their task.
 *
 * Individual use of radio buttons, at least uncontrolled, is unadvised as React state management doesn't
 * respond to the browser's native management of radio inputs checked state.
 */
export declare const HvRadio: ForwardRefExoticComponent<Omit<HvRadioProps, "ref"> & RefAttributes<HTMLButtonElement>>;

export declare type HvRadioClasses = ExtractNames<typeof useClasses_97>;

/**
 * A radio group is a type of selection list that can only have a single entry checked at any one time.
 */
export declare const HvRadioGroup: ForwardRefExoticComponent<HvRadioGroupProps & RefAttributes<HTMLDivElement>>;

export declare type HvRadioGroupClasses = ExtractNames<typeof useClasses_66>;

export declare interface HvRadioGroupProps extends HvBaseProps<HTMLDivElement, "onChange"> {
    /**
     * The form element name.
     *
     * It is propagated to the children radio buttons, unless they already have one (which they shouldn't).
     */
    name?: string;
    /**
     * The value of the form element, represented in one of the child radio buttons values.
     *
     * When defined the radio button group state becomes controlled.
     */
    value?: any;
    /**
     * When uncontrolled, defines the initial value.
     */
    defaultValue?: any;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /**
     * Provide additional descriptive text for the form element.
     */
    description?: React.ReactNode;
    /**
     * Indicates that the form element is disabled.
     * If `true` the state is propagated to the children radio buttons.
     */
    disabled?: boolean;
    /**
     * Indicates that the form element is not editable.
     * If `true` the state is propagated to the children radio buttons.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required on the form element.
     * If `true` the state is propagated to the children radio buttons' input element.
     */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when `status` is "invalid".
     */
    statusMessage?: React.ReactNode;
    /**
     * The callback fired when the value changes.
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>, value: any) => void;
    /**
     * Indicates whether the radio buttons group's orientation is horizontal or vertical.
     *
     * Defaults to vertical.
     */
    orientation?: "vertical" | "horizontal";
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvRadioGroupClasses;
}

export declare interface HvRadioProps extends Omit<RadioProps, "onChange" | "classes"> {
    /**
     * A Jss Object used to override or extend the styles applied to the radio button.
     */
    classes?: HvRadioClasses;
    /**
     * The form element name.
     */
    name?: string;
    /**
     * The value of the form element.
     *
     * The default value is "on".
     */
    value?: any;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided.
     */
    label?: React.ReactNode;
    /**
     * Properties passed on to the label element.
     */
    labelProps?: HvLabelProps;
    /**
     * Indicates that user input is required on the form element.
     *
     * If a single radio button in a group has the required attribute, a radio button in
     * that group must be check, though it doesn't have to be the one with the attribute is applied.
     *
     * For that reason, the component doesn't make any uncontrolled changes to its validation status.
     * That should ideally be managed in the context of a radio button group.
     */
    required?: boolean;
    /**
     * Indicates that the form element is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that the form element is disabled.
     */
    disabled?: boolean;
    /**
     * If `true` the radio button is selected, if set to `false` the radio button is not selected.
     *
     * When defined the radio button state becomes controlled.
     */
    checked?: boolean;
    /**
     * When uncontrolled, defines the initial checked state.
     */
    defaultChecked?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     */
    status?: HvRadioStatus;
    /**
     * The error message to show when `status` is "invalid".
     */
    statusMessage?: string;
    /**
     * Identifies the element that provides an error message for the radio button.
     *
     * Will only be used when the validation status is invalid.
     */
    "aria-errormessage"?: string;
    /**
     * The callback fired when the radio button is pressed.
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>, checked: boolean, value: any) => void;
    /**
     * Whether the selector should use semantic colors.
     */
    semantic?: boolean;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible?: (event: React.FocusEvent<any>) => void;
    /** @ignore */
    ref?: RadioProps["ref"];
    /** @ignore */
    component?: RadioProps["component"];
}

export declare type HvRadioStatus = "standBy" | "valid" | "invalid";

export { HvRadius }

export declare const HvRightControl: ({ id, classes: classesProp, className, children, values, onSort, hideSortBy, sortProps, ...others }: HvRightControlProps) => JSX_2.Element;

export declare type HvRightControlClasses = ExtractNames<typeof useClasses_57>;

export declare interface HvRightControlProps extends HvBaseProps {
    /** if `true` the hide sort by dropdown is not rendered */
    hideSortBy?: boolean;
    /** options for the dropdown to sort */
    values?: HvRightListControls[];
    /** Callback called when a sort action occurs */
    onSort?: (selected: HvRightListControls | undefined) => void;
    /** Extra props passed to dropdown */
    sortProps?: HvDropdownProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvRightControlClasses;
}

export declare interface HvRightListControls extends HvListValue {
    accessor: string;
    desc: boolean;
}

export declare interface HvRowInstance<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<Row<D>, "cells" | "allCells" | "subRows" | "getRowProps">, Partial<Omit<UseGroupByRowProps<D>, "subRows" | "values">>, Partial<UseRowStateRowProps<D>>, Partial<Omit<UseHvRowExpandRowInstance<D>, "subRows">>, Partial<UseHvRowSelectionRowInstance> {
    cells: Array<HvCellInstance<D, H>>;
    allCells: Array<HvCellInstance<D, H>>;
    getRowProps: (propGetter?: HvRowPropGetter<D, H>) => HvUseTableRowProps;
    index: number;
    original: D;
    id: string;
    subRows: Array<HvRowInstance<D, H>>;
}

declare type HvRowPropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvPropGetter<D, H, HvUseTableRowProps, {
    row: HvRowInstance<D, H>;
}>;

/**
 * The horizontal scroll to element can be used to quickly navigate in a page.
 */
export declare const HvScrollToHorizontal: (props: HvScrollToHorizontalProps) => JSX_2.Element;

export declare type HvScrollToHorizontalClasses = ExtractNames<typeof useClasses_99>;

export declare type HvScrollToHorizontalPositions = "sticky" | "fixed" | "relative";

export declare interface HvScrollToHorizontalProps extends HvBaseProps<HTMLOListElement, "onChange" | "onClick"> {
    /** An Array of Objects with Label and Value. Label is the displayed Element and Value is the local navigation location applied */
    options: HvScrollToOption[];
    /**
     * Should the active element be reflected in the URL.
     *
     * @default true
     *
     * @deprecated Use `navigationMode` instead.
     * */
    href?: boolean;
    /**
     * The navigation mode to be used when the user clicks on a tab element.
     * - `push` will add a new entry to the history stack.
     * - `replace` will replace the current entry on the history stack.
     * - `none` will not add any entry to the history stack.
     *
     * Defaults to `push`, unless the deprecated `href` prop is set to `false`, in which case it defaults to `none`.
     *
     * When set to `none`, then each element will render a button instead of a link.
     *
     * @default "push"
     */
    navigationMode?: "push" | "replace" | "none";
    /**
     * When set to `true`, the generated links will be relative (e.g. `#section`).
     * Relative URLs take into account not only the current location, but also the base URL if it is set (i.e. a `<base>` tag).
     * This can lead to unexpected behavior.
     *
     * When set to `false`, the links will be generated from the current location's full URL (e.g. `http://example.com/hello/world?value=123#section`).
     *
     * @default false
     */
    relativeLinks?: boolean;
    /** Default selected index passed from the parent. */
    defaultSelectedIndex?: number;
    /**
     * The Id of the scrollable container containing displayed elements.
     *
     * Defaults to `window` if unspecified.
     */
    scrollElementId?: string;
    /**
     * Defines the offset from the top of each element for getting an optimal viewing region in the container.
     * This allows to exclude regions of the container that are obscured by other content (such as fixed-positioned toolbars or titles)
     * or to put more breathing room between the targeted element and the edges of the container.
     *
     * Each element can also have a specific offset via the options property.
     */
    offset?: number;
    /** Position of the Horizontal scroll to. */
    position?: HvScrollToHorizontalPositions;
    /** Position of tooltip identifying the current item. */
    tooltipPosition?: HvScrollToTooltipPositions;
    /** A function called each time the selected index changes. */
    onChange?: (event: Event | React.MouseEvent<HTMLDivElement | HTMLAnchorElement> | React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement>, index: number) => void;
    /** A function called each time an user clicks on a tab element. */
    onClick?: (event: React.MouseEvent<HTMLDivElement | HTMLAnchorElement>, index: number) => void;
    /** A function called each time an user press enter on a tab element. */
    onEnter?: (event: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement>, index: number) => void;
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvScrollToHorizontalClasses;
}

declare interface HvScrollToOption {
    key?: React.Key;
    label: string;
    value: string;
    offset?: number;
}

declare type HvScrollToTooltipPositions = "left" | "right" | "top" | "bottom";

/**
 * The vertical scroll to element can be used to quickly navigate in a page.
 */
export declare const HvScrollToVertical: (props: HvScrollToVerticalProps) => JSX_2.Element;

export declare type HvScrollToVerticalClasses = ExtractNames<typeof useClasses_101>;

declare type HvScrollToVerticalPositions = "absolute" | "fixed" | "relative";

export declare interface HvScrollToVerticalProps extends HvBaseProps<HTMLOListElement, "onChange" | "onClick"> {
    /** An Array of Objects with Label and Value. Label is the displayed Element and Value is the local navigation location applied */
    options: HvScrollToOption[];
    /**
     * Should the active element be reflected in the URL.
     *
     * @default true
     *
     * @deprecated Use `navigationMode` instead.
     * */
    href?: boolean;
    /**
     * The navigation mode to be used when the user clicks on a tab element.
     * - `push` will add a new entry to the history stack.
     * - `replace` will replace the current entry on the history stack.
     * - `none` will not add any entry to the history stack.
     *
     * Defaults to `push`, unless the deprecated `href` prop is set to `false`, in which case it defaults to `none`.
     *
     * When set to `none`, then each element will render a button instead of a link.
     *
     * @default "push"
     */
    navigationMode?: "push" | "replace" | "none";
    /**
     * When set to `true`, the generated links will be relative (e.g. `#section`).
     * Relative URLs take into account not only the current location, but also the base URL if it is set (i.e. a `<base>` tag).
     * This can lead to unexpected behavior.
     *
     * When set to `false`, the links will be generated from the current location's full URL (e.g. `http://example.com/hello/world?value=123#section`).
     *
     * @default false
     */
    relativeLinks?: boolean;
    /** Default selected index passed from the parent. */
    defaultSelectedIndex?: number;
    /**
     * The Id of the scrollable container containing displayed elements.
     *
     * Defaults to `window` if unspecified.
     */
    scrollElementId?: string;
    /**
     * Defines the offset from the top of each element for getting an optimal viewing region in the container.
     * This allows to exclude regions of the container that are obscured by other content (such as fixed-positioned toolbars or titles)
     * or to put more breathing room between the targeted element and the edges of the container.
     *
     * Each element can also have a specific offset via the options property.
     */
    offset?: number;
    /** Position of the Vertical scroll to. */
    position?: HvScrollToVerticalPositions;
    /** Position of tooltip identifying the current item. */
    tooltipPosition?: HvScrollToTooltipPositions;
    /** A function called each time the selected index changes. */
    onChange?: (event: Event | React.MouseEvent<HTMLDivElement | HTMLAnchorElement> | React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement>, index: number) => void;
    /** A function called each time an user clicks on a tab element. */
    onClick?: (event: React.MouseEvent<HTMLDivElement | HTMLAnchorElement>, index: number) => void;
    /** A function called each time an user press enter on a tab element. */
    onEnter?: (event: React.KeyboardEvent<HTMLDivElement | HTMLAnchorElement>, index: number) => void;
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvScrollToVerticalClasses;
}

/**
 * Sections allow grouping information on a page under the same topic.
 */
export declare const HvSection: ForwardRefExoticComponent<HvSectionProps & RefAttributes<HTMLDivElement>>;

export declare type HvSectionClasses = ExtractNames<typeof useClasses_102>;

export declare interface HvSectionProps extends Omit<HvBaseProps<HTMLDivElement>, "title" | "onToggle"> {
    /** The title of the section */
    title?: React.ReactNode;
    /** Whether or not the section is expandable.  */
    expandable?: boolean;
    /** Whether the section is open or not, if this property is defined the accordion must be fully controlled. */
    expanded?: boolean;
    /** When uncontrolled, defines the initial expanded state. */
    defaultExpanded?: boolean;
    /** Section actions */
    actions?: React.ReactNode;
    /** Section onExpand callback */
    onToggle?: (event: React.MouseEvent<HTMLButtonElement>, open: boolean) => void;
    /** Props to be passed to the expand button */
    expandButtonProps?: HvButtonProps;
    /** Determines whether or not the header has a shadow on the bottom border. */
    raisedHeader?: boolean;
    /** A Jss Object used to override or extend the styles applied to the empty state component. */
    classes?: HvSectionClasses;
    /** Content container ref. */
    contentRef?: React.Ref<HTMLDivElement>;
}

/**
 * The `HvSelect` component is a form control element that allows selection from a list of options.
 *
 * It aims to be aligned with the native HTML `<select>` and `<option>` APIs and be easily integrated with forms.
 *
 * @example
 * <HvSelect name="pets">
 *   <HvOption value="dog">Dog</HvOption>
 *   <HvOption value="cat">Cat</HvOption>
 * </HvSelect>
 * */
export declare const HvSelect: <OptionValue extends {}, Multiple extends boolean = false>(props: HvSelectProps<OptionValue, Multiple> & RefAttributes<HTMLButtonElement>) => React.ReactElement | null;

export declare type HvSelectClasses = ExtractNames<typeof useClasses_12>;

/**
 * Allows the user to select one or more items from a list of choices.
 *
 * Although it supports multi-selection, DS recommends the use of a selection list
 * when it’s clear that the user can only select just one option from the range provided.
 */
export declare const HvSelectionList: ForwardRefExoticComponent<HvSelectionListProps & RefAttributes<HTMLUListElement>>;

export declare type HvSelectionListClasses = ExtractNames<typeof useClasses_16>;

export declare interface HvSelectionListProps extends HvBaseProps<HTMLUListElement, "onChange"> {
    /** The form element name. */
    name?: string;
    /**
     * The value of the form element. It must be represented in the child list items.
     *
     * Can either be a single value (when multiple = false) or an
     * array of values (when multiple = true).
     *
     * When defined the selection list state becomes controlled.
     */
    value?: any | any[];
    /** When uncontrolled, defines the initial value. */
    defaultValue?: any | any[];
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /** Provide additional descriptive text for the form element. */
    description?: React.ReactNode;
    /** Indicates that the form element is disabled. If `true` the state is propagated to the children list items. */
    disabled?: boolean;
    /** Indicates that the form element is not editable. */
    readOnly?: boolean;
    /** Indicates that user input is required on the form element. */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when the validation status is "invalid".
     *
     * Defaults to "Required" when the status is uncontrolled and no `aria-errormessage` is provided.
     */
    statusMessage?: string;
    /** Indicates that the user may select more than one item from the current selectable list items. */
    multiple?: boolean;
    /** If `true`, selection can be toggled when single selection. */
    singleSelectionToggle?: boolean;
    /** Indicates whether the list orientation is horizontal or vertical. Defaults to vertical. */
    orientation?: "vertical" | "horizontal";
    /** The callback fired when the value changes. */
    onChange?: (event: React.MouseEvent, value: any) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSelectionListClasses;
}

export declare interface HvSelectProps<OptionValue extends {}, Multiple extends boolean = false> extends Omit<HvFormElementProps, "value" | "defaultValue" | "onChange">, Pick<UseSelectParameters<OptionValue, Multiple>, "name" | "required" | "disabled" | "multiple" | "open" | "defaultOpen" | "value" | "defaultValue" | "buttonRef" | "options" | "getSerializedValue" | "onChange" | "onOpenChange">, Pick<HvButtonProps, "size" | "variant"> {
    classes?: HvSelectClasses;
    placeholder?: React.ReactNode;
    autoComplete?: string;
    /** Whether the width of the select panel can vary independently. */
    variableWidth?: boolean;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
    /**  If enabled the panel will be rendered using a portal , if disabled will be under the DOM hierarchy of the parent component. */
    enablePortal?: boolean;
}

export { HvSemanticColor }

export declare type HvSemanticColorKeys = HvSemanticColor;

export declare type HvSemanticColors = Record<HvSemanticColorKeys, string>;

export declare type HvSequentialColorKeys = "cat1" | "cat1_100" | "cat1_200" | "cat1_300" | "cat1_400" | "cat1_500" | "cat1_600" | "cat1_700" | "cat1_800" | "cat1_900";

export declare const HvSimpleGrid: (props: HvSimpleGridProps) => JSX_2.Element;

export declare type HvSimpleGridClasses = ExtractNames<typeof useClasses_103>;

/** Grid component that enables you to create columns of equal width and define your own breakpoints and responsive behavior. */
export declare interface HvSimpleGridProps extends HvBaseProps {
    /** Spacing with pre-defined values according the values defined in the theme */
    spacing?: HvBreakpoints;
    /**
     * Provide an array to define responsive behavior:
     * - `maxWidth` or `minWidth`: max-width or min-width at which media query will work
     * - `cols`: number of columns per row at given max-width
     * - `spacing`: optional spacing at given max-width, if not provided spacing from component prop will be used instead
     */
    breakpoints?: Breakpoint[];
    /** Number of how many columns the content will be displayed */
    cols?: number;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSimpleGridClasses;
}

declare type HvSingleCalendarClasses = ExtractNames<typeof useClasses_39>;

declare interface HvSingleCalendarProps extends Omit<HvCalendarProps, "classes"> {
    /**
     * Styles applied from the theme.
     */
    classes?: HvSingleCalendarClasses;
    /**
     * Callback function to be triggered when the selected date input has changed.
     */
    onInputChange?: (event: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement | HTMLButtonElement> | undefined, value: Date | DateRangeProp, position?: "left" | "right") => void;
    /**
     * Indicates if header should display end date in a date range.
     */
    showEndDate?: boolean;
    /**
     * Content on the upper part of the calendar.
     */
    children?: React.ReactNode;
}

export { HvSize }

/**
 * The `HvSkeleton` component is used to create a placeholder element that represents the shape and size of the content that will be loaded.
 */
export declare const HvSkeleton: (props: HvSkeletonProps) => JSX_2.Element;

export declare type HvSkeletonClasses = ExtractNames<typeof useClasses_132>;

export declare interface HvSkeletonProps extends HvBaseProps {
    /** Whether the skeleton element is hidden or not. */
    hidden?: boolean;
    /** The type of skeleton element. @default "text" */
    variant?: "circle" | "square" | "text";
    /** The animation the skeleton element will display. @default "pulse" */
    animation?: "pulse" | "wave";
    /** The width of the skeleton element. */
    width?: React.CSSProperties["width"];
    /** The height of the skeleton element. */
    height?: React.CSSProperties["height"];
    /** The url for a placeholder image to use on the skeleton element. */
    backgroundImage?: string;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSkeletonClasses;
}

/**
 * Sliders reflect a range of values along a bar, from which users may select a single value. They are ideal for adjusting settings such as volume, brightness, or applying image filters.
 */
export declare const HvSlider: ForwardRefExoticComponent<HvSliderProps & RefAttributes<SliderRef>>;

export declare type HvSliderClasses = ExtractNames<typeof useClasses_104>;

export declare interface HvSliderProps extends HvBaseProps<HTMLDivElement, "onChange" | "onBlur"> {
    /** The slider name. */
    name?: string;
    /** The label of the slider. If not provided, an aria-label or aria-labelledby must be inputted via sliderProps. */
    label?: React.ReactNode;
    /** Indicates that the slider is disabled. */
    disabled?: boolean;
    /** Indicates that the slider is not editable. */
    readOnly?: boolean;
    /** Indicates that user slider is required on the form element. */
    required?: boolean;
    /** Error message to render when the value is required. */
    requiredMessage?: string;
    /** If `true` the input that controls the slider is hidden. */
    hideInput?: boolean;
    /** Attributes applied to the slider element. */
    sliderProps?: SliderProps;
    /**
     * The status of the slider element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus | HvFormStatus[];
    /** The error message to show when `status` is "invalid". */
    statusMessage?: React.ReactNode;
    /** The values array to apply to the component */
    values?: number[];
    /** The default values array to apply to the component */
    defaultValues?: (number | undefined)[];
    /**
     * The object used to set the knob properties,
     * for every item in the array a new knob will be created.
     */
    knobProperties?: HvKnobProperty[];
    /** The object used to set the mark properties individually. */
    markProperties?: HvMarkProperty[];
    /**
     * The function executed before a change will occur in the slider.
     * @deprecated It's always better to use onChange instead
     */
    onBeforeChange?: (value: number[]) => void;
    /** The function executed while a change is occurring in the slider. */
    onChange?: (value: number[]) => void;
    /**
     * The function executed after a change ocurred in the slider.
     * @deprecated It's always better to use onChange instead
     */
    onAfterChange?: (value: number[]) => void;
    /** The function executed after a blur ocurred in the slider. */
    onBlur?: (event: React.FocusEvent, knobsValues: number[], status?: HvFormStatus | HvFormStatus[]) => void;
    /**
     * The separation in points between marks.
     * example: if 10 divisions and a markstep of 2 there will be 5 marks.
     */
    markStep?: number;
    /** How many subdivisions there are in the slider. */
    divisionQuantity?: number;
    /** The value of the first point in the slider from left to right. */
    minPointValue?: number;
    /** The value of the last point in the slider from left to right. */
    maxPointValue?: number;
    /** Error message to render when the value is higher than maxPointValue or lower than minPointValue. */
    outOfRangeMessage?: string;
    /** The max number of decimals if no format function is applied */
    markDigits?: number;
    /**
     * A formatting function used to add format to the marks in the track,
     * the function receives the mark text
     */
    formatMark?: (label: React.ReactNode) => React.ReactNode;
    /**
     * A formatting function used to add format to the tooltip in the track,
     * the function receives the mark text
     */
    formatTooltip?: (label: React.ReactNode) => React.ReactNode;
    /** If `true` the knobs can't have the same value, if `false` knobs can have the same value. */
    noOverlap?: boolean;
    /** Attributes applied to the input element. */
    inputProps?: HvInputProps[];
    /** Attributes applied to the knob element. */
    knobProps?: React.HTMLAttributes<HTMLDivElement>[];
    /** The classes object to be applied into the root object. */
    classes?: HvSliderClasses;
}

/**
 * A Snackbar provides brief messages about app processes.
 * It is dismissed automatically after a given interval.
 *
 * Snackbar can be built with two different components:
 * - `HvSnackbar`, which wraps all the positioning, transition, auto hide, etc.
 * - `HvSnackbarContent`, which allows a finer control and customization of the content of the Snackbar.
 */
export declare const HvSnackbar: ForwardRefExoticComponent<Omit<HvSnackbarProps, "ref"> & RefAttributes<unknown>>;

export declare type HvSnackbarClasses = ExtractNames<typeof useClasses_105>;

export declare const HvSnackbarContent: ForwardRefExoticComponent<Omit<HvSnackbarContentProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvSnackbarContentClasses = ExtractNames<typeof useClasses_106>;

export declare interface HvSnackbarContentProps extends Omit<SnackbarContentProps, "variant" | "action" | "classes"> {
    /** The message to display. */
    label?: React.ReactNode;
    /** Variant of the snackbar. */
    variant?: HvSnackbarVariant;
    /** Controls if the associated icon to the variant should be shown. */
    showIcon?: boolean;
    /** Custom icon to replace the variant default. */
    customIcon?: React.ReactNode;
    /** Action to display. */
    action?: React.ReactNode | HvActionGeneric;
    /**
     * The callback function called when an action is triggered, receiving `action` as parameter.
     *
     * @deprecated Use `onAction` instead.
     * */
    actionCallback?: HvActionsGenericProps["actionsCallback"];
    /** The callback function called when an action is triggered, receiving `action` as parameter. */
    onAction?: HvActionsGenericProps["onAction"];
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSnackbarContentClasses;
}

export declare interface HvSnackbarProps extends Omit<SnackbarProps, "action" | "classes" | "children"> {
    /** If true, Snackbar is open. */
    open?: boolean;
    /**
     * Callback fired when the component requests to be closed.
     * Typically onClose is used to set state in the parent component, which is used to control the Snackbar open prop.
     * The reason parameter can optionally be used to control the response to onClose, for example ignoring click away.
     * */
    onClose?: (event: Event | React.SyntheticEvent<any, Event>, reason: SnackbarCloseReason) => void;
    /** The message to display. */
    label?: React.ReactNode;
    /**
     * The anchor of the Snackbar. vertical: "top", "bottom" | horizontal: "left", "center", "right".
     * It defines where the snackbar will end his animation */
    anchorOrigin?: SnackbarOrigin;
    /** The number of milliseconds to wait before automatically calling the onClose function. onClose should then set the state of the open prop to hide the Snackbar */
    autoHideDuration?: number;
    /** Variant of the snackbar. */
    variant?: HvSnackbarVariant;
    /** Custom icon to replace the variant default. */
    customIcon?: React.ReactNode;
    /** Controls if the associated icon to the variant should be shown. */
    showIcon?: boolean;
    /** Action to display. */
    action?: React.ReactNode | HvActionGeneric;
    /**
     * The callback function called when an action is triggered, receiving `action` as parameter.
     *
     * @deprecated Use `onAction` instead.
     * */
    actionCallback?: HvActionsGenericProps["actionsCallback"];
    /** The callback function called when an action is triggered, receiving `action` as parameter. */
    onAction?: HvActionsGenericProps["onAction"];
    /** Duration of transition in milliseconds. */
    transitionDuration?: number;
    /** Direction of slide transition. */
    transitionDirection?: "up" | "down" | "left" | "right";
    /** The container the snackbar should slide from. */
    container?: SlideProps["container"];
    /** Custom offset from top/bottom of the page, in px. */
    offset?: number;
    /** Others applied to the content of the snackbar. */
    snackbarContentProps?: HvSnackbarContentProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSnackbarClasses;
    /** @ignore */
    ref?: SnackbarProps["ref"];
}

/**
 * A snackbar provider to control the stacking of multiple snackbars in the app.
 *
 * This component uses of the [Notistack](https://github.com/iamhosseindhv/notistack) library.
 * Please refer to its [API Reference](https://notistack.com/v2.x/api-reference) for more complex usage scenarios.
 */
export declare const HvSnackbarProvider: ({ children, notistackClassesOverride, maxSnack, autoHideDuration, anchorOrigin, classes: classesProp, className, container, ...others }: HvSnackbarProviderProps) => JSX_2.Element;

export declare type HvSnackbarProviderClasses = ExtractNames<typeof useClasses_107>;

export declare interface HvSnackbarProviderProps {
    /** Your component tree. */
    children: React.ReactNode;
    /** Max visible snackbars. */
    maxSnack?: number;
    /** How much time the snackbar remains visible in milliseconds. */
    autoHideDuration?: number;
    /** Where is the snackbar placed. */
    anchorOrigin?: SnackbarOrigin;
    /** Class object used to override notistack classes. */
    notistackClassesOverride?: SnackbarProviderProps["classes"];
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSnackbarProviderClasses;
    /** Class names to be applied. */
    className?: string;
    /** The container the snackbar should slide from. */
    container?: SnackbarProviderProps["domRoot"];
}

export declare type HvSnackbarVariant = "default" | "success" | "warning" | "error";

/**
 * A Stack component allows the organization of its children in a vertical or horizontal layout.
 *
 * It also allows the specification of the spacing between the stack elements and the addition of a divider between the elements.
 */
export declare const HvStack: (props: HvStackProps) => JSX_2.Element;

export declare interface HvStackBreakpoints extends Record<HvBreakpoints, string> {
}

export declare type HvStackClasses = ExtractNames<typeof useClasses_108>;

export declare type HvStackDirection = "column" | "row" | Partial<HvStackBreakpoints>;

export declare interface HvStackProps extends HvBaseProps {
    /** The direction of the stack. Can be either a string or an object that states the direction for each breakpoint. */
    direction?: HvStackDirection;
    /** The spacing between elements of the stack. */
    spacing?: HvBreakpoints;
    /** The divider component to be used between the stack elements.
     * - If `true` the Material-UI Divider component will be used.
     * - If a React node is passed then the custom divider will be used.
     */
    divider?: boolean | React.ReactNode;
    /** The properties to pass on to the Material-UI component. */
    dividerProps?: DividerProps;
    /** Sets whether or not there should be arrow navigation between the stack elements. */
    withNavigation?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvStackClasses;
}

export declare const hvStringFallback: (value: any) => string;

export declare interface HvSuggestion {
    id?: string;
    label: React.ReactNode;
    value?: string;
    disabled?: boolean;
}

export declare const HvSuggestions: ForwardRefExoticComponent<HvSuggestionsProps & RefAttributes<unknown>>;

export declare type HvSuggestionsClasses = ExtractNames<typeof useClasses_17>;

export declare interface HvSuggestionsProps extends HvBaseProps {
    /** Whether suggestions is visible */
    open?: boolean;
    /**
     * Whether suggestions is visible.
     * @deprecated use `open` instead.
     * */
    expanded?: boolean;
    /** The HTML element Suggestions attaches to. */
    anchorEl?: HTMLElement | null;
    /** Array of { id, label, ...others } values to display in the suggestion list */
    suggestionValues?: HvSuggestion[] | null;
    /** Function called when a suggestion is selected */
    onSuggestionSelected?: (event: React.MouseEvent, value: HvSuggestion) => void;
    /** Function called when suggestion list is closed */
    onClose?: ClickAwayListenerProps["onClickAway"];
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSuggestionsClasses;
    /**
     * If enabled, the suggestions list will be rendered using a portal.
     * If disabled, it will be under the DOM hierarchy of the parent component.
     * @default false
     * */
    enablePortal?: boolean;
    /** Props passed to the underlying MUI Popper component */
    popperProps?: Partial<PopperProps>;
}

export { HvSupportColor }

export declare type HvSupportColorKeys = HvSupportColor;

export declare type HvSupportColors = Record<HvSupportColorKeys, string>;

/**
 * A Switch is **binary** and works as a digital on/off button.
 *
 * Use when two states are **opposite** and to trigger immediate changes in the system.
 */
export declare const HvSwitch: ForwardRefExoticComponent<Omit<HvSwitchProps, "ref"> & RefAttributes<HTMLButtonElement>>;

export declare type HvSwitchClasses = ExtractNames<typeof useClasses_109>;

export declare function hvSwitchColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, switchLabel: string, falseLabel?: string, trueLabel?: string, switchProps?: HvBaseSwitchProps): HvTableColumnConfig<D, H>;

export declare const HvSwitchColumnCell: ({ checked, value, switchLabel, falseLabel, trueLabel, switchProps, }: HvSwitchColumnCellProp) => JSX.Element;

export declare interface HvSwitchColumnCellProp {
    /** Whether the switch is checked or not. */
    checked: boolean;
    /** The switch label. */
    value: number | string | undefined;
    /** The value of the switch. */
    switchLabel: string;
    /** The right switch label. */
    falseLabel?: string;
    /** The left switch label. */
    trueLabel?: string;
    /** Extra props to be passed to the switch. */
    switchProps?: HvBaseSwitchProps;
}

export declare interface HvSwitchProps extends Omit<SwitchProps, "color" | "onChange" | "classes"> {
    /**
     * A Jss Object used to override or extend the styles applied to the switch.
     */
    classes?: HvSwitchClasses;
    /**
     * The form element name.
     */
    name?: string;
    /**
     * The value of the form element.
     *
     * Is up to the application's logic when to consider the submission of this value.
     * Generally it should be used only when the switch is neither unchecked nor indeterminate.
     *
     * The default value is "on".
     */
    value?: any;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be inputted via inputProps.
     */
    label?: React.ReactNode;
    /**
     * Properties passed on to the label element.
     */
    labelProps?: HvLabelProps;
    /**
     * Indicates that the form element is disabled.
     */
    disabled?: boolean;
    /**
     * Indicates that the form element is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required on the form element.
     */
    required?: boolean;
    /**
     * If `true` the switch is selected, if set to `false` the switch is not selected.
     *
     * When defined the switch state becomes controlled.
     */
    checked?: boolean;
    /**
     * When uncontrolled, defines the initial checked state.
     */
    defaultChecked?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to `checked`, depending of the values of both `required` and `checked`.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when the validation status is "invalid".
     *
     * Defaults to "Required" when the status is uncontrolled and no `aria-errormessage` is provided.
     */
    statusMessage?: string;
    /**
     * Identifies the element that provides an error message for the switch.
     *
     * Will only be used when the validation status is invalid.
     */
    "aria-errormessage"?: string;
    /**
     * The callback fired when the switch is pressed.
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>, checked: boolean, value: any) => void;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
    /** @ignore */
    ref?: SwitchProps["ref"];
    /** @ignore */
    component?: SwitchProps["component"];
    /** Color applied to the switch. */
    color?: HvColorAny;
}

export declare const HvTab: ForwardRefExoticComponent<Omit<HvTabProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvTabClasses = ExtractNames<typeof useClasses_115>;

/**
 * A table gathers relational data. It displays values arranged to allow quick numerical analysis like comparison and sorting.
 *
 * The **HvTable** component offers a set of HTML-equivalent elements, **styled to Design System's specification**,
 * for building tables.
 * You can rely on these **elements** when your table doesn’t have many interactions or you need it to be very lightweight.
 *
 * For better data handling and **advanced features** we recommend the use of the utility hooks collection.
 * See the <a href="?id=guides-table-table-hooks--use-hv-hooks&viewMode=docs" target="_self">Table Hooks documentation</a> for more details.
 */
export declare const HvTable: ForwardRefExoticComponent<HvTableProps & RefAttributes<HTMLElement>>;

/**
 * HvTableBody acts as a `tbody` element.
 * `HvTableCell` and `HvTableRow` elements in it inherit body-specific styles
 */
export declare const HvTableBody: ForwardRefExoticComponent<HvTableBodyProps & RefAttributes<HTMLElement>>;

export declare type HvTableBodyClasses = ExtractNames<typeof useClasses_111>;

export declare interface HvTableBodyProps extends HvBaseProps<HTMLTableSectionElement, "children"> {
    /**
     * Content to be rendered
     */
    children: React.ReactNode;
    /**
     * The component used for the root node. Either a string to use a HTML element or a component.
     * Defaults to tbody.
     */
    component?: React.ElementType;
    /** Sets whether or not there should be arrow navigation between the table rows */
    withNavigation?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableBodyClasses;
}

export declare interface HvTAbleBulkActionsProps extends TableCommonProps {
    numTotal: number;
    numSelected: number;
    showSelectAllPages: boolean;
    onSelectAll: () => void;
    onSelectAllPages: () => void;
    labels?: Record<string, string>;
}

/**
 * `HvTableCell` acts as a `td` element and inherits styles from its context
 */
export declare const HvTableCell: ForwardRefExoticComponent<HvTableCellProps & RefAttributes<HTMLElement>>;

export declare type HvTableCellAlign = "center" | "inherit" | "justify" | "left" | "right";

export declare type HvTableCellClasses = ExtractNames<typeof useClasses_52>;

export declare interface HvTableCellProps extends Omit<React.TdHTMLAttributes<HTMLTableCellElement>, "align"> {
    /** The component used for the root node. Either a string to use a HTML element or a component. Defaults to td. */
    component?: React.ElementType;
    /** Content to be rendered */
    children?: React.ReactNode;
    /** Inline styles to be applied to the root element. */
    style?: React.CSSProperties;
    /** Set the text-align on the table cell content. */
    align?: HvTableCellAlign;
    /** Sets the cell's variant. */
    variant?: HvTableCellVariant | "listcheckbox" | "listactions";
    /** Specify the cell's type. The prop defaults to the value inherited from the parent TableHead, TableBody, or TableFooter components. */
    type?: HvTableCellType;
    /** Whether or not the cell is part of a sorted column. */
    sorted?: boolean;
    /** The cell is part of a sticky column. */
    stickyColumn?: boolean;
    /** The cell is part of the last sticky to the left column. */
    stickyColumnMostLeft?: boolean;
    /** The cell is part of the first sticky to the right column. */
    stickyColumnLeastRight?: boolean;
    /** The cell is part of the first column in the group. */
    groupColumnMostLeft?: boolean;
    /** The cell is part of the last column in the group. */
    groupColumnMostRight?: boolean;
    /** Whether or not the cell is resizable */
    resizable?: boolean;
    /** Whether or not the cell is being resized */
    resizing?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableCellClasses;
}

export declare type HvTableCellType = "body" | "footer" | "head";

export declare type HvTableCellVariant = "checkbox" | "expand" | "actions" | "default" | "none";

export declare type HvTableClasses = ExtractNames<typeof useClasses_55>;

export declare type HvTableColumnConfig<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvColumnGroup<D, H> | HvColumnWithLooseAccessor<D, H> | HvColumnWithStrictAccessor<D, H>;

export declare interface HvTableColumnOptions<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<ColumnInterface<D>, "Header" | "Footer">, Partial<UseFiltersColumnOptions<D>>, Partial<UseGroupByColumnOptions<D>>, Partial<UseResizeColumnsColumnOptions<D>>, Partial<UseSortByColumnOptions<D>>, Partial<UseGlobalFiltersColumnOptions<D>>, Partial<UseHvTableStylesColumnOptions> {
    Header?: H;
    Footer?: Renderer<HvFooterProps_2<D>>;
    originalId?: IdType<D>;
}

/**
 * HvTableContainer is a container for the HvTable
 */
export declare const HvTableContainer: ForwardRefExoticComponent<HvTableContainerProps & RefAttributes<HTMLElement>>;

export declare type HvTableContainerClasses = ExtractNames<typeof useClasses_110>;

export declare interface HvTableContainerProps extends HvBaseProps<HTMLDivElement, "children"> {
    /**
     * Content to be rendered
     */
    children: React.ReactNode;
    /**
     * The component used for the root node. Either a string to use a HTML element or a component.
     * Defaults to tbody.
     */
    component?: React.ElementType;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableContainerClasses;
}

export declare type HvTableDefinitionConfig<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvTableOptions<D, H>;

/**
 * HvTableHead acts as a `thead` element.
 * `HvTableCell` and `HvTableRow` elements in it inherit header-specific styles
 */
export declare const HvTableHead: ForwardRefExoticComponent<HvTableHeadProps & RefAttributes<HTMLElement>>;

export declare type HvTableHeadClasses = ExtractNames<typeof useClasses_112>;

/**
 * `HvTableHeader` acts as a `th` element and inherits styles from its context
 */
export declare const HvTableHeader: ForwardRefExoticComponent<HvTableHeaderProps & RefAttributes<HTMLElement>>;

export declare type HvTableHeaderClasses = ExtractNames<typeof useClasses_54>;

export declare interface HvTableHeaderProps extends Omit<React.ThHTMLAttributes<HTMLTableCellElement>, "align"> {
    /** The component used for the root node. Either a string to use a HTML element or a component. Defaults to th. */
    component?: React.ElementType;
    /** Content to be rendered */
    children?: React.ReactNode;
    /** The scope of cells that the header element relates to. */
    scope?: "col" | "row" | "colgroup" | "rowgroup";
    /** Set the text-align on the table cell content. */
    align?: HvTableCellAlign;
    /** Sets the cell's variant. */
    variant?: HvTableCellVariant;
    /** Specify the cell type. The prop defaults to the value inherited from the parent TableHead, TableBody, or TableFooter components. */
    type?: HvTableCellType;
    /** The cell is part of a sticky column. */
    stickyColumn?: boolean;
    /** The cell is part of the last sticky to the left column. */
    stickyColumnMostLeft?: boolean;
    /** The cell is part of the first sticky to the right column. */
    stickyColumnLeastRight?: boolean;
    /** The cell is part of the first column in the group. */
    groupColumnMostLeft?: boolean;
    /** The cell is part of the last column in the group. */
    groupColumnMostRight?: boolean;
    /** Whether or not the cell is sorted */
    sorted?: boolean;
    /** Whether or not the cell is sortable */
    sortable?: boolean;
    /** Set sort direction icon and aria-sort. */
    sortDirection?: "ascending" | "descending" | false;
    /** Extra props to be passed onto the text in the header. */
    headerTextProps?: HvTypographyProps;
    /** Whether or not the cell is resizable */
    resizable?: boolean;
    /** Whether or not the cell is being resized */
    resizing?: boolean;
    /** The resize props injected in the resize handler */
    resizerProps?: React.HTMLAttributes<HTMLDivElement>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableHeaderClasses;
    /** Extra props to be passed onto the sort button in the header. */
    sortButtonProps?: HvButtonProps;
}

export declare type HvTableHeaderRenderer<D extends object = Record<string, unknown>> = Renderer<HvHeaderProps_2<D>>;

export declare type HvTableHeadPropGetter<D extends object> = PropGetter<D, UseHvTableStickyTableHeadProps>;

export declare interface HvTableHeadProps extends HvBaseProps<HTMLTableSectionElement, "children"> {
    /**
     * Content to be rendered
     */
    children: React.ReactNode;
    /**
     * The component used for the root node. Either a string to use a HTML element or a component.
     * Defaults to thead.
     */
    component?: React.ElementType;
    /**
     * The table has sticky headers.
     */
    stickyHeader?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableHeadClasses;
}

export declare interface HvTableInstance<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<TableInstance<D>, "pageCount" | "data" | "columns" | "rows" | "allColumns" | "visibleColumns" | "headers" | "flatHeaders" | "rowsById" | "prepareRow" | "flatRows" | "headerGroups" | "footerGroups" | "defaultColumn" | "stateReducer" | "useControlledState" | "getRowId" | "getHooks" | "getTableProps">, Omit<HvTableOptions<D, H>, "pageCount" | "columns">, Partial<UseColumnOrderInstanceProps<D>>, Partial<Omit<UseExpandedInstanceProps<D>, "rows">>, Partial<Omit<UseFiltersInstanceProps<D>, "rows" | "rowsById" | "flatRows">>, Partial<Omit<UseGlobalFiltersInstanceProps<D>, "rows" | "rowsById" | "flatRows">>, Partial<Omit<UseGroupByInstanceProps<D>, "rows" | "rowsById" | "flatRows">>, Partial<Omit<UsePaginationInstanceProps<D>, "page">>, Partial<Omit<UseSortByInstanceProps<D>, "rows">>, Partial<UseRowStateInstanceProps<D>>, Partial<Omit<UseHvRowSelectionTableInstance<D>, "selectedFlatRows">>, Partial<UseHvTableStickyTableInstance<D>>, Partial<UseHvHeaderGroupsInstance>, Partial<UseHvPaginationTableInstance<D>>, Partial<UseHvBulkActionsTableInstanceProps<D>> {
    initialState: Partial<HvTableState<D>>;
    state: HvTableState<D>;
    columns: Array<HvColumnInstance<D, H>>;
    allColumns: Array<HvColumnInstance<D, H>>;
    visibleColumns: Array<HvColumnInstance<D, H>>;
    headers: Array<HvColumnInstance<D, H>>;
    flatHeaders: Array<HvColumnInstance<D, H>>;
    rows: Array<HvRowInstance<D, H>>;
    page: Array<HvRowInstance<D, H>>;
    rowsById: Record<string, HvRowInstance<D, H>>;
    flatRows: Array<HvRowInstance<D, H>>;
    getHooks: () => HvHooks<D>;
    getTableProps: (propGetter?: HvTablePropGetter<D, H>) => HvUseTableProps;
    prepareRow: (row: HvRowInstance<D, H>) => void;
    selectedFlatRows: Array<HvRowInstance<D, H>>;
    initialRows: Array<HvRowInstance<D, H>>;
    initialRowsById: Record<string, HvRowInstance<D, H>>;
    labels: Record<string, string>;
    headerGroups: Array<HvHeaderGroup<D, H>>;
    footerGroups: Array<HvHeaderGroup<D, H>>;
}

export declare interface HvTableOptions<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<TableOptions<D>, "columns" | "data" | "defaultColumn" | "stateReducer" | "useControlledState" | "getRowId">, Partial<UseExpandedOptions<D>>, Partial<UseFiltersOptions<D>>, Partial<UseGlobalFiltersOptions<D>>, Partial<UseGroupByOptions<D>>, Partial<UsePaginationOptions<D>>, Partial<UseResizeColumnsOptions<D>>, Partial<UseSortByOptions<D>>, Partial<UseRowStateOptions<D>>, Partial<UseHvTableStylesTableOptions>, Partial<UseHvRowSelectionTableOptions>, Partial<UseHvTableStickyTableOptions>, Partial<UseHvBulkActionsTableOptions>, Partial<UseHvRowExpandTableOptions> {
    columns?: Array<HvTableColumnConfig<D, H>>;
    data?: D[];
    initialState?: Partial<HvTableState<D>>;
    labels?: Record<string, string>;
    defaultColumn?: Partial<HvTableColumnConfig<D, H>>;
    stateReducer?: (newState: HvTableState<D>, action: ActionType, previousState: HvTableState<D>, instance?: HvTableInstance<D, H>) => HvTableState<D>;
    useControlledState?: (state: HvTableState<D>, meta: HvMeta<D, H>) => HvTableState<D>;
    getRowId?: (originalRow: D, relativeIndex: number, parent?: HvRowInstance<D, H>) => string;
}

export declare interface HvTablePaginationProps extends TableCommonProps {
    canPrevious: boolean;
    canNext: boolean;
    pages: number;
    page: number;
    pageSize: number;
    onPageChange?: (updater: ((pageIndex: number) => number) | number) => void;
    onPageSizeChange?: (pageSize: number) => void;
    labels?: Record<string, string>;
}

export { HvTablePluginHook }

declare type HvTablePropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvPropGetter<D, H, HvUseTableProps>;

export declare interface HvTableProps extends React.TableHTMLAttributes<HTMLTableElement> {
    /**
     * The component used for the root node. Either a string to use a HTML element or a component.
     * Defaults to `table`.
     *
     * When using non-table elements, layout is up to the developer using the component.
     */
    component?: React.ElementType;
    /** Content to be rendered */
    children: React.ReactNode;
    /** Whether the `HvTable` has a sticky header row. */
    stickyHeader?: boolean;
    /** Whether the `HvTable` has sticky columns. */
    stickyColumns?: boolean;
    /** Whether the `HvTable` has the list row styles or the default. */
    variant?: HvTableVariant;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableClasses;
}

/**
 * `HvTableRow` acts as a `tr` element and inherits styles from its context
 */
export declare const HvTableRow: ForwardRefExoticComponent<HvTableRowProps & RefAttributes<HTMLElement>>;

export declare type HvTableRowClasses = ExtractNames<typeof useClasses_53>;

export declare interface HvTableRowProps extends HvBaseProps<HTMLTableRowElement, "children"> {
    /** Content to be rendered */
    children: React.ReactNode;
    /** The component used for the root node. Either a string to use a HTML element or a component. Defaults to tbody. */
    component?: React.ElementType;
    /** Whether the table row will shade on hover. */
    hover?: boolean;
    /** Whether the table row will have the selected shading. */
    selected?: boolean;
    /** Whether the table row is expanded. */
    expanded?: boolean;
    /** Whether the table row background is striped. */
    striped?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableRowClasses;
}

/**
 * The `TableSection` component is a wrapper for the `Section` component that applies
 * specific stylings for tables that follow the latest DS specifications.
 */
export declare const HvTableSection: ForwardRefExoticComponent<HvTableSectionProps & RefAttributes<HTMLDivElement>>;

export declare type HvTableSectionClasses = ExtractNames<typeof useClasses_131>;

export declare interface HvTableSectionProps extends HvSectionProps {
}

export declare interface HvTableState<D extends object = Record<string, unknown>> extends TableState<D>, Partial<UseColumnOrderState<D>>, Partial<UseExpandedState<D>>, Partial<UseFiltersState<D>>, Partial<UseGlobalFiltersState<D>>, Partial<UseGroupByState<D>>, Partial<UsePaginationState<D>>, Partial<UseResizeColumnsState<D>>, Partial<UseSortByState<D>>, Partial<UseRowStateState<D>>, Partial<UseHvRowSelectionState<D>> {
    rowCount: number;
}

export declare type HvTableVariant = "listrow" | "default";

export declare interface HvTabProps extends Omit<TabProps, "children"> {
    /** If `true`, the tab will be disabled. */
    disabled?: boolean;
    /** The icon element. */
    icon?: React.ReactElement | string;
    /** The label element. */
    label?: React.ReactNode;
    /** The position of the icon relative to the label. */
    iconPosition?: "bottom" | "end" | "start" | "top";
    /** A Jss Object used to override or extend the component styles. */
    classes?: HvTabClasses;
}

/**
 * A Tab is a graphical control element that allows multiple documents or panels to be contained within a single window.
 * Tabs can be used as a navigational widget for switching between sets of documents.
 */
export declare const HvTabs: ForwardRefExoticComponent<Omit<HvTabsProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvTabsClasses = ExtractNames<typeof useClasses_114>;

export declare interface HvTabsProps extends Omit<TabsProps, "onChange"> {
    /**
     * The value of the currently selected Tab. If you don't want any selected Tab, you can set this property to `false`.
     */
    value?: any;
    /**
     * Callback fired when the value changes.
     */
    onChange?: (event: React.SyntheticEvent, value: any) => void;
    /**
     * A Jss Object used to override or extend the component styles.
     */
    classes?: HvTabsClasses;
    /** @ignore */
    ref?: TabsProps["ref"];
    /** @ignore */
    component?: TabsProps["component"];
    floating?: boolean;
}

/**
 * A Tag is one word that describes a specific aspect of an asset. A single asset can have
 * multiple tags.
 * Use tags to highlight an item's status for quick recognition and navigation
 * Use color to indicate meanings that users can learn and recognize across products.
 */
export declare const HvTag: ForwardRefExoticComponent<Omit<HvTagProps, "ref"> & RefAttributes<HTMLElement>>;

export declare type HvTagClasses = ExtractNames<typeof useClasses_113>;

export declare function hvTagColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, A extends object = Record<string, unknown>>(col: HvTableColumnConfig<D, H>, valueDataKey: keyof A, colorDataKey: keyof A, textColorDataKey: keyof A, fromRowData?: boolean, tagProps?: HvTagProps): HvTableColumnConfig<D, H>;

export declare interface HvTagProps extends Omit<HvButtonBaseProps, "type" | "color" | "classes" | "onClick" | "onToggle"> {
    /** The label of the tag element. */
    label?: React.ReactNode;
    /** Indicates that the form element is disabled. */
    disabled?: boolean;
    /** The type of the tag element. A tag can be of semantic or categoric type. */
    type?: "semantic" | "categorical";
    /** The color variant of the tag */
    color?: HvColorAny;
    /** Icon used to customize the delete icon */
    deleteIcon?: React.ReactElement;
    /**
     * The callback fired when the delete icon is pressed.
     * This function has to be provided to the component, in order to render the delete icon
     * */
    onDelete?: React.EventHandler<any>;
    /** Callback triggered when any item is clicked. */
    onClick?: (event: React.MouseEvent<HTMLElement>, selected?: boolean) => void;
    /** Aria properties to apply to delete button in tag
     * @deprecated no longer used
     */
    deleteButtonArialLabel?: string;
    /** Props to apply to delete icon */
    deleteButtonProps?: React.HTMLAttributes<HTMLDivElement>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTagClasses;
    /** Determines whether or not the tag is selectable. */
    selectable?: boolean;
    /** Defines if the tag is selected. When defined the tag state becomes controlled. */
    selected?: boolean;
    /** When uncontrolled, defines the initial selected state. */
    defaultSelected?: boolean;
}

/**
 * A tags input is a single or multiline control that allows the input of tags.
 */
export declare const HvTagsInput: ForwardRefExoticComponent<HvTagsInputProps & RefAttributes<HTMLElement>>;

export declare type HvTagsInputClasses = ExtractNames<typeof useClasses_116>;

export declare interface HvTagsInputProps extends Omit<HvInputProps, "onChange" | "onBlur" | "onFocus" | "onKeyDown" | "value" | "defaultValue"> {
    /** The value of the form element. */
    value?: string[] | HvTagProps[];
    /** When uncontrolled, defines the initial input value. */
    defaultValue?: string[] | HvTagProps[];
    /** The function that will be executed onChange. */
    onChange?: (event: React.SyntheticEvent, value: HvTagProps[]) => void;
    /** The function that will be executed when the element is focused. */
    onFocus?: (event: React.FocusEvent<HTMLDivElement>, value: string) => void;
    /** The function that will be executed when the element is blurred. */
    onBlur?: (event: React.FocusEvent<HTMLDivElement>, value: string) => void;
    /** The function that will be executed when a tag is deleted. */
    onDelete?: (event: React.SyntheticEvent, value: HvTagProps, index: number) => void;
    /** The function that will be executed when a tag is added. */
    onAdd?: (event: React.SyntheticEvent, value: HvTagProps, index: number) => void;
    /** If `true` the character counter isn't shown even if maxTagsQuantity is set. */
    hideCounter?: boolean;
    /** Text between the current char counter and max value. */
    middleCountLabel?: string;
    /** The maximum allowed length of the characters, if this value is null no check will be performed. */
    maxTagsQuantity?: number;
    /** If `true` the component is resizable. */
    resizable?: boolean;
    /** Props passed to the HvCharCount component. */
    countCharProps?: Partial<HvCharCounterProps>;
    /** If `true` the component is in multiline mode. */
    multiline?: boolean;
    /** An array of strings that represent the character used to input a tag. This character is the string representation of the event.code from the input event. */
    commitTagOn?: string[];
    /** If `true` the tag will be committed when the blur event occurs. */
    commitOnBlur?: boolean;
    /** The function that will be executed to received an array of objects that has a label and id to create list of suggestions. */
    suggestionListCallback?: (value: string) => HvTagSuggestion[] | null;
    /** The validation function that will be executed when adding tags in the suggestions mode. */
    suggestionValidation?: (value: string) => boolean;
    /** When in suggestions mode, this property indicates that tags that are not present on the suggestions list can also be added. */
    suggestionsLoose?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTagsInputClasses;
}

export declare interface HvTagSuggestion extends HvInputSuggestion {
}

/**
 * A text area is a multiline text input box, with an optional character counter when there is a length limit.
 */
export declare const HvTextArea: ForwardRefExoticComponent<HvTextAreaProps & RefAttributes<HTMLTextAreaElement>>;

export declare type HvTextAreaClasses = ExtractNames<typeof useClasses_117>;

export declare interface HvTextAreaProps extends Omit<HvBaseInputProps, "onChange" | "onBlur" | "rows" | "classes" | "onFocus" | "placeholder"> {
    /** The placeholder value of the text area. */
    placeholder?: string;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /**
     * Provide additional descriptive text for the form element.
     */
    description?: React.ReactNode;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when `status` is "invalid".
     */
    statusMessage?: React.ReactNode;
    /**
     * Text between the current char counter and max value.
     */
    middleCountLabel?: string;
    /**
     * An Object containing the various texts associated with the input.
     */
    validationMessages?: HvValidationMessages;
    /**
     * The custom validation function, it receives the value and must return
     * either `true` for valid or `false` for invalid, default validations would only
     * occur if this function is null or undefined
     */
    validation?: (value: string) => boolean;
    /**
     * The maximum allowed length of the characters, if this value is null no check
     * will be performed.
     */
    maxCharQuantity?: number;
    /**
     * The minimum allowed length of the characters, if this value is null no check
     * will be perform.
     */
    minCharQuantity?: number;
    /**
     * If `true` it should autofocus.
     */
    autoFocus?: boolean;
    /**
     * The number of rows of the text area
     */
    rows?: number;
    /**
     * If `true` the component is resizable.
     */
    resizable?: boolean;
    /**
     * Auto-scroll: automatically scroll to the end on value changes.
     * Will stop if the user scrolls up and resume if scrolled to the bottom.
     */
    autoScroll?: boolean;
    /**
     * If true it isn't possible to pass the `maxCharQuantity`
     */
    blockMax?: boolean;
    /**
     * If `true` the character counter isn't shown even if maxCharQuantity is set.
     */
    hideCounter?: boolean;
    /**
     * Props passed to the char count.
     */
    countCharProps?: Partial<HvCharCounterProps>;
    /**
     * Called back when the value is changed.
     */
    onChange?: (event: React.ChangeEvent<HTMLTextAreaElement>, value: string) => void;
    /**
     * Called back when the value is changed.
     */
    onBlur?: (event: React.FocusEvent<HTMLTextAreaElement>, value: string, validationState: HvInputValidity) => void;
    /**
     * The function that will be executed onBlur, allows checking the value state,
     * it receives the value.
     */
    onFocus?: (event: React.FocusEvent<HTMLTextAreaElement>, value: string) => void;
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvTextAreaClasses;
}

export declare function hvTextColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, overflowTooltipProps?: Omit<HvOverflowTooltipProps, "data">): HvTableColumnConfig<D, H>;

export { HvTheme }

export { HvThemeBreakpoint }

export { HvThemeColorMode }

export { HvThemeContext }

export { HvThemeContextValue }

export declare type HvThemeCustomizationProps = HvExtraDeepPartialProps<Omit<HvThemeStructure, "colors" | "name" | "base">> & {
    colors?: {
        modes?: {
            [key: string]: Partial<HvThemeColorModeStructure> & {
                [key: string]: string;
            };
        };
    };
};

export declare interface HvThemePalette {
    accent: HvAccentColors;
    atmosphere: HvAtmosphereColors;
    base: HvBaseColors;
    semantic: HvSemanticColors;
    support: HvSupportColors;
}

export declare const HvThemeProvider: ({ children, themes: themesList, theme: themeProp, emotionCache, colorMode: colorModeProp, themeRootId: rootId, }: HvThemeProviderProps) => JSX_2.Element;

declare interface HvThemeProviderProps {
    children: React.ReactNode;
    themes: (HvTheme | HvThemeStructure)[];
    theme: string;
    emotionCache: EmotionCache;
    colorMode: string;
    themeRootId?: string;
}

/**
 * The HvTimeAgo component implements the Design System relative time format guidelines.
 */
export declare const HvTimeAgo: <C extends React.ElementType = "p">(props: {
    /**
     * The timestamp to format, in seconds or milliseconds.
     * Defaults to `emptyElement` if value is null or 0
     */
    timestamp?: number;
    /**
     * The locale to be used. Should be on of the JS supported locales
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument
     */
    locale?: Intl.LocalesArgument;
    /**
     * The element to render when the timestamp is null or 0
     * Defaults to `—` (Em Dash)
     */
    emptyElement?: React.ReactNode;
    /** Disables periodic date refreshes */
    disableRefresh?: boolean;
    /** Whether to show seconds in the rendered time */
    showSeconds?: boolean;
    /**
     * Whether the component should render just the string
     * Consider using `useTimeAgo` instead
     */
    justText?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: Partial<{
        root: string;
    }>;
} & {
    component?: C | undefined;
} & {
    children?: ReactNode | undefined;
} & (Omit<PropsWithoutRef<ComponentProps<C>>, "classes" | "component" | "locale" | "emptyElement" | "showSeconds" | "timestamp" | "disableRefresh" | "justText"> extends infer T ? T extends Omit<PropsWithoutRef<ComponentProps<C>>, "classes" | "component" | "locale" | "emptyElement" | "showSeconds" | "timestamp" | "disableRefresh" | "justText"> ? T extends any ? T : never : never : never) & {
    ref?: PolymorphicRef<C> | undefined;
} & RefAttributes<unknown>) => React.ReactElement | null;

export declare type HvTimeAgoClasses = ExtractNames<typeof useClasses_118>;

export declare type HvTimeAgoProps<C extends React.ElementType = "p"> = PolymorphicComponentRef<C, {
    /**
     * The timestamp to format, in seconds or milliseconds.
     * Defaults to `emptyElement` if value is null or 0
     */
    timestamp?: number;
    /**
     * The locale to be used. Should be on of the JS supported locales
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument
     */
    locale?: Intl.LocalesArgument;
    /**
     * The element to render when the timestamp is null or 0
     * Defaults to `—` (Em Dash)
     */
    emptyElement?: React.ReactNode;
    /** Disables periodic date refreshes */
    disableRefresh?: boolean;
    /** Whether to show seconds in the rendered time */
    showSeconds?: boolean;
    /**
     * Whether the component should render just the string
     * Consider using `useTimeAgo` instead
     */
    justText?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTimeAgoClasses;
}>;

/**
 * A Time Picker allows the user to choose a specific time or a time range.
 */
export declare const HvTimePicker: ForwardRefExoticComponent<HvTimePickerProps & RefAttributes<HTMLDivElement>>;

export declare type HvTimePickerClasses = ExtractNames<typeof useClasses_119>;

export declare type HvTimePickerClassKey = "root" | "input" | "label" | "placeholder" | "timePopperContainer" | "separator" | "periodContainer" | "formElementRoot" | "dropdownPlaceholder" | "iconBaseRoot" | "error" | "labelContainer" | "description" | "dropdownHeaderInvalid" | "dropdownPlaceholderDisabled" | "dropdownHeaderOpen";

export declare interface HvTimePickerProps extends Omit<HvFormElementProps, "classes" | "value" | "defaultValue" | "onChange"> {
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTimePickerClasses;
    /** Current value of the element when _controlled_. Follows the 24-hour format. */
    value?: HvTimePickerValue | null;
    /** Initial value of the element when _uncontrolled_. Follows the 24-hour format. */
    defaultValue?: HvTimePickerValue | null;
    /** The placeholder value when no time is selected. */
    placeholder?: string;
    /** The placeholder of the hours input. */
    hoursPlaceholder?: string;
    /** The placeholder of the minutes input. */
    minutesPlaceholder?: string;
    /** The placeholder of the seconds input. */
    secondsPlaceholder?: string;
    /**
     * Whether the time picker should show the AM/PM 12-hour clock or the 24-hour one.
     * If undefined, the component will use a format according to the passed locale.
     */
    timeFormat?: TimeFormat;
    /** Whether to visually show the seconds control */
    showSeconds?: boolean;
    /** Locale that will provide the time format(12 or 24 hour format). It is "overwritten" by `showAmPm` */
    locale?: string;
    /** Whether the dropdown is expandable. */
    disableExpand?: boolean;
    /**
     * Callback function to be triggered when the input value is changed.
     * It is invoked with a `{hours, minutes, seconds}` object, always in the 24h format
     */
    onChange?: (value: HvTimePickerValue) => void;
    /** Callback called when dropdown changes the expanded state. */
    onToggle?: (event: Event, isOpen: boolean) => void;
    /** Disable the portal behavior. The children stay within it's parent DOM hierarchy. */
    disablePortal?: boolean;
    /** Sets if the calendar container should follow the date picker input out of the screen or stay visible. */
    escapeWithReference?: boolean;
    /** Extra properties to be passed to the TimePicker's dropdown. */
    dropdownProps?: Partial<HvBaseDropdownProps>;
}

export declare type HvTimePickerValue = {
    hours: number;
    minutes: number;
    seconds: number;
};

/**
 * Use when two instances are opposite and the on/off analogy doesn’t apply. Only well-known icons should be used, otherwise, use a single checkbox for the same situation.
 */
export declare const HvToggleButton: ForwardRefExoticComponent<HvToggleButtonProps & RefAttributes<HTMLButtonElement>>;

export declare interface HvToggleButtonProps extends HvBaseProps<HTMLButtonElement, "onClick"> {
    /** When uncontrolled, defines the initial selected state. */
    defaultSelected?: boolean;
    /** Defines if the button is selected. When defined the button state becomes controlled. */
    selected?: boolean;
    /** Defines if the button is disabled. */
    disabled?: boolean;
    /** Icon for when not selected. Ignored if the component has children. */
    notSelectedIcon?: React.ReactNode;
    /** Icon for when selected. Ignored if the component has children. */
    selectedIcon?: React.ReactNode;
    /** Function called when icon is clicked. */
    onClick?: (event: React.MouseEvent<HTMLButtonElement>, selected: boolean) => void;
}

/**
 * Tooltips display informative text when users hover over, focus on, or tap an element.
 * Accessibility-wise, the tooltip automatically labels the `children` content.
 *
 * If you are looking to wrap an icon only button with a tooltip, take a look at the `HvIconButton` component
 * which offers you thus behavior out of the box.
 */
export declare const HvTooltip: ForwardRefExoticComponent<Omit<HvTooltipProps, "ref"> & RefAttributes<unknown>>;

export declare type HvTooltipClasses = ExtractNames<typeof useClasses_93>;

export declare type HvTooltipPlacementType = TooltipProps["placement"];

export declare interface HvTooltipProps extends Omit<TooltipProps, "classes"> {
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied.
     */
    classes?: HvTooltipClasses;
    /**
     * If true, the tooltip is shown.
     */
    open?: boolean;
    /**
     * Tooltip placement.
     */
    placement?: HvTooltipPlacementType;
    /**
     * The number of milliseconds to wait before showing the tooltip.
     * This property won't impact the enter touch delay (enterTouchDelay).
     */
    enterDelay?: number;
    /** @inheritdoc */
    title: TooltipProps["title"];
    /** @inheritdoc */
    TransitionComponent?: TooltipProps["TransitionComponent"];
    /** @inheritdoc */
    TransitionProps?: TooltipProps["TransitionProps"];
    /**
     * Defines if should use a single or multiline tooltip.
     * @deprecated tooltips already support multiline and can be styled accordingly.
     */
    useSingle?: boolean;
    /**
     * Node to apply the tooltip.
     */
    children: React.ReactElement;
    /**
     * Id attribute value of an HTML Element to have the tooltip appended to it.
     */
    containerId?: string;
}

declare type HvTreeContentClasses = ExtractNames<typeof useClasses_122>;

export declare interface HvTreeContentProps extends React.HTMLAttributes<HTMLElement> {
    /** className applied to the root element. */
    className?: string;
    /** Override or extend the styles applied to the component. */
    classes?: HvTreeContentClasses;
    /** The tree node label. */
    label?: React.ReactNode;
    /** The id of the node. */
    nodeId: string;
    /** The icon to display next to the tree node's label. */
    icon?: React.ReactNode;
    /** The icon to display next to the tree node's label. Either an expansion or collapse icon. */
    expansionIcon?: React.ReactNode;
    /** The icon to display next to the tree node's label. Either a parent or end icon. */
    displayIcon?: React.ReactNode;
}

export declare const HvTreeItem: ForwardRefExoticComponent<HvTreeItemProps & RefAttributes<HTMLLIElement>>;

export declare type HvTreeItemClasses = ExtractNames<typeof useClasses_121>;

export declare interface HvTreeItemProps extends React.HTMLAttributes<HTMLElement> {
    /** The element id */
    id?: string;
    /** The id of the node. */
    nodeId: string;
    /** The tree node label. */
    label?: React.ReactNode;
    /** Override or extend the styles applied to the component. */
    classes?: HvTreeItemClasses;
    /** If `true`, the node is disabled. */
    disabled?: boolean;
    /** The icon to display next to the tree node's label. */
    icon?: React.ReactNode;
    /** The component used for the content node. */
    ContentComponent?: React.JSXElementConstructor<HvTreeContentProps>;
    /** Props applied to the content component */
    ContentProps?: HvTreeContentProps;
    /** The content of the component. */
    children?: React.ReactNode;
    /** className applied to the root element. */
    className?: string;
    /** The icon used to collapse the node. */
    collapseIcon?: React.ReactNode;
    /** The icon displayed next to an end node. */
    endIcon?: React.ReactNode;
    /** The icon used to expand the node. */
    expandIcon?: React.ReactNode;
    /** The component used for the transition. */
    TransitionComponent?: React.JSXElementConstructor<TransitionProps>;
    /** Props applied to the transition component */
    TransitionProps?: TransitionProps;
    /** Whether to disable the following default behavior: when the item is focused, the focus is placed on the tree root. @default `false` */
    disableTreeFocus?: boolean;
}

/**
 * A Tree View displays hierarchical structures.
 * It also facilitates the exploration of categorical levels and their content.
 *
 * Tree structures are built through composing the `HvTreeItem` component,
 * or a custom variation of it.
 *
 * It is based on the [MUI X TreeView](https://mui.com/x/react-tree-view) component.
 *
 * @example
 * ```tsx
 * <HvTreeView>
 *   <HvTreeItem nodeId="1" label="File1" />
 * </HvTreeView>
 * ```
 */
export declare const HvTreeView: <Multiple extends boolean | undefined>(props: HvTreeViewProps<Multiple> & RefAttributes<HTMLUListElement>) => React.ReactElement | null;

export declare type HvTreeViewClasses = ExtractNames<typeof useClasses_120>;

export declare interface HvTreeViewProps<Multiple extends boolean | undefined> extends HvBaseProps<HTMLUListElement>, DefaultTreeViewPluginParameters<Multiple> {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvTreeViewClasses;
    /** Tree View children. Usually a `HvTreeItem` instance, or a custom variation of it */
    children?: React.ReactNode;
}

/**
 * Typography component is used to render text and paragraphs within an interface.
 */
export declare const HvTypography: <C extends React.ElementType = "p">(props: {
    /** Use the variant prop to change the visual style of the Typography. */
    variant?: HvTypographyVariants | HvTypographyLegacyVariants;
    /** If `true` the typography will display the look of a link. */
    link?: boolean;
    /** If `true` the typography will display the look of a disabled state. */
    disabled?: boolean;
    /**
     * If `true`, the typography will render a "p" element
     * @deprecated use `component="p"` instead
     * */
    paragraph?: boolean;
    /**
     * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
     *
     * Note that text overflow can only happen with block or inline-block level elements
     * (the element needs to have a width in order to overflow).
     */
    noWrap?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: Partial<{
        root: string;
        disabled: string;
        isLink: string;
        noWrap: string;
        display: string;
        title1: string;
        title2: string;
        title3: string;
        title4: string;
        body: string;
        label: string;
        captionLabel: string;
        caption1: string;
        caption2: string;
        "5xlTitle": string;
        "4xlTitle": string;
        "3xlTitle": string;
        xxlTitle: string;
        xlTitle: string;
        lTitle: string;
        mTitle: string;
        sTitle: string;
        xsTitle: string;
        xxsTitle: string;
        sectionTitle: string;
        highlightText: string;
        normalText: string;
        placeholderText: string;
        link: string;
        disabledText: string;
        selectedNavText: string;
        vizText: string;
        vizTextDisabled: string;
        xsInlineLink: string;
    }>;
} & {
    component?: C | undefined;
} & {
    children?: ReactNode | undefined;
} & (Omit<PropsWithoutRef<ComponentProps<C>>, "link" | "classes" | "disabled" | "variant" | "component" | "noWrap" | "paragraph"> extends infer T ? T extends Omit<PropsWithoutRef<ComponentProps<C>>, "link" | "classes" | "disabled" | "variant" | "component" | "noWrap" | "paragraph"> ? T extends any ? T : never : never : never) & {
    ref?: PolymorphicRef<C> | undefined;
} & RefAttributes<unknown>) => React.ReactElement | null;

export declare type HvTypographyClasses = ExtractNames<typeof useClasses>;

/** @deprecated */
export declare type HvTypographyLegacyVariants = "5xlTitle" | "4xlTitle" | "3xlTitle" | "xxlTitle" | "xlTitle" | "lTitle" | "mTitle" | "sTitle" | "xsTitle" | "xxsTitle" | "sectionTitle" | "highlightText" | "normalText" | "placeholderText" | "link" | "disabledText" | "selectedNavText" | "vizText" | "vizTextDisabled" | "xsInlineLink";

export declare type HvTypographyProps<C extends React.ElementType = "p"> = PolymorphicComponentRef<C, {
    /** Use the variant prop to change the visual style of the Typography. */
    variant?: HvTypographyVariants | HvTypographyLegacyVariants;
    /** If `true` the typography will display the look of a link. */
    link?: boolean;
    /** If `true` the typography will display the look of a disabled state. */
    disabled?: boolean;
    /**
     * If `true`, the typography will render a "p" element
     * @deprecated use `component="p"` instead
     * */
    paragraph?: boolean;
    /**
     * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
     *
     * Note that text overflow can only happen with block or inline-block level elements
     * (the element needs to have a width in order to overflow).
     */
    noWrap?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTypographyClasses;
}>;

export declare type HvTypographyVariants = (typeof typographyVariants)[number];

export declare type HvUndefinedStateColorKeys = "atmo4";

export declare interface HvUseTableCellProps extends Omit<TableCellProps, "role">, Omit<UseHvTableStylesTableCellProps, "variant" | "classes">, UseHvTableStickyCellProps, UseHvHeaderGroupsCellProps, UseHvResizeTableCellProps, UseHvSortByTableCellProps, HvTableCellProps {
}

export declare interface HvUseTableFooterProps extends TableFooterProps, UseHvTableStylesTableCellProps {
}

export declare interface HvUseTableHeaderProps extends Omit<TableHeaderProps, "role">, Omit<UseHvTableStylesTableCellProps, "classes">, UseHvTableStickyColumnProps, UseHvHeaderGroupsColumnProps, UseHvResizeColumnProps, Omit<UseHvSortByColumnProps, "sortDirection">, HvTableHeaderProps {
}

export declare interface HvUseTableProps extends Omit<TableProps, "role">, UseHvTableStickyTableProps, HvTableProps {
}

export declare interface HvUseTableRowProps extends Omit<TableRowProps, "role">, UseHvTableStylesTableRowProps, UseHvRowSelectionTableRowProps, UseHvRowExpandTableRowProps, HvTableRowProps {
}

export declare interface HvValidationMessages {
    /** The value when a validation fails. */
    error?: string;
    /** The message that appears when there are too many characters. */
    maxCharError?: string;
    /** The message that appears when there are too few characters. */
    minCharError?: string;
    /** The message that appears when the input is empty and required. */
    requiredError?: string;
    /** The message that appears when the input is value is incompatible with the expected type. */
    typeMismatchError?: string;
}

/**
 * Navigation enables users to move through an app to complete tasks.
 *
 * It is recommended to use vertical navigation when your application requires global navigation that is displayed on the left.
 * While vertical navigation menus generally consume more space than their horizontal counterparts, they have become more popular as desktop monitors move to wide-screen formats.
 *
 * Although both the hierarchically organized data and the visual style resemble a treeview-like structure, the [Treeview Design Pattern](https://w3c.github.io/aria-practices/#TreeView)
 * isn't necessarily the most appropriate.
 *
 * The tree role provides complex functionality that is not needed for typical site navigation, and changes the most common keyboard navigation using TAB.
 *
 * The [Disclosure Design Pattern](https://w3c.github.io/aria-practices/#disclosure) is more suited for typical site navigation, with expandable groups of links.
 * However it can be tedious to TAB through all navigation items to reach the actions panel.
 *
 * Both modes are available via the `mode` property and each app should choose the most appropriate.
 */
export declare const HvVerticalNavigation: ForwardRefExoticComponent<HvVerticalNavigationProps & RefAttributes<HTMLDivElement>>;

export declare const HvVerticalNavigationAction: (props: HvVerticalNavigationActionProps) => JSX_2.Element;

export declare type HvVerticalNavigationActionClasses = ExtractNames<typeof useClasses_126>;

export declare interface HvVerticalNavigationActionProps extends Omit<HvButtonProps, "classes" | "icon"> {
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvVerticalNavigationActionClasses;
    /** Visual label. */
    label?: string;
    /** Icon. */
    icon?: React.ReactNode;
}

export declare const HvVerticalNavigationActions: (props: HvVerticalNavigationActionsProps) => JSX_2.Element;

export declare type HvVerticalNavigationActionsClasses = ExtractNames<typeof useClasses_125>;

export declare interface HvVerticalNavigationActionsProps extends HvBaseProps {
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvVerticalNavigationActionsClasses;
}

export declare type HvVerticalNavigationClasses = ExtractNames<typeof useClasses_123>;

export declare const HvVerticalNavigationHeader: (props: HvVerticalNavigationHeaderProps) => JSX_2.Element | null;

export declare type HvVerticalNavigationHeaderClasses = ExtractNames<typeof useClasses_124>;

export declare interface HvVerticalNavigationHeaderProps extends HvBaseProps {
    /** The title text to show on header. */
    title?: string;
    /** Icon to show when vertical navigation is collapsed. */
    openIcon?: React.ReactNode;
    /** Icon to show when vertical navigation is expanded. */
    closeIcon?: React.ReactNode;
    /** Props for the collapse button. */
    collapseButtonProps?: HvButtonProps;
    /** Props for the back button. */
    backButtonProps?: HvButtonProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvVerticalNavigationHeaderClasses;
    /** Handler for the collapse button. */
    onCollapseButtonClick?: React.MouseEventHandler<HTMLElement>;
}

export declare type HvVerticalNavigationMode = "icon" | "simple";

export declare type HvVerticalNavigationPosition = "static" | "relative" | "fixed" | "absolute";

export declare interface HvVerticalNavigationProps extends HvBaseProps<HTMLDivElement> {
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvVerticalNavigationClasses;
    /** Current State of the Vertical Navigation Collapse */
    open?: boolean;
    /**
     * Collapsed Mode for the Vertical Navigation, the default value is "simple".
     *
     * @deprecated - `useIcons` property should be used instead.
     */
    collapsedMode?: HvVerticalNavigationMode;
    /** Boolean to determine if treeview is in slider mode (for mobile navigation), the default value is false. */
    slider?: boolean;
    /**
     * Boolean to determine if icons should be displayed in the navigation menu.
     * When `true` a icon will always be displayed, if no icon is provided the first letter of the label will be
     * displayed inside an Avatar component.
     * When `false` no icons will be shown, even if an icon is provided.
     */
    useIcons?: boolean;
}

export declare const HvVerticalNavigationSlider: (props: HvVerticalNavigationSliderProps) => JSX_2.Element;

export declare type HvVerticalNavigationSliderClasses = ExtractNames<typeof useClasses_128>;

export declare interface HvVerticalNavigationSliderProps extends Omit<HvListContainerProps, "classes"> {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvVerticalNavigationSliderClasses;
    /**
     * An array containing the data for each menu item.
     *
     * id - the id to be applied to the root element.
     * label - the label to be rendered on the menu item.
     * icon - the icon react element
     * data - sub-menu items
     * href - the url used for navigation.
     * target - the behavior when opening an url.
     */
    data?: NavigationData[];
    /** The selected item id. */
    selected?: string;
    /** Triggered when the item is clicked. */
    onNavigateToTarget?: (event: React.MouseEvent<HTMLLIElement>, item: NavigationData) => void;
    /** Triggered when the navigate to child button is clicked. */
    onNavigateToChild?: (event: React.MouseEvent<HTMLButtonElement>, item: NavigationData) => void;
    /** Aria label to apply to the navigate to submenu button on the list items. */
    forwardButtonAriaLabel?: string;
}

export declare const HvVerticalNavigationTree: (props: HvVerticalNavigationTreeProps) => JSX_2.Element;

export declare type HvVerticalNavigationTreeClasses = ExtractNames<typeof useClasses_127>;

export declare interface HvVerticalNavigationTreeProps extends HvBaseProps<HTMLDivElement, "onChange" | "onToggle"> {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvVerticalNavigationTreeClasses;
    /** Modus operandi (role) of the widget instance. */
    mode?: NavigationMode;
    /** Can non-leaf nodes be collapsed / expanded. */
    collapsible?: boolean;
    /** The ID of the selected page. */
    selected?: string;
    /** When uncontrolled, defines the initial selected page ID. */
    defaultSelected?: string;
    /** Callback fired when a navigation item is selected. */
    onChange?: (event: React.MouseEvent<HTMLLIElement> | React.KeyboardEvent<HTMLUListElement>, page: NavigationData) => void;
    /** Expanded nodes' ids. */
    expanded?: string[];
    /**
     * When uncontrolled, defines the initial expanded nodes' ids.
     *
     * It also supports `true` for starting with all nodes expanded.
     * With `false` all nodes will be collapsed.
     *
     * By default it expands the needed nodes to display the current selection, if any.
     */
    defaultExpanded?: string[] | boolean;
    /** Callback fired when tree items are expanded/collapsed. */
    onToggle?: (event: React.KeyboardEvent<HTMLUListElement>, nodeIds: string[]) => void;
    /**
     * An array containing the data for each menu item.
     *
     * id - the id to be applied to the root element.
     * label - the label to be rendered on the menu item.
     * data - sub-menu items
     * href - the url used for navigation.
     * target - the behavior when opening an url.
     */
    data?: NavigationData[];
    /** Aria label to apply to the navigate to submenu button on the navigation slider list items. */
    sliderForwardButtonAriaLabel?: string;
}

export declare const HvVerticalNavigationTreeView: ForwardRefExoticComponent<HvVerticalNavigationTreeViewProps & RefAttributes<HTMLUListElement>>;

export declare type HvVerticalNavigationTreeViewClasses = ExtractNames<typeof useClasses_129>;

export declare const HvVerticalNavigationTreeViewItem: ForwardRefExoticComponent<HvVerticalNavigationTreeViewItemProps & RefAttributes<unknown>>;

export declare type HvVerticalNavigationTreeViewItemClasses = ExtractNames<typeof useClasses_130>;

export declare interface HvVerticalNavigationTreeViewItemProps {
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the Radio button.
     */
    classes?: HvVerticalNavigationTreeViewItemClasses;
    /**
     * Is the node disabled.
     */
    disabled?: boolean;
    /**
     * Can the node be selected.
     */
    selectable?: boolean;
    /**
     * The id of the node.
     */
    nodeId?: string;
    /**
     * The icon to display next to the node's label.
     */
    icon?: React.ReactNode;
    /**
     * The item label.
     */
    label?: React.ReactNode;
    /**
     * The url for the link.
     */
    href?: string;
    /**
     * The behavior when opening a link.
     */
    target?: string;
    /**
     * The node payload.
     */
    payload?: any;
    /**
     * @ignore
     */
    onClick?: any;
    /**
     * @ignore
     */
    onMouseDown?: any;
    /**
     * @ignore
     */
    onFocus?: any;
    /**
     * The content of the component.
     */
    children?: React.ReactNode;
    /**
     * @ignore
     */
    onMouseEnter?: any;
    /**
     * Disables the appearence of a tooltip on hovering an element ( Only applicable when the in collapsed mode)
     */
    disableTooltip?: boolean;
}

export declare interface HvVerticalNavigationTreeViewProps extends HvBaseProps<HTMLUListElement, "onChange" | "onToggle"> {
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvVerticalNavigationTreeViewClasses;
    /** Modus operandi (role) of the widget instance. */
    mode?: NavigationMode;
    /** Enables selection. @default false */
    selectable?: boolean;
    /** Enables the simultaneous selection of multiple items. @default false */
    multiSelect?: boolean;
    /** The selected nodes' ids. When `multiSelect` is true this takes an array of strings; when false (default) a string. */
    selected?: string[] | string;
    /**
     * When uncontrolled, defines the initial selected nodes' ids.
     * When `multiSelect` is true this takes an array of strings; when false (default) a string.
     * @default []
     */
    defaultSelected?: string[] | string;
    /** Can non-leaf nodes be collapsed / expanded. */
    collapsible?: boolean;
    /** Callback fired when a tree item is selected. */
    onChange?: (event: React.KeyboardEvent<HTMLUListElement>, nodeId: string | string[], payloads: any) => void;
    /** Expanded nodes' ids. */
    expanded?: string[];
    /** When uncontrolled, defines the initial expanded nodes' ids. @default [] */
    defaultExpanded?: string[];
    /** Callback fired when tree items are expanded/collapsed. */
    onToggle?: (event: React.KeyboardEvent<HTMLUListElement>, nodeIds: string[]) => void;
    /** If `true`, will allow focus on disabled items. @default false */
    disabledItemsFocusable?: boolean;
}

export declare type HvVerticalScrollListItemClasses = ExtractNames<typeof useClasses_100>;

/**
 * Provides the user with a descriptive text, signaling an error, for when the form element is in an invalid state.
 */
export declare const HvWarningText: (props: HvWarningTextProps) => JSX_2.Element;

export declare type HvWarningTextClasses = ExtractNames<typeof useClasses_11>;

export declare interface HvWarningTextProps extends HvBaseProps {
    /** Icon to be rendered alongside the warning text. */
    adornment?: React.ReactNode;
    /** If `true` the text is not rendered. */
    isVisible?: boolean;
    /** If `true` the text is disabled. */
    disabled?: boolean;
    /** If `true` the text won't include a gutter. */
    disableGutter?: boolean;
    /** If `true` the text won't include the top border. */
    disableBorder?: boolean;
    /** If `true` the adornment icon isn't shown. */
    disableAdornment?: boolean;
    /** If `true` the text isn't shown. */
    hideText?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvWarningTextClasses;
}

export declare const iconVariant: (variant: "success" | "warning" | "error" | "info" | "default", color?: IconBaseProps["color"], semantic?: true) => JSX_2.Element | null;

declare type IdType<D> = StringKey<D> | string;

export declare const increaseSize: (size: string) => "S" | "M" | "L" | "XL";

export declare const infoMessageClasses: {
    root: string;
    infoDisabled: string;
    gutter: string;
};

export declare const inlineEditorClasses: {
    root: string;
    inputBorderContainer: string;
    input: string;
    inputRoot: string;
    text: string;
    largeText: string;
    textEmpty: string;
    button: string;
    icon: string;
    iconVisible: string;
};

export declare const inputClasses: {
    root: string;
    labelContainer: string;
    label: string;
    description: string;
    adornmentsBox: string;
    icon: string;
    adornmentButton: string;
    iconClear: string;
    hasSuggestions: string;
    suggestionsContainer: string;
    suggestionList: string;
    inputExtension: string;
    input: string;
    inputRoot: string;
    inputRootFocused: string;
    inputRootDisabled: string;
    inputRootMultiline: string;
    inputBorderContainer: string;
    error: string;
};

export declare const isBrowser: (browsers: string | string[]) => boolean | null;

export declare function isDeleteKey(event: React.KeyboardEvent): boolean;

/** Check whether a keyboard `event` is pressing the `keyCode` key. */
export declare const isKey: (event: any, keyCode: Key) => boolean;

export declare const isOneOfKeys: (event: any, keys: Key[]) => boolean;

declare type Key = keyof typeof keyboardCodes;

/** Map of keys to key `code` @see https://mdn.io/event/code */
declare const keyboardCodes: {
    readonly Backspace: "Backspace";
    readonly Tab: "Tab";
    readonly Enter: "Enter";
    readonly Shift: "ShiftLeft";
    readonly Ctrl: "ControlLeft";
    readonly Alt: "AltLeft";
    readonly Delete: "Delete";
    readonly Esc: "Escape";
    readonly ArrowLeft: "ArrowLeft";
    readonly ArrowUp: "ArrowUp";
    readonly ArrowRight: "ArrowRight";
    readonly ArrowDown: "ArrowDown";
    readonly Space: "Space";
    readonly PageUp: "PageUp";
    readonly PageDown: "PageDown";
    readonly Home: "Home";
    readonly End: "End";
};

export declare const kpiClasses: {
    root: string;
    visualIndicatorContainer: string;
    comparisons: string;
    comparisonContainer: string;
    comparisonComposition: string;
    indicatorsContainer: string;
    indicatorText: string;
    indicatorUnit: string;
    spacingToTheRight: string;
    trendLine: string;
};

export declare const labelClasses: {
    root: string;
    labelDisabled: string;
    childGutter: string;
};

export declare const leftControlClasses: {
    root: string;
};

export declare const linkClasses: {
    a: string;
};

export declare const listClasses: {
    root: string;
    virtualizedRoot: string;
    selectorRoot: string;
    selectorContainer: string;
    box: string;
    truncate: string;
    item: string;
    itemSelector: string;
    link: string;
    selectAllSelector: string;
};

export declare const listContainerClasses: {
    root: string;
};

export declare const listItemClasses: {
    root: string;
    focus: string;
    startAdornment: string;
    endAdornment: string;
    gutters: string;
    condensed: string;
    interactive: string;
    selected: string;
    disabled: string;
    withStartAdornment: string;
    withEndAdornment: string;
};

export declare const loadingClasses: {
    root: string;
    barContainer: string;
    loadingBar: string;
    label: string;
    overlay: string;
    blur: string;
    hidden: string;
    small: string;
    regular: string;
    smallColor: string;
    regularColor: string;
};

export declare const loadingContainerClasses: {
    root: string;
    loading: string;
};

export declare const loginClasses: {
    root: string;
    formContainer: string;
};

export declare const multiButtonClasses: {
    root: string;
    multiple: string;
    splitGroup: string;
    splitGroupDisabled: string;
    button: string;
    selected: string;
    vertical: string;
    firstButton: string;
    lastButton: string;
    primary: string;
    primarySubtle: string;
    primaryGhost: string;
    secondary: string;
    secondarySubtle: string;
    secondaryGhost: string;
};

export declare const multiSelectionEventHandler: (evt: any, index: number, selectionAnchor: any, allValues: any[], selectedState: boolean[], selectionCheck: any) => any[];

declare type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};

export declare type NavigationData<T extends React.ElementType = "a"> = React.ComponentProps<T> & Record<string, any> & {
    /** The id to be applied to the root element. */
    id: string;
    /** The label to be rendered on the menu item. */
    label: string;
    /** The icon to be rendered. */
    icon?: React.ReactNode;
    /** The Data children subset. */
    data?: NavigationData<T>[];
    /** Whether the item is disabled and not interactive. */
    disabled?: boolean;
    /** Whether the item has a selected state. */
    selectable?: boolean;
};

export declare type NavigationMode = "treeview" | "navigation" | "slider";

export declare const normalizeProgressBar: (value: number, max: number) => number;

export declare const optionClasses: {
    root: string;
    highlighted: string;
};

export declare const optionGroupClasses: {
    root: string;
};

export declare const outlineStyles: {
    boxShadow: string;
};

export declare const overflowTooltipClasses: {
    tooltipData: string;
    tooltipAnchor: string;
    tooltipAnchorParagraph: string;
};

export declare const paginationClasses: {
    root: string;
    pageSizeOptions: string;
    pageSizeHeader: string;
    pageSizeRoot: string;
    pageSizeTextContainer: string;
    totalPagesTextContainer: string;
    pageSizeOptionsSelect: string;
    pageNavigator: string;
    iconContainer: string;
    icon: string;
    pageInfo: string;
    pageJump: string;
    pageSizeInput: string;
    pageSizeInputRoot: string;
    pageSizeInputContainer: string;
};

export declare const panelClasses: {
    root: string;
};

export { pentahoPlus }

declare type PolymorphicComponent<C extends React.ElementType, Props = {}> = React.PropsWithChildren<Props & AsProp<C>> & FixComponentProps<Omit<React.ComponentPropsWithoutRef<C>, PropsToOmit<C, Props>>>;

export declare type PolymorphicComponentRef<C extends React.ElementType, Props = {}> = PolymorphicComponent<C, Props> & {
    ref?: PolymorphicRef<C>;
};

export declare type PolymorphicRef<C extends React.ElementType> = React.ComponentPropsWithRef<C>["ref"];

/**
 * Process the themes provided to the HvProvider:
 *  - Cleans themes with the same name
 *  - Returns the default if the list is empty (ds5)
 */
export declare const processThemes: (themesList?: (HvTheme | HvThemeStructure)[]) => (HvTheme | HvThemeStructure)[];

export declare const progressBarClasses: {
    root: string;
    progress: string;
    progressBar: string;
    progressBarLabel: string;
    progressContainer: string;
    progressDone: string;
    progressBarContainer: string;
    progressError: string;
};

declare type PropsToOmit<C extends React.ElementType, P> = keyof (AsProp<C> & P);

declare type Query = QueryGroup;

declare type QueryAction = {
    type: "reset-query";
} | {
    type: "reset-group";
    id: React.Key;
} | {
    type: "add-rule" | "add-group" | "remove-node";
    id: React.Key;
} | {
    type: "set-combinator";
    id: React.Key;
    combinator: string;
} | {
    type: "set-attribute";
    id: React.Key;
    attribute?: string | null;
    operator?: string | null;
    value?: HvQueryBuilderQueryRuleValue | null;
} | {
    type: "set-operator";
    id: React.Key;
    operator: string | null;
    value?: HvQueryBuilderQueryRuleValue | null;
} | {
    type: "set-value";
    id: React.Key;
    value: HvQueryBuilderQueryRuleValue | null | any;
} | {
    type: "set-query";
    query: Query;
};

export declare const queryBuilderClasses: {
    root: string;
    topGroup: string;
    subGroup: string;
    combinator: string;
    topCombinator: string;
    combinatorButton: string;
    removeButton: string;
    topRemoveButton: string;
    topRemoveButtonDisabled: string;
    rulesContainer: string;
    subRulesContainer: string;
    actionButtonContainer: string;
    topActionButtonContainer: string;
    topRulesContainer: string;
    buttonBackground: string;
    createConditionButton: string;
    createGroupButton: string;
};

declare interface QueryGroup {
    id: React.Key;
    combinator: string;
    rules: Array<QueryRule | QueryGroup>;
}

declare interface QueryRule {
    id: React.Key;
    attribute?: string;
    operator?: string;
    value?: HvQueryBuilderQueryRuleValue;
}

export declare const radioClasses: {
    root: string;
    container: string;
    invalidContainer: string;
    disabled: string;
    radio: string;
    invalidRadio: string;
    label: string;
    focusVisible: string;
    checked: string;
    semantic: string;
};

export declare const radioGroupClasses: {
    root: string;
    label: string;
    group: string;
    vertical: string;
    horizontal: string;
    invalid: string;
    error: string;
};

export declare class Random {
    i: number;
    max: number;
    min: number;
    constructor(seed?: number, max?: number, min?: number);
    next(max?: number, min?: number): number;
}

export declare const rightControlClasses: {
    root: string;
    sortDropdown: string;
};

export declare const scrollToHorizontalClasses: {
    root: string;
    positionSticky: string;
    positionFixed: string;
    notSelectedRoot: string;
    notSelected: string;
    selected: string;
};

export declare const scrollToVerticalClasses: {
    root: string;
    positionAbsolute: string;
    positionFixed: string;
};

export declare const sectionClasses: {
    root: string;
    hidden: string;
    header: string;
    content: string;
    hasHeader: string;
    spaceTop: string;
    actions: string;
    raisedHeader: string;
};

export declare const selectClasses: {
    root: string;
    disabled: string;
    readOnly: string;
    invalid: string;
    labelContainer: string;
    label: string;
    description: string;
    select: string;
    popper: string;
    panel: string;
    panelOpenedUp: string;
    panelOpenedDown: string;
    error: string;
};

export declare const selectionListClasses: {
    root: string;
    error: string;
    listbox: string;
    label: string;
    description: string;
    horizontal: string;
    vertical: string;
    invalid: string;
};

/**
 * Sets the element attributes and style for a theme and color mode.
 */
export declare const setElementAttrs: (themeName: string, modeName: string, colorScheme: string, themeRootId?: string) => void;

export declare const setId: (...args: any[]) => string | undefined;

/** @deprecated use `useUniqueId` instead */
export declare const setUid: (id: string, suffix: string) => string | undefined;

export declare const simpleGridClasses: {
    root: string;
};

export declare const skeletonClasses: {
    root: string;
    content: string;
    circle: string;
    square: string;
    text: string;
    pulse: string;
    wave: string;
};

export declare const sliderClasses: {
    sliderBase: string;
    rootDisabled: string;
    sliderContainer: string;
    error: string;
    trackDragging: string;
    trackStandBy: string;
    sliderRoot: string;
    rootRange: string;
    handleContainer: string;
    handle: string;
    handleContainerDisabled: string;
    handleHiddenContainer: string;
    labelContainer: string;
    labelIncluded: string;
    onlyInput: string;
    label: string;
    root: string;
    sliderTooltip: string;
};

export declare const snackbarClasses: {
    root: string;
    anchorOriginTopRight: string;
    anchorOriginTopLeft: string;
    anchorOriginTopCenter: string;
    anchorOriginBottomCenter: string;
    anchorOriginBottomLeft: string;
    anchorOriginBottomRight: string;
};

export declare const snackbarContentClasses: {
    root: string;
    success: string;
    error: string;
    default: string;
    warning: string;
    message: string;
    messageSpan: string;
    messageText: string;
    action: string;
    iconVariant: string;
};

export declare const snackbarProviderClasses: {
    snackItemRoot: string;
};

export declare type Spacing = HvBreakpoints;

export declare const stackClasses: {
    root: string;
    column: string;
    row: string;
    divider: string;
    xs: string;
    sm: string;
    md: string;
    lg: string;
    xl: string;
};

declare type StringKey<D> = Extract<keyof D, string>;

export declare const suggestionsClasses: {
    root: string;
    list: string;
    popper: string;
    portal: string;
};

export declare const switchClasses: {
    root: string;
    label: string;
    error: string;
    switchContainer: string;
    invalidSwitch: string;
};

export declare const tabClasses: {
    root: string;
    focusVisible: string;
    selected: string;
    disabled: string;
};

export declare const tableBodyClasses: {
    root: string;
};

export declare const tableCellClasses: {
    root: string;
    head: string;
    body: string;
    footer: string;
    sorted: string;
    alignLeft: string;
    alignCenter: string;
    alignRight: string;
    alignJustify: string;
    variantNone: string;
    variantCheckbox: string;
    variantActions: string;
    variantExpand: string;
    variantList: string;
    variantListHead: string;
    variantListactions: string;
    variantListcheckbox: string;
    stickyColumn: string;
    stickyColumnMostLeft: string;
    stickyColumnLeastRight: string;
    groupColumnMostLeft: string;
    groupColumnMostRight: string;
    resizable: string;
    resizing: string;
};

export declare const tableClasses: {
    root: string;
    stickyHeader: string;
    stickyColumns: string;
    listRow: string;
};

export declare const tableContainerClasses: {
    root: string;
};

export declare const tableHeadClasses: {
    root: string;
    stickyHeader: string;
};

export declare const tableHeaderClasses: {
    root: string;
    head: string;
    body: string;
    footer: string;
    stickyColumn: string;
    stickyColumnMostLeft: string;
    stickyColumnLeastRight: string;
    groupColumnMostLeft: string;
    groupColumnMostRight: string;
    headerContent: string;
    headerText: string;
    headerParagraph: string;
    sortableHeaderText: string;
    sorted: string;
    sortable: string;
    sortButton: string;
    sortIcon: string;
    alignLeft: string;
    alignRight: string;
    alignCenter: string;
    alignJustify: string;
    alignFlexLeft: string;
    alignFlexRight: string;
    alignFlexCenter: string;
    alignFlexJustify: string;
    variantCheckbox: string;
    variantExpand: string;
    variantActions: string;
    variantNone: string;
    variantList: string;
    resizable: string;
    resizing: string;
    resizer: string;
};

export declare const tableRowClasses: {
    root: string;
    head: string;
    body: string;
    footer: string;
    selected: string;
    expanded: string;
    striped: string;
    hover: string;
    variantList: string;
    variantListHead: string;
};

export declare const tableSectionClasses: {
    root: string;
    header: string;
    actions: string;
    content: string;
    hidden: string;
    raisedHeader: string;
    hasHeader: string;
    spaceTop: string;
};

export declare const tabsClasses: {
    root: string;
    indicator: string;
    scroller: string;
    flexContainer: string;
    floating: string;
};

export declare const tagClasses: {
    root: string;
    categorical: string;
    disabled: string;
    label: string;
    deleteIcon: string;
    selected: string;
    clickable: string;
    icon: string;
    chipRoot: string;
    button: string;
    tagButton: string;
    focusVisible: string;
    disabledDeleteIcon: string;
    categoricalFocus: string;
    categoricalDisabled: string;
};

export declare const tagsInputClasses: {
    listItemGutters: string;
    listItemRoot: string;
    root: string;
    chipRoot: string;
    disabled: string;
    readOnly: string;
    resizable: string;
    invalid: string;
    labelContainer: string;
    label: string;
    description: string;
    characterCounter: string;
    tagsList: string;
    tagInputContainerRoot: string;
    tagInputRoot: string;
    input: string;
    tagSelected: string;
    tagInputBorderContainer: string;
    tagInputRootFocused: string;
    tagInputRootEmpty: string;
    singleLine: string;
    error: string;
    inputExtension: string;
    suggestionsContainer: string;
    suggestionList: string;
};

export declare const textAreaClasses: {
    root: string;
    disabled: string;
    resizable: string;
    invalid: string;
    baseInput: string;
    input: string;
    inputResizable: string;
    labelContainer: string;
    label: string;
    description: string;
    characterCounter: string;
    error: string;
};

export { theme }

export { themes }

export declare const timeAgoClasses: {
    root: string;
};

export declare type TimeFormat = "12" | "24";

export declare const timePickerClasses: {
    root: string;
    labelContainer: string;
    label: string;
    description: string;
    placeholder: string;
    placeholderDisabled: string;
    dropdownHeader: string;
    dropdownHeaderOpen: string;
    dropdownHeaderInvalid: string;
    dropdownPanel: string;
    icon: string;
    timePopperContainer: string;
    error: string;
};

export declare const tooltipClasses: {
    root: string;
    tooltip: string;
    popper: string;
    tooltipMulti: string;
    title: string;
    valuesContainer: string;
    values: string;
    color: string;
    separatorColor: string;
    separator: string;
    valueWrapper: string;
};

export declare const treeItemClasses: {
    root: string;
    group: string;
    content: string;
    expanded: string;
    selected: string;
    focused: string;
    disabled: string;
    label: string;
    iconContainer: string;
};

export declare const treeView2Classes: {
    root: string;
};

export declare const treeViewClasses: {
    root: string;
};

export declare const treeViewItemClasses: {
    node: string;
    content: string;
    link: string;
    group: string;
    disabled: string;
    expandable: string;
    collapsed: string;
    expanded: string;
    selectable: string;
    unselectable: string;
    selected: string;
    unselected: string;
    focused: string;
    minimized: string;
    hide: string;
    label: string;
    labelIcon: string;
    labelExpandable: string;
    icon: string;
};

declare type TreeViewSelectionValue<Multiple extends boolean | undefined> = Multiple extends true ? string[] : string | null;

declare type TypeSuffix = "" | "Subtle" | "Ghost";

export declare const typographyClasses: {
    root: string;
    disabled: string;
    isLink: string;
    noWrap: string;
    display: string;
    title1: string;
    title2: string;
    title3: string;
    title4: string;
    body: string;
    label: string;
    captionLabel: string;
    caption1: string;
    caption2: string;
    "5xlTitle": string;
    "4xlTitle": string;
    "3xlTitle": string;
    xxlTitle: string;
    xlTitle: string;
    lTitle: string;
    mTitle: string;
    sTitle: string;
    xsTitle: string;
    xxsTitle: string;
    sectionTitle: string;
    highlightText: string;
    normalText: string;
    placeholderText: string;
    link: string;
    disabledText: string;
    selectedNavText: string;
    vizText: string;
    vizTextDisabled: string;
    xsInlineLink: string;
};

export declare const typographyVariants: readonly ["display", "title1", "title2", "title3", "title4", "body", "label", "captionLabel", "caption1", "caption2"];

export declare const uniqueId: (prefix?: string) => string;

export declare type UseBulkActionsProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

declare const useClasses: (classesProp?: Partial<Record<"display" | "title1" | "title2" | "title3" | "title4" | "label" | "body" | "captionLabel" | "caption1" | "caption2" | "5xlTitle" | "4xlTitle" | "xxlTitle" | "lTitle" | "sTitle" | "xxsTitle" | "sectionTitle" | "placeholderText" | "link" | "disabledText" | "selectedNavText" | "vizTextDisabled" | "xsInlineLink" | "root" | "disabled" | "isLink" | "noWrap" | "3xlTitle" | "xlTitle" | "mTitle" | "xsTitle" | "highlightText" | "normalText" | "vizText", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        disabled: string;
        isLink: string;
        noWrap: string;
        display: string;
        title1: string;
        title2: string;
        title3: string;
        title4: string;
        body: string;
        label: string;
        captionLabel: string;
        caption1: string;
        caption2: string;
        "5xlTitle": string;
        "4xlTitle": string;
        "3xlTitle": string;
        xxlTitle: string;
        xlTitle: string;
        lTitle: string;
        mTitle: string;
        sTitle: string;
        xsTitle: string;
        xxsTitle: string;
        sectionTitle: string;
        highlightText: string;
        normalText: string;
        placeholderText: string;
        link: string;
        disabledText: string;
        selectedNavText: string;
        vizText: string;
        vizTextDisabled: string;
        xsInlineLink: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_10: (classesProp?: Partial<Record<"root" | "gutter" | "infoDisabled", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        infoDisabled: string;
        gutter: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_100: (classesProp?: Partial<Record<"root" | "icon" | "button" | "text" | "notSelected", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        icon: string;
        notSelected: string;
        text: string;
        button: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_101: (classesProp?: Partial<Record<"root" | "positionFixed" | "positionAbsolute", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        positionAbsolute: string;
        positionFixed: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_102: (classesProp?: Partial<Record<"content" | "header" | "root" | "hidden" | "actions" | "hasHeader" | "spaceTop" | "raisedHeader", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        hidden: string;
        header: string;
        content: string;
        hasHeader: string;
        spaceTop: string;
        actions: string;
        raisedHeader: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_103: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_104: (classesProp?: Partial<Record<"label" | "root" | "trackDragging" | "trackStandBy" | "handleContainer" | "error" | "labelContainer" | "rootDisabled" | "sliderBase" | "sliderContainer" | "sliderRoot" | "rootRange" | "handle" | "handleContainerDisabled" | "handleHiddenContainer" | "labelIncluded" | "onlyInput" | "sliderTooltip", string>>, addStatic?: boolean) => {
    readonly classes: {
        sliderBase: string;
        rootDisabled: string;
        sliderContainer: string;
        error: string;
        trackDragging: string;
        trackStandBy: string;
        sliderRoot: string;
        rootRange: string;
        handleContainer: string;
        handle: string;
        handleContainerDisabled: string;
        handleHiddenContainer: string;
        labelContainer: string;
        labelIncluded: string;
        onlyInput: string;
        label: string;
        root: string;
        sliderTooltip: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_105: (classesProp?: Partial<Record<"root" | "anchorOriginTopCenter" | "anchorOriginBottomCenter" | "anchorOriginTopRight" | "anchorOriginBottomRight" | "anchorOriginTopLeft" | "anchorOriginBottomLeft", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        anchorOriginTopRight: string;
        anchorOriginTopLeft: string;
        anchorOriginTopCenter: string;
        anchorOriginBottomCenter: string;
        anchorOriginBottomLeft: string;
        anchorOriginBottomRight: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_106: (classesProp?: Partial<Record<"warning" | "root" | "action" | "default" | "success" | "error" | "message" | "messageSpan" | "messageText" | "iconVariant", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        success: string;
        error: string;
        default: string;
        warning: string;
        message: string;
        messageSpan: string;
        messageText: string;
        action: string;
        iconVariant: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_107: (classesProp?: Partial<Record<"snackItemRoot", string>>, addStatic?: boolean) => {
    readonly classes: {
        snackItemRoot: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_108: (classesProp?: Partial<Record<"xs" | "sm" | "md" | "lg" | "xl" | "root" | "divider" | "row" | "column", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        column: string;
        row: string;
        divider: string;
        xs: string;
        sm: string;
        md: string;
        lg: string;
        xl: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_109: (classesProp?: Partial<Record<"label" | "root" | "invalidSwitch" | "error" | "switchContainer", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        label: string;
        error: string;
        switchContainer: string;
        invalidSwitch: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_11: (classesProp?: Partial<Record<"root" | "warningText" | "topGutter" | "defaultIcon" | "show" | "hideText" | "topBorder", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        defaultIcon: string;
        warningText: string;
        show: string;
        topGutter: string;
        hideText: string;
        topBorder: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_110: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_111: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_112: (classesProp?: Partial<Record<"root" | "stickyHeader", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        stickyHeader: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_113: (classesProp?: Partial<Record<"label" | "root" | "disabled" | "icon" | "selected" | "button" | "deleteIcon" | "focusVisible" | "categorical" | "clickable" | "chipRoot" | "tagButton" | "disabledDeleteIcon" | "categoricalFocus" | "categoricalDisabled", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        categorical: string;
        disabled: string;
        label: string;
        deleteIcon: string;
        selected: string;
        clickable: string;
        icon: string;
        chipRoot: string;
        button: string;
        tagButton: string;
        focusVisible: string;
        disabledDeleteIcon: string;
        categoricalFocus: string;
        categoricalDisabled: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_114: (classesProp?: Partial<Record<"root" | "floating" | "indicator" | "scroller" | "flexContainer", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        indicator: string;
        scroller: string;
        flexContainer: string;
        floating: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_115: (classesProp?: Partial<Record<"root" | "disabled" | "selected" | "focusVisible", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        focusVisible: string;
        selected: string;
        disabled: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_116: (classesProp?: Partial<Record<"label" | "root" | "invalid" | "disabled" | "readOnly" | "input" | "tagInputRoot" | "tagsList" | "error" | "description" | "labelContainer" | "resizable" | "suggestionsContainer" | "suggestionList" | "inputExtension" | "chipRoot" | "listItemGutters" | "listItemRoot" | "characterCounter" | "tagInputContainerRoot" | "tagSelected" | "tagInputBorderContainer" | "tagInputRootFocused" | "tagInputRootEmpty" | "singleLine", string>>, addStatic?: boolean) => {
    readonly classes: {
        listItemGutters: string;
        listItemRoot: string;
        root: string;
        chipRoot: string;
        disabled: string;
        readOnly: string;
        resizable: string;
        invalid: string;
        labelContainer: string;
        label: string;
        description: string;
        characterCounter: string;
        tagsList: string;
        tagInputContainerRoot: string;
        tagInputRoot: string;
        input: string;
        tagSelected: string;
        tagInputBorderContainer: string;
        tagInputRootFocused: string;
        tagInputRootEmpty: string;
        singleLine: string;
        error: string;
        inputExtension: string;
        suggestionsContainer: string;
        suggestionList: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_117: (classesProp?: Partial<Record<"label" | "root" | "invalid" | "disabled" | "input" | "error" | "description" | "labelContainer" | "resizable" | "inputResizable" | "characterCounter" | "baseInput", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        disabled: string;
        resizable: string;
        invalid: string;
        baseInput: string;
        input: string;
        inputResizable: string;
        labelContainer: string;
        label: string;
        description: string;
        characterCounter: string;
        error: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_118: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_119: (classesProp?: Partial<Record<"label" | "root" | "placeholder" | "icon" | "error" | "description" | "labelContainer" | "dropdownHeader" | "dropdownHeaderInvalid" | "dropdownHeaderOpen" | "placeholderDisabled" | "dropdownPanel" | "timePopperContainer", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        labelContainer: string;
        label: string;
        description: string;
        placeholder: string;
        placeholderDisabled: string;
        dropdownHeader: string;
        dropdownHeaderOpen: string;
        dropdownHeaderInvalid: string;
        dropdownPanel: string;
        icon: string;
        timePopperContainer: string;
        error: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_12: (classesProp?: Partial<Record<"label" | "root" | "panel" | "invalid" | "disabled" | "readOnly" | "select" | "popper" | "error" | "description" | "labelContainer" | "panelOpenedUp" | "panelOpenedDown", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        disabled: string;
        readOnly: string;
        invalid: string;
        labelContainer: string;
        label: string;
        description: string;
        select: string;
        popper: string;
        panel: string;
        panelOpenedUp: string;
        panelOpenedDown: string;
        error: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_120: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_121: (classesProp?: Partial<Record<"content" | "label" | "root" | "disabled" | "focused" | "selected" | "expanded" | "group" | "iconContainer", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        group: string;
        content: string;
        expanded: string;
        selected: string;
        focused: string;
        disabled: string;
        label: string;
        iconContainer: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_122: (classesProp?: Partial<Record<"label" | "root" | "disabled" | "focused" | "selected" | "expanded" | "iconContainer", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        expanded: string;
        selected: string;
        focused: string;
        disabled: string;
        iconContainer: string;
        label: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_123: (classesProp?: Partial<Record<"root" | "slider" | "collapsed" | "childData", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        collapsed: string;
        slider: string;
        childData: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_124: (classesProp?: Partial<Record<"root" | "title" | "backButton" | "minimized" | "collapseButton", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        minimized: string;
        collapseButton: string;
        backButton: string;
        title: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_125: (classesProp?: Partial<Record<"root" | "hide", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        hide: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_126: (classesProp?: Partial<Record<"action" | "minimized" | "noIcon", string>>, addStatic?: boolean) => {
    readonly classes: {
        action: string;
        noIcon: string;
        minimized: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_127: (classesProp?: Partial<Record<"root" | "listItem" | "list" | "popup" | "collapsed" | "navigationPopup", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        list: string;
        listItem: string;
        collapsed: string;
        popup: string;
        navigationPopup: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_128: (classesProp?: Partial<Record<"root" | "listItemSelected" | "listItemDisabled" | "listItemFocus" | "listContainer" | "forwardButton", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        listItemSelected: string;
        listItemFocus: string;
        forwardButton: string;
        listContainer: string;
        listItemDisabled: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_129: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_13: (classesProp?: Partial<Record<"secondary" | "primary" | "root" | "disabled" | "semantic" | "icon" | "secondarySubtle" | "ghost" | "secondaryGhost" | "contained" | "primaryGhost" | "primarySubtle" | "subtle" | "startIcon" | "endIcon" | "focusVisible", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        startIcon: string;
        endIcon: string;
        focusVisible: string;
        disabled: string;
        icon: string;
        contained: string;
        subtle: string;
        ghost: string;
        semantic: string;
        primary: string;
        primarySubtle: string;
        primaryGhost: string;
        secondarySubtle: string;
        secondaryGhost: string;
        secondary: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_130: (classesProp?: Partial<Record<"content" | "label" | "link" | "disabled" | "focused" | "icon" | "selectable" | "selected" | "hide" | "expanded" | "unselectable" | "group" | "node" | "expandable" | "labelIcon" | "collapsed" | "minimized" | "unselected" | "labelExpandable", string>>, addStatic?: boolean) => {
    readonly classes: {
        node: string;
        content: string;
        link: string;
        group: string;
        disabled: string;
        expandable: string;
        collapsed: string;
        expanded: string;
        selectable: string;
        unselectable: string;
        selected: string;
        unselected: string;
        focused: string;
        minimized: string;
        hide: string;
        label: string;
        labelIcon: string;
        labelExpandable: string;
        icon: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_131: (classesProp?: Partial<Record<"content" | "header" | "root" | "hidden" | "actions" | "hasHeader" | "spaceTop" | "raisedHeader", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        header: string;
        actions: string;
        content: string;
        hidden: string;
        raisedHeader: string;
        hasHeader: string;
        spaceTop: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_132: (classesProp?: Partial<Record<"content" | "root" | "circle" | "text" | "square" | "pulse" | "wave", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        content: string;
        circle: string;
        square: string;
        text: string;
        pulse: string;
        wave: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_14: (classesProp?: Partial<Record<"root" | "highlighted", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        highlighted: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_15: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_16: (classesProp?: Partial<Record<"vertical" | "horizontal" | "label" | "root" | "invalid" | "listbox" | "error" | "description", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        error: string;
        listbox: string;
        label: string;
        description: string;
        horizontal: string;
        vertical: string;
        invalid: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_17: (classesProp?: Partial<Record<"root" | "list" | "popper" | "portal", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        list: string;
        popper: string;
        portal: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_18: (classesProp?: Partial<Record<"root" | "invalid" | "disabled" | "multiline" | "readOnly" | "focused" | "input" | "inputReadOnly" | "inputRoot" | "resizable" | "inputBorderContainer" | "inputRootInvalid" | "inputRootReadOnly" | "inputRootFocused" | "inputRootDisabled" | "inputRootMultiline" | "inputDisabled" | "inputResizable", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        disabled: string;
        invalid: string;
        multiline: string;
        resizable: string;
        readOnly: string;
        focused: string;
        inputBorderContainer: string;
        inputRootInvalid: string;
        inputRootReadOnly: string;
        inputRoot: string;
        inputRootFocused: string;
        inputRootDisabled: string;
        inputRootMultiline: string;
        input: string;
        inputDisabled: string;
        inputReadOnly: string;
        inputResizable: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_19: (classesProp?: Partial<Record<"container" | "header" | "root" | "headerOpen" | "headerDisabled" | "headerReadOnly" | "placeholder" | "panel" | "inputExtensionOpen" | "anchor" | "selection" | "arrowContainer" | "panelOpenedUp" | "panelOpenedDown" | "rootDisabled" | "headerOpenUp" | "headerOpenDown" | "arrow" | "selectionDisabled" | "inputExtensionLeftPosition" | "inputExtensionOpenShadow" | "inputExtensionFloatRight" | "inputExtensionFloatLeft", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        rootDisabled: string;
        anchor: string;
        container: string;
        header: string;
        headerOpen: string;
        headerOpenUp: string;
        headerOpenDown: string;
        headerDisabled: string;
        headerReadOnly: string;
        arrowContainer: string;
        arrow: string;
        selection: string;
        selectionDisabled: string;
        placeholder: string;
        panel: string;
        panelOpenedUp: string;
        panelOpenedDown: string;
        inputExtensionOpen: string;
        inputExtensionLeftPosition: string;
        inputExtensionOpenShadow: string;
        inputExtensionFloatRight: string;
        inputExtensionFloatLeft: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_2: (classesProp?: Partial<Record<"root" | "disabled", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        disabled: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_20: (classesProp?: Partial<Record<"container" | "label" | "root" | "disabled" | "hidden", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        hidden: string;
        container: string;
        label: string;
        disabled: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_21: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_22: (classesProp?: Partial<Record<"root" | "button" | "actionContainer" | "dropDownMenu" | "dropDownMenuButton" | "dropDownMenuButtonSelected", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        button: string;
        actionContainer: string;
        dropDownMenu: string;
        dropDownMenuButton: string;
        dropDownMenuButtonSelected: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_23: (classesProp?: Partial<Record<"container" | "root" | "icon" | "iconSelected" | "baseContainer" | "menuListRoot" | "menuList", string>>, addStatic?: boolean) => {
    readonly classes: {
        container: string;
        baseContainer: string;
        root: string;
        icon: string;
        iconSelected: string;
        menuListRoot: string;
        menuList: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_24: (classesProp?: Partial<Record<"root" | "title" | "single" | "actionsContainer" | "open" | "item" | "titleAnchor" | "itemSelected" | "itemDisabled" | "itemTrigger" | "itemIcon" | "itemTitle" | "itemInfoIcon" | "footerContainer" | "closed" | "dual" | "fluid", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        item: string;
        itemSelected: string;
        itemDisabled: string;
        itemTrigger: string;
        itemIcon: string;
        itemTitle: string;
        itemInfoIcon: string;
        actionsContainer: string;
        footerContainer: string;
        open: string;
        closed: string;
        title: string;
        titleAnchor: string;
        single: string;
        dual: string;
        fluid: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_25: (classesProp?: Partial<Record<"typography" | "root" | "disabled" | "icon" | "title" | "selected" | "iconUrl" | "iconInfo" | "titleAnchor", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        icon: string;
        iconUrl: string;
        iconInfo: string;
        disabled: string;
        selected: string;
        typography: string;
        title: string;
        titleAnchor: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_26: (classesProp?: Partial<Record<"container" | "xs" | "sm" | "md" | "lg" | "xl" | "root" | "square" | "img" | "status" | "fallback" | "avatar" | "badge" | "circular", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        container: string;
        img: string;
        fallback: string;
        status: string;
        avatar: string;
        badge: string;
        xs: string;
        sm: string;
        md: string;
        lg: string;
        xl: string;
        circular: string;
        square: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_27: (classesProp?: Partial<Record<"root" | "row" | "column" | "highlight" | "toBack", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        row: string;
        column: string;
        highlight: string;
        toBack: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_28: (classesProp?: Partial<Record<"root" | "badgePosition" | "badge" | "badgeContainer" | "badgeHidden" | "showCount" | "showLabel" | "badgeIcon" | "badgeOneDigit", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        badgeContainer: string;
        badgePosition: string;
        badge: string;
        badgeHidden: string;
        showCount: string;
        showLabel: string;
        badgeIcon: string;
        badgeOneDigit: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_29: (classesProp?: Partial<Record<"root" | "rootClosed" | "anchorOriginTopCenter" | "anchorOriginBottomCenter", string>>, addStatic?: boolean) => {
    readonly classes: {
        rootClosed: string;
        root: string;
        anchorOriginTopCenter: string;
        anchorOriginBottomCenter: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_3: (classesProp?: Partial<Record<"root" | "disabled" | "focused" | "selected" | "focus" | "focusDisabled" | "externalReference" | "falseFocus", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        selected: string;
        disabled: string;
        focusDisabled: string;
        focused: string;
        externalReference: string;
        falseFocus: string;
        focus: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_30: (classesProp?: Partial<Record<"warning" | "root" | "action" | "default" | "success" | "error" | "message" | "actionContainer" | "baseVariant" | "outContainer" | "messageContainer" | "iconContainer" | "messageActions" | "actionsInnerContainer" | "closeAction", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        message: string;
        action: string;
        baseVariant: string;
        success: string;
        warning: string;
        error: string;
        default: string;
        outContainer: string;
        messageContainer: string;
        iconContainer: string;
        messageActions: string;
        actionContainer: string;
        actionsInnerContainer: string;
        closeAction: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_31: (classesProp?: Partial<Record<"root" | "disabled" | "semantic" | "icon" | "checked" | "indeterminate" | "focusVisible", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        disabled: string;
        focusVisible: string;
        icon: string;
        checked: string;
        indeterminate: string;
        semantic: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_32: (classesProp?: Partial<Record<"root" | "disabled" | "semantic" | "icon" | "checked" | "focusVisible", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        disabled: string;
        focusVisible: string;
        icon: string;
        checked: string;
        semantic: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_33: (classesProp?: Partial<Record<"root" | "disabled" | "readOnly" | "switch" | "switchBase" | "track" | "checked" | "thumb" | "focusVisible", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        switch: string;
        switchBase: string;
        track: string;
        thumb: string;
        checked: string;
        disabled: string;
        readOnly: string;
        focusVisible: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_34: (classesProp?: Partial<Record<"link" | "root" | "a" | "orderedList" | "currentPage" | "centerContainer" | "separatorContainer", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        link: string;
        orderedList: string;
        currentPage: string;
        centerContainer: string;
        separatorContainer: string;
        a: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_35: (classesProp?: Partial<Record<"root" | "semantic" | "divider" | "selectAll" | "actions" | "selectAllContainer" | "selectAllPages", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        semantic: string;
        actions: string;
        selectAllContainer: string;
        selectAll: string;
        selectAllPages: string;
        divider: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_36: (classesProp?: Partial<Record<"container" | "label" | "root" | "disabled" | "semantic" | "checkbox" | "checked" | "indeterminate" | "focusVisible" | "invalidContainer" | "invalidCheckbox", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        container: string;
        disabled: string;
        focusVisible: string;
        invalidContainer: string;
        checkbox: string;
        invalidCheckbox: string;
        label: string;
        checked: string;
        indeterminate: string;
        semantic: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_37: (classesProp?: Partial<Record<"root" | "rangeCalendarContainer" | "singleCalendar" | "focusSelection" | "calendarMonthlyCell" | "calendarMonthlyCellSelected", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        rangeCalendarContainer: string;
        singleCalendar: string;
        focusSelection: string;
        calendarMonthlyCell: string;
        calendarMonthlyCellSelected: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_38: (classesProp?: Partial<Record<"root" | "invalid" | "headerDayOfWeek", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        invalid: string;
        headerDayOfWeek: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_39: (classesProp?: Partial<Record<"root" | "focusSelection" | "navigationContainer" | "navigationMonth" | "cellContainer" | "calendarDate" | "calendarDateSelected" | "calendarDateNotInMonth" | "calendarDateInSelectionRange" | "startBookend" | "endBookend" | "cellsInRange" | "cellsOutsideRange" | "calendarGrid" | "calendarDay" | "calendarDateInvalid", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        calendarGrid: string;
        calendarDay: string;
        navigationContainer: string;
        focusSelection: string;
        navigationMonth: string;
        calendarDate: string;
        calendarDateNotInMonth: string;
        calendarDateSelected: string;
        calendarDateInvalid: string;
        calendarDateInSelectionRange: string;
        startBookend: string;
        endBookend: string;
        cellsInRange: string;
        cellsOutsideRange: string;
        cellContainer: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_4: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_40: (classesProp?: Partial<Record<"root" | "icon" | "selectable" | "selected" | "semanticContainer" | "semanticBar", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        selected: string;
        selectable: string;
        semanticContainer: string;
        icon: string;
        semanticBar: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_41: (classesProp?: Partial<Record<"content" | "root" | "title" | "titleShort" | "subheader" | "action", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        titleShort: string;
        title: string;
        subheader: string;
        content: string;
        action: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_42: (classesProp?: Partial<Record<"content", string>>, addStatic?: boolean) => {
    readonly classes: {
        content: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_43: (classesProp?: Partial<Record<"root" | "media", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        media: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_44: (classesProp?: Partial<Record<"xs" | "root" | "panel" | "title" | "controls" | "counterContainer" | "thumbnail" | "thumbnailSelected" | "dot" | "main" | "counter" | "actions" | "fullscreen" | "closeButton" | "mainContainer" | "pageCounter" | "mainXs" | "mainFullscreen" | "slideControls" | "slidesViewport" | "slidesContainer" | "dots" | "dotsXs" | "dotSelected", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        xs: string;
        fullscreen: string;
        title: string;
        actions: string;
        closeButton: string;
        mainContainer: string;
        controls: string;
        pageCounter: string;
        main: string;
        mainXs: string;
        mainFullscreen: string;
        counterContainer: string;
        counter: string;
        slideControls: string;
        slidesViewport: string;
        slidesContainer: string;
        dots: string;
        dotsXs: string;
        dot: string;
        dotSelected: string;
        panel: string;
        thumbnail: string;
        thumbnailSelected: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_45: (classesProp?: Partial<Record<"image" | "slide", string>>, addStatic?: boolean) => {
    readonly classes: {
        slide: string;
        image: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_46: (classesProp?: Partial<Record<"label" | "root" | "input" | "icon" | "error" | "inputRoot" | "description" | "adornmentButton" | "labelContainer" | "inputBorderContainer" | "inputRootFocused" | "inputRootDisabled" | "inputRootMultiline" | "adornmentsBox" | "iconClear" | "hasSuggestions" | "suggestionsContainer" | "suggestionList" | "inputExtension", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        labelContainer: string;
        label: string;
        description: string;
        adornmentsBox: string;
        icon: string;
        adornmentButton: string;
        iconClear: string;
        hasSuggestions: string;
        suggestionsContainer: string;
        suggestionList: string;
        inputExtension: string;
        input: string;
        inputRoot: string;
        inputRootFocused: string;
        inputRootDisabled: string;
        inputRootMultiline: string;
        inputBorderContainer: string;
        error: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_47: (classesProp?: Partial<Record<"root" | "icon" | "pageSizeOptions" | "pageSizeHeader" | "pageSizeTextContainer" | "pageSizeOptionsSelect" | "totalPagesTextContainer" | "pageNavigator" | "iconContainer" | "pageSizeRoot" | "pageInfo" | "pageJump" | "pageSizeInput" | "pageSizeInputRoot" | "pageSizeInputContainer", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        pageSizeOptions: string;
        pageSizeHeader: string;
        pageSizeRoot: string;
        pageSizeTextContainer: string;
        totalPagesTextContainer: string;
        pageSizeOptionsSelect: string;
        pageNavigator: string;
        iconContainer: string;
        icon: string;
        pageInfo: string;
        pageJump: string;
        pageSizeInput: string;
        pageSizeInputRoot: string;
        pageSizeInputContainer: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_48: (classesProp?: Partial<Record<"vertical" | "horizontal" | "label" | "root" | "invalid" | "error" | "group" | "selectAll", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        label: string;
        group: string;
        vertical: string;
        horizontal: string;
        invalid: string;
        selectAll: string;
        error: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_49: (classesProp?: Partial<Record<"label" | "colorPicker" | "root" | "panel" | "headerColorValue" | "recommendedColorsRoot" | "description" | "labelContainer" | "headerColorIcon" | "colorPickerIcon" | "dropdownRootIconOnly" | "headerColorIconOnly" | "pickerFields", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        labelContainer: string;
        label: string;
        description: string;
        headerColorValue: string;
        headerColorIcon: string;
        panel: string;
        colorPicker: string;
        colorPickerIcon: string;
        recommendedColorsRoot: string;
        dropdownRootIconOnly: string;
        headerColorIconOnly: string;
        pickerFields: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_5: (classesProp?: Partial<Record<"root" | "disabled" | "selected" | "condensed" | "focus" | "interactive" | "startAdornment" | "endAdornment" | "gutters" | "withStartAdornment" | "withEndAdornment", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        focus: string;
        startAdornment: string;
        endAdornment: string;
        gutters: string;
        condensed: string;
        interactive: string;
        selected: string;
        disabled: string;
        withStartAdornment: string;
        withEndAdornment: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_50: (classesProp?: Partial<Record<"root" | "fixed" | "disableGutters" | "maxWidthXs" | "maxWidthSm" | "maxWidthMd" | "maxWidthLg" | "maxWidthXl", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        disableGutters: string;
        fixed: string;
        maxWidthXs: string;
        maxWidthSm: string;
        maxWidthMd: string;
        maxWidthLg: string;
        maxWidthXl: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_51: (classesProp?: Partial<Record<"root" | "section" | "rightSection" | "leftSection", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        section: string;
        rightSection: string;
        leftSection: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_52: (classesProp?: Partial<Record<"body" | "root" | "head" | "variantListactions" | "variantListcheckbox" | "variantList" | "footer" | "resizable" | "sorted" | "alignLeft" | "alignCenter" | "alignRight" | "alignJustify" | "variantNone" | "variantCheckbox" | "variantActions" | "variantExpand" | "variantListHead" | "stickyColumn" | "stickyColumnMostLeft" | "stickyColumnLeastRight" | "groupColumnMostLeft" | "groupColumnMostRight" | "resizing", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        head: string;
        body: string;
        footer: string;
        sorted: string;
        alignLeft: string;
        alignCenter: string;
        alignRight: string;
        alignJustify: string;
        variantNone: string;
        variantCheckbox: string;
        variantActions: string;
        variantExpand: string;
        variantList: string;
        variantListHead: string;
        variantListactions: string;
        variantListcheckbox: string;
        stickyColumn: string;
        stickyColumnMostLeft: string;
        stickyColumnLeastRight: string;
        groupColumnMostLeft: string;
        groupColumnMostRight: string;
        resizable: string;
        resizing: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_53: (classesProp?: Partial<Record<"body" | "root" | "selected" | "head" | "variantList" | "expanded" | "footer" | "variantListHead" | "striped" | "hover", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        head: string;
        body: string;
        footer: string;
        selected: string;
        expanded: string;
        striped: string;
        hover: string;
        variantList: string;
        variantListHead: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_54: (classesProp?: Partial<Record<"body" | "root" | "head" | "sortButton" | "variantList" | "resizer" | "footer" | "resizable" | "sorted" | "alignLeft" | "alignCenter" | "alignRight" | "alignJustify" | "variantNone" | "variantCheckbox" | "variantActions" | "variantExpand" | "stickyColumn" | "stickyColumnMostLeft" | "stickyColumnLeastRight" | "groupColumnMostLeft" | "groupColumnMostRight" | "resizing" | "headerContent" | "headerText" | "headerParagraph" | "sortableHeaderText" | "sortable" | "sortIcon" | "alignFlexLeft" | "alignFlexRight" | "alignFlexCenter" | "alignFlexJustify", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        head: string;
        body: string;
        footer: string;
        stickyColumn: string;
        stickyColumnMostLeft: string;
        stickyColumnLeastRight: string;
        groupColumnMostLeft: string;
        groupColumnMostRight: string;
        headerContent: string;
        headerText: string;
        headerParagraph: string;
        sortableHeaderText: string;
        sorted: string;
        sortable: string;
        sortButton: string;
        sortIcon: string;
        alignLeft: string;
        alignRight: string;
        alignCenter: string;
        alignJustify: string;
        alignFlexLeft: string;
        alignFlexRight: string;
        alignFlexCenter: string;
        alignFlexJustify: string;
        variantCheckbox: string;
        variantExpand: string;
        variantActions: string;
        variantNone: string;
        variantList: string;
        resizable: string;
        resizing: string;
        resizer: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_55: (classesProp?: Partial<Record<"root" | "stickyHeader" | "stickyColumns" | "listRow", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        stickyHeader: string;
        stickyColumns: string;
        listRow: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_56: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_57: (classesProp?: Partial<Record<"root" | "sortDropdown", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        sortDropdown: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_58: (classesProp?: Partial<Record<"label" | "root" | "placeholder" | "disabled" | "readOnly" | "placeholderClosed" | "error" | "description" | "labelContainer" | "dropdown" | "arrow" | "selectionDisabled" | "dropdownHeader" | "dropdownHeaderInvalid" | "dropdownHeaderOpen" | "dropdownListContainer" | "rootList", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        labelContainer: string;
        label: string;
        description: string;
        error: string;
        placeholder: string;
        placeholderClosed: string;
        selectionDisabled: string;
        dropdown: string;
        arrow: string;
        dropdownHeader: string;
        dropdownHeaderInvalid: string;
        dropdownHeaderOpen: string;
        dropdownListContainer: string;
        rootList: string;
        disabled: string;
        readOnly: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_59: (classesProp?: Partial<Record<"listContainer" | "selection" | "virtualized" | "selectAll" | "selectAllContainer" | "dropdownListContainer" | "rootList" | "searchContainer" | "listBorderDown", string>>, addStatic?: boolean) => {
    readonly classes: {
        rootList: string;
        dropdownListContainer: string;
        virtualized: string;
        searchContainer: string;
        listBorderDown: string;
        listContainer: string;
        selectAllContainer: string;
        selection: string;
        selectAll: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_6: (classesProp?: Partial<Record<"root" | "counterDisabled" | "gutter" | "overloaded", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        counterDisabled: string;
        gutter: string;
        overloaded: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_60: (classesProp?: Partial<Record<"container" | "label" | "root" | "panel" | "icon" | "inputText" | "action" | "error" | "description" | "labelContainer" | "dropdown" | "actionContainer" | "dropdownHeaderInvalid" | "dropdownHeaderOpen" | "leftContainer" | "rightContainer" | "dateText", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        actionContainer: string;
        leftContainer: string;
        rightContainer: string;
        labelContainer: string;
        label: string;
        description: string;
        error: string;
        dropdown: string;
        panel: string;
        dropdownHeaderInvalid: string;
        dropdownHeaderOpen: string;
        icon: string;
        action: string;
        inputText: string;
        dateText: string;
        container: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_61: (classesProp?: Partial<Record<"root" | "titleText" | "messageContainer" | "fullscreen" | "textWithIcon", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        fullscreen: string;
        messageContainer: string;
        textWithIcon: string;
        titleText: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_62: (classesProp?: Partial<Record<"root" | "textContent", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        textContent: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_63: (classesProp?: Partial<Record<"root" | "spacing" | "fullscreen", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        fullscreen: string;
        spacing: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_64: (classesProp?: Partial<Record<"warning" | "background" | "root" | "paper" | "success" | "error" | "fullscreen" | "closeButton" | "fullHeight" | "statusBar", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        background: string;
        paper: string;
        fullscreen: string;
        fullHeight: string;
        closeButton: string;
        statusBar: string;
        success: string;
        error: string;
        warning: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_65: (classesProp?: Partial<Record<"horizontal" | "root" | "icon" | "radio" | "radioRoot", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        horizontal: string;
        radioRoot: string;
        radio: string;
        icon: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_66: (classesProp?: Partial<Record<"vertical" | "horizontal" | "label" | "root" | "invalid" | "error" | "group", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        label: string;
        group: string;
        vertical: string;
        horizontal: string;
        invalid: string;
        error: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_67: (classesProp?: Partial<Record<"background" | "root" | "paper" | "closeButton", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        paper: string;
        background: string;
        closeButton: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_68: (classesProp?: Partial<Record<"container" | "root" | "titleContainer" | "actionContainer" | "messageContainer" | "iconContainer" | "containerMessageOnly" | "textContainer", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        container: string;
        containerMessageOnly: string;
        iconContainer: string;
        titleContainer: string;
        textContainer: string;
        messageContainer: string;
        actionContainer: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_69: (classesProp?: Partial<Record<"overlay" | "previewButton", string>>, addStatic?: boolean) => {
    readonly classes: {
        previewButton: string;
        overlay: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_7: (classesProp?: Partial<Record<"root" | "disabled" | "icon" | "adornment" | "adornmentIcon" | "hideIcon" | "adornmentButton", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        icon: string;
        adornment: string;
        adornmentIcon: string;
        hideIcon: string;
        adornmentButton: string;
        disabled: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_70: (classesProp?: Partial<Record<"root" | "icon" | "progressbarContainer" | "previewContainer" | "progressbar" | "removeButton" | "progressbarBack" | "nameText" | "progressTextContainer" | "fail", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        progressbar: string;
        progressbarContainer: string;
        progressbarBack: string;
        nameText: string;
        progressTextContainer: string;
        removeButton: string;
        previewContainer: string;
        icon: string;
        fail: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_71: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_72: (classesProp?: Partial<Record<"dropZoneContainer" | "dragAction" | "dropZoneContainerDisabled" | "dropZoneLabelsGroup" | "inputArea" | "dropArea" | "dropZoneAreaLabels" | "dropZoneAreaIcon" | "dropZoneLabel" | "dragText" | "selectFilesText", string>>, addStatic?: boolean) => {
    readonly classes: {
        dropZoneContainer: string;
        dropZoneLabelsGroup: string;
        dragAction: string;
        dropZoneContainerDisabled: string;
        inputArea: string;
        dropArea: string;
        dropZoneAreaLabels: string;
        dropZoneAreaIcon: string;
        dropZoneLabel: string;
        dragText: string;
        selectFilesText: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_73: (classesProp?: Partial<Record<"label" | "root" | "error" | "description" | "labelContainer", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        label: string;
        labelContainer: string;
        description: string;
        error: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_74: (classesProp?: Partial<Record<"space" | "header" | "root" | "panel" | "rightSidePanel" | "applyButton" | "dropdown" | "baseDropdownSelection" | "leftSidePanel" | "actionBar", string>>, addStatic?: boolean) => {
    readonly classes: {
        dropdown: string;
        panel: string;
        header: string;
        baseDropdownSelection: string;
        root: string;
        rightSidePanel: string;
        leftSidePanel: string;
        actionBar: string;
        space: string;
        applyButton: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_75: (classesProp?: Partial<Record<"name" | "small" | "root" | "separator" | "rightContainer" | "copyright", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        name: string;
        rightContainer: string;
        copyright: string;
        separator: string;
        small: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_76: (classesProp?: Partial<Record<"name" | "root" | "section" | "wrapper" | "sectionName" | "actions" | "positionSticky" | "positionFixed" | "global" | "globalSectionArea" | "globalWrapperComplement" | "backButton", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        positionSticky: string;
        positionFixed: string;
        global: string;
        section: string;
        wrapper: string;
        globalSectionArea: string;
        globalWrapperComplement: string;
        backButton: string;
        name: string;
        sectionName: string;
        actions: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_77: (classesProp?: Partial<Record<"container" | "root" | "item" | "zeroMinWidth" | "direction-xs-column" | "direction-xs-reverse" | "direction-xs-row-reverse" | "wrap-xs-nowrap" | "wrap-xs-wrap-reverse" | "spacing-xs-1" | "spacing-xs-2" | "spacing-xs-3" | "spacing-xs-4" | "spacing-xs-5" | "spacing-xs-6" | "spacing-xs-7" | "spacing-xs-8" | "spacing-xs-9" | "spacing-xs-10" | "grid-xs-auto" | "grid-xs-true" | "grid-xs-1" | "grid-xs-2" | "grid-xs-3" | "grid-xs-4" | "grid-xs-5" | "grid-xs-6" | "grid-xs-7" | "grid-xs-8" | "grid-xs-9" | "grid-xs-10" | "grid-xs-11" | "grid-xs-12", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        container: string;
        item: string;
        zeroMinWidth: string;
        "direction-xs-column": string;
        "direction-xs-reverse": string;
        "direction-xs-row-reverse": string;
        "wrap-xs-nowrap": string;
        "wrap-xs-wrap-reverse": string;
        "spacing-xs-1": string;
        "spacing-xs-2": string;
        "spacing-xs-3": string;
        "spacing-xs-4": string;
        "spacing-xs-5": string;
        "spacing-xs-6": string;
        "spacing-xs-7": string;
        "spacing-xs-8": string;
        "spacing-xs-9": string;
        "spacing-xs-10": string;
        "grid-xs-auto": string;
        "grid-xs-true": string;
        "grid-xs-1": string;
        "grid-xs-2": string;
        "grid-xs-3": string;
        "grid-xs-4": string;
        "grid-xs-5": string;
        "grid-xs-6": string;
        "grid-xs-7": string;
        "grid-xs-8": string;
        "grid-xs-9": string;
        "grid-xs-10": string;
        "grid-xs-11": string;
        "grid-xs-12": string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_78: (classesProp?: Partial<Record<"backgroundColor" | "header" | "root" | "fixed", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        header: string;
        fixed: string;
        backgroundColor: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_79: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_8: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_80: (classesProp?: Partial<Record<"root" | "separator" | "brandName", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        separator: string;
        brandName: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_81: (classesProp?: Partial<Record<"root" | "active" | "list" | "hidden" | "menu" | "menubar", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        menu: string;
        menubar: string;
        hidden: string;
        active: string;
        list: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_82: (classesProp?: Partial<Record<"link" | "root" | "selected" | "button" | "menu" | "menubar" | "item", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        menu: string;
        menubar: string;
        selected: string;
        item: string;
        link: string;
        button: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_83: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_84: (classesProp?: Partial<Record<"root" | "input" | "icon" | "button" | "text" | "inputRoot" | "inputBorderContainer" | "largeText" | "textEmpty" | "iconVisible", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        inputBorderContainer: string;
        input: string;
        inputRoot: string;
        text: string;
        largeText: string;
        textEmpty: string;
        button: string;
        icon: string;
        iconVisible: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_85: (classesProp?: Partial<Record<"root" | "visualIndicatorContainer" | "comparisons" | "comparisonContainer" | "comparisonComposition" | "indicatorsContainer" | "indicatorText" | "indicatorUnit" | "spacingToTheRight" | "trendLine", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        visualIndicatorContainer: string;
        comparisons: string;
        comparisonContainer: string;
        comparisonComposition: string;
        indicatorsContainer: string;
        indicatorText: string;
        indicatorUnit: string;
        spacingToTheRight: string;
        trendLine: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_86: (classesProp?: Partial<Record<"a", string>>, addStatic?: boolean) => {
    readonly classes: {
        a: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_87: (classesProp?: Partial<Record<"link" | "root" | "itemSelector" | "item" | "virtualizedRoot" | "selectorRoot" | "selectorContainer" | "box" | "truncate" | "selectAllSelector", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        virtualizedRoot: string;
        selectorRoot: string;
        selectorContainer: string;
        box: string;
        truncate: string;
        item: string;
        itemSelector: string;
        link: string;
        selectAllSelector: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_88: (classesProp?: Partial<Record<"overlay" | "label" | "small" | "root" | "hidden" | "loadingBar" | "blur" | "barContainer" | "regular" | "smallColor" | "regularColor", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        barContainer: string;
        loadingBar: string;
        label: string;
        overlay: string;
        blur: string;
        hidden: string;
        small: string;
        regular: string;
        smallColor: string;
        regularColor: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_89: (classesProp?: Partial<Record<"root" | "loading", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        loading: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_9: (classesProp?: Partial<Record<"root" | "childGutter" | "labelDisabled", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        labelDisabled: string;
        childGutter: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_90: (classesProp?: Partial<Record<"root" | "formContainer", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        formContainer: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_91: (classesProp?: Partial<Record<"secondary" | "primary" | "vertical" | "root" | "secondarySubtle" | "selected" | "button" | "secondaryGhost" | "multiple" | "splitGroup" | "primaryGhost" | "primarySubtle" | "splitGroupDisabled" | "firstButton" | "lastButton", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        multiple: string;
        splitGroup: string;
        splitGroupDisabled: string;
        button: string;
        selected: string;
        vertical: string;
        firstButton: string;
        lastButton: string;
        primary: string;
        primarySubtle: string;
        primaryGhost: string;
        secondary: string;
        secondarySubtle: string;
        secondaryGhost: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_92: (classesProp?: Partial<Record<"tooltipData" | "tooltipAnchor" | "tooltipAnchorParagraph", string>>, addStatic?: boolean) => {
    readonly classes: {
        tooltipData: string;
        tooltipAnchor: string;
        tooltipAnchorParagraph: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_93: (classesProp?: Partial<Record<"color" | "root" | "title" | "popper" | "separator" | "tooltip" | "values" | "tooltipMulti" | "valuesContainer" | "separatorColor" | "valueWrapper", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        tooltip: string;
        popper: string;
        tooltipMulti: string;
        title: string;
        valuesContainer: string;
        values: string;
        color: string;
        separatorColor: string;
        separator: string;
        valueWrapper: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_94: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_95: (classesProp?: Partial<Record<"root" | "progress" | "progressBar" | "progressBarLabel" | "progressContainer" | "progressDone" | "progressBarContainer" | "progressError", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        progress: string;
        progressBar: string;
        progressBarLabel: string;
        progressContainer: string;
        progressDone: string;
        progressBarContainer: string;
        progressError: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_96: (classesProp?: Partial<Record<"root" | "topGroup" | "subGroup" | "subRulesContainer" | "topActionButtonContainer" | "createConditionButton" | "createGroupButton" | "removeButton" | "combinator" | "topCombinator" | "combinatorButton" | "topRemoveButton" | "topRemoveButtonDisabled" | "rulesContainer" | "actionButtonContainer" | "topRulesContainer" | "buttonBackground", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        topGroup: string;
        subGroup: string;
        combinator: string;
        topCombinator: string;
        combinatorButton: string;
        removeButton: string;
        topRemoveButton: string;
        topRemoveButtonDisabled: string;
        rulesContainer: string;
        subRulesContainer: string;
        actionButtonContainer: string;
        topActionButtonContainer: string;
        topRulesContainer: string;
        buttonBackground: string;
        createConditionButton: string;
        createGroupButton: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_97: (classesProp?: Partial<Record<"container" | "label" | "root" | "disabled" | "semantic" | "radio" | "checked" | "focusVisible" | "invalidContainer" | "invalidRadio", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        container: string;
        invalidContainer: string;
        disabled: string;
        radio: string;
        invalidRadio: string;
        label: string;
        focusVisible: string;
        checked: string;
        semantic: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_98: (classesProp?: Partial<Record<"root" | "selected" | "button" | "text" | "bullet" | "bulletSelected", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        button: string;
        text: string;
        selected: string;
        bullet: string;
        bulletSelected: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

declare const useClasses_99: (classesProp?: Partial<Record<"root" | "selected" | "notSelected" | "positionSticky" | "positionFixed" | "notSelectedRoot", string>>, addStatic?: boolean) => {
    readonly classes: {
        root: string;
        positionSticky: string;
        positionFixed: string;
        notSelectedRoot: string;
        notSelected: string;
        selected: string;
    };
    readonly css: any;
    readonly cx: (...args: any) => string;
};

export declare const useClickOutside: <T extends HTMLElement = HTMLElement>(ref: React.RefObject<T>, handler: (event: HvClickOutsideEvent) => void) => void;

export declare const useComputation: (valueFn: Function, valueFallback?: Function) => (Function | undefined)[];

export declare const useControlled: <T>(controlledProp: T | undefined, initialState: T | (() => T)) => readonly [T, (newValue: React.SetStateAction<T>) => void];

export { useCss }

export { useDefaultProps }

export declare const useEnhancedEffect: typeof useLayoutEffect;

export declare type UseFiltersProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare const useForkRef: (refA: any, refB: any) => ((refValue: any) => void) | null;

export declare type UseGlobalFilterProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare const useHvBulkActions: UseBulkActionsProps;

export declare interface UseHvBulkActionsHooks<D extends object> {
    getHvBulkActionsProps: Array<HvBulkActionsPropGetter<D>>;
}

export declare interface UseHvBulkActionsTableInstanceProps<D extends object> {
    getHvBulkActionsProps: (propGetter?: HvBulkActionsPropGetter<D>) => HvTAbleBulkActionsProps;
    invertedToggleAllRowsSelected: () => void;
}

export declare type UseHvBulkActionsTableOptions = {
    /** Controls whether the "Select all" should _select_ or _unselect_ the rows, in a partial selection state. */
    aditivePageBulkSelection?: boolean;
    /** Controls whether _only the current page_ or _all pages_ should be unselected */
    subtractivePageBulkDeselection?: boolean;
    showSelectAllPages?: boolean;
};

export declare const useHvFilters: UseFiltersProps;

export declare const useHvGlobalFilter: UseGlobalFilterProps;

export declare const useHvHeaderGroups: UseHvHeaderGroupsProps;

export declare interface UseHvHeaderGroupsCellProps {
    groupColumnMostLeft?: boolean;
    groupColumnMostRight?: boolean;
}

export declare interface UseHvHeaderGroupsColumnProps {
    style?: React.CSSProperties;
    groupColumnMostLeft?: boolean;
    groupColumnMostRight?: boolean;
}

export declare interface UseHvHeaderGroupsInstance {
    hasGroupedColumns?: boolean;
}

export declare type UseHvHeaderGroupsProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare const useHvPagination: UsePaginationProps;

export declare interface UseHvPaginationHooks<D extends object> {
    getHvPaginationProps: Array<HvPaginationPropGetter<D>>;
}

export declare interface UseHvPaginationTableInstance<D extends object> {
    getHvPaginationProps: (propGetter?: HvPaginationPropGetter<D>) => HvTablePaginationProps;
}

export declare interface UseHvResizeColumnProps {
    resizable?: boolean;
    resizing?: boolean;
    resizerProps?: React.HTMLAttributes<HTMLDivElement>;
}

export declare const useHvResizeColumns: UseHvResizeColumnsProps;

export declare type UseHvResizeColumnsProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare interface UseHvResizeTableCellProps {
    resizable?: boolean;
    resizing?: boolean;
}

export declare const useHvRowExpand: UseRowExpandProps;

export declare interface UseHvRowExpandRowInstance<D extends object = Record<string, unknown>> extends UseExpandedRowProps<D> {
    getToggleRowExpandedProps: (props?: Partial<TableExpandedToggleProps>) => UseHvRowExpandRowToggleProps;
}

export declare interface UseHvRowExpandRowToggleProps extends TableExpandedToggleProps {
    onClick?: React.MouseEventHandler<unknown>;
}

export declare type UseHvRowExpandTableOptions = {
    disableCreateExpandButton?: boolean;
};

export declare interface UseHvRowExpandTableRowProps {
    expanded?: boolean;
}

export declare const useHvRowSelection: UseRowSelectionProps;

export declare interface UseHvRowSelectionBulkCheckboxProps {
    onChange?: (e: React.ChangeEvent, checked?: boolean) => void;
    checked?: boolean;
    indeterminate?: boolean;
}

export declare interface UseHvRowSelectionHooks<D extends object> {
    getToggleRowSelectedProps: Array<PropGetter<D, UseHvRowSelectionRowCheckboxProps>>;
    getToggleAllRowsSelectedProps: Array<PropGetter<D, UseHvRowSelectionBulkCheckboxProps>>;
    getToggleAllPageRowsSelectedProps: Array<PropGetter<D, UseHvRowSelectionBulkCheckboxProps>>;
}

export declare interface UseHvRowSelectionRowCheckboxProps {
    onChange?: (e: React.ChangeEvent, checked?: boolean) => void;
    checked?: boolean;
    disabled?: boolean;
    indeterminate?: boolean;
}

export declare interface UseHvRowSelectionRowInstance {
    isSelected: boolean;
    isSomeSelected: boolean;
    isSelectionLocked: boolean;
    toggleRowLockedSelection: (set?: boolean) => void;
    toggleRowSelected: (set?: boolean) => void;
    getToggleRowSelectedProps: (props?: Partial<UseHvRowSelectionRowCheckboxProps>) => UseHvRowSelectionRowCheckboxProps;
}

export declare interface UseHvRowSelectionState<D extends object> {
    selectedRowIds: Record<IdType_2<D>, boolean>;
    lockedSelectionRowIds: Record<IdType_2<D>, boolean>;
}

export declare interface UseHvRowSelectionTableColumnProps {
    "aria-hidden"?: boolean;
}

export declare interface UseHvRowSelectionTableInstance<D extends object> {
    toggleRowSelected: (rowId: IdType_2<D>, set?: boolean) => void;
    toggleAllRowsSelected: (value?: boolean) => void;
    toggleAllPageRowsSelected: (value?: boolean) => void;
    getToggleAllRowsSelectedProps: (props?: Partial<UseHvRowSelectionBulkCheckboxProps>) => UseHvRowSelectionBulkCheckboxProps;
    getToggleAllPageRowsSelectedProps: (props?: Partial<UseHvRowSelectionBulkCheckboxProps>) => UseHvRowSelectionBulkCheckboxProps;
    isNoRowsSelected: boolean;
    isNoPageRowsSelected: boolean;
    isAllRowsSelected: boolean;
    isAllPageRowsSelected: boolean;
    isAllSelectableRowsSelected: boolean;
    isAllSelectablePageRowsSelected: boolean;
    isAllSelectableRowsUnselected: boolean;
    isAllSelectablePageRowsUnselected: boolean;
    selectedFlatRows: Array<Row<D>>;
}

export declare type UseHvRowSelectionTableOptions = Partial<{
    autoResetSelectedRows: boolean;
    autoResetLockedSelectionRows: boolean;
    selectSubRows: boolean;
    manualRowSelectedKey: string;
    applyToggleAllRowsSelectedToPrefilteredRows: boolean;
}>;

export declare interface UseHvRowSelectionTableRowProps {
    selected?: boolean;
}

export declare const useHvRowState: typeof useRowState;

export declare const useHvSnackbar: () => {
    enqueueSnackbar: (message: React.ReactNode, options?: HvNotistackSnackMessageProps) => SnackbarKey;
    closeSnackbar: (key?: SnackbarKey) => void;
};

export declare const useHvSortBy: UseHvSortByProps;

export declare interface UseHvSortByColumnProps {
    sortable?: boolean;
    sorted?: boolean;
    sortDirection?: "descending" | "ascending";
    onClick?: (e: React.MouseEvent<HTMLTableCellElement>) => void;
}

export declare type UseHvSortByProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare interface UseHvSortByTableCellProps {
    sorted?: boolean;
}

declare function useHvTable<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(options: HvTableOptions<D, H>, ...plugins: HvTablePluginHook<D>[]): HvTableInstance<D, H>;
export { useHvTable as useHvData }
export { useHvTable }

export declare type UseHvTableProps = <D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(options: HvTableOptions<D, H>, ...plugins: Array<HvTablePluginHook<D>>) => HvTableInstance<D, H>;

export declare type UseHvTableSticky = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare const useHvTableSticky: UseHvTableSticky;

export declare interface UseHvTableStickyCellProps {
    stickyColumn?: boolean;
    stickyColumnMostLeft?: boolean;
    stickyColumnLeastRight?: boolean;
}

export declare interface UseHvTableStickyColumnProps {
    stickyColumn?: boolean;
    stickyColumnMostLeft?: boolean;
    stickyColumnLeastRight?: boolean;
}

export declare interface UseHvTableStickyHooks<D extends object> {
    getTableHeadProps: Array<HvTableHeadPropGetter<D>>;
}

export declare interface UseHvTableStickyTableHeadProps extends TableCommonProps {
    stickyHeader?: boolean;
}

export declare interface UseHvTableStickyTableInstance<D extends object> {
    getTableHeadProps: (propGetter?: HvTableHeadPropGetter<D>) => UseHvTableStickyTableHeadProps;
    totalRight?: number;
    hasStickyColumns?: boolean;
}

export declare type UseHvTableStickyTableOptions = {
    stickyHeader?: boolean;
    stickyColumns?: boolean;
};

export declare interface UseHvTableStickyTableProps {
    stickyHeader?: boolean;
    stickyColumns?: boolean;
}

export declare const useHvTableStyles: UseTableStylesProps;

export declare interface UseHvTableStylesColumnOptions {
    variant?: "checkbox" | "expand" | "actions" | "default" | "none";
    align?: "center" | "inherit" | "justify" | "left" | "right";
    style?: React.CSSProperties;
    className?: string;
    classes?: Record<string, string>;
    headerStyle?: React.CSSProperties;
    headerClassName?: string;
    headerClasses?: Record<string, string>;
    cellStyle?: React.CSSProperties;
    cellClassName?: string;
    cellClasses?: Record<string, string>;
}

export declare interface UseHvTableStylesTableCellProps {
    style?: React.CSSProperties;
    className?: string;
    classes?: Record<string, string>;
    variant?: "checkbox" | "expand" | "actions" | "default" | "none";
    align?: "center" | "inherit" | "justify" | "left" | "right";
}

export declare type UseHvTableStylesTableOptions = {
    style?: React.CSSProperties;
    className?: string;
    classes?: Record<string, string>;
    component?: any;
};

export declare interface UseHvTableStylesTableRowProps {
    hover?: boolean;
}

export declare function useHvTreeItem(nodeId: string): {
    instance: (UseTreeViewNodesInstance & UseTreeViewExpansionInstance & UseTreeViewSelectionInstance & UseTreeViewFocusInstance & UseTreeViewKeyboardNavigationInstance) | null;
    level: number;
    disabled: boolean;
    expanded: boolean;
    selected: boolean;
    focused: boolean;
    handleExpansion: (event: React_2.MouseEvent) => void;
    handleSelection: (event: React_2.MouseEvent) => void;
    preventSelection: (event: React_2.MouseEvent) => void;
};

export declare const useImageLoaded: (src?: string, srcSet?: string) => string | boolean;

export declare const useIsMounted: () => MutableRefObject<boolean>;

export declare function useLabels<T>(defaultLabels: T, labels?: DeepPartial<T>): T;

export declare type UsePaginationProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare const useQueryBuilderContext: () => HvQueryBuilderContextValue;

export declare type UseRowExpandProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare type UseRowSelectionProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare type UseRowStateProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare function useSavedState<T>(defaultState: T): readonly [T | undefined, (value?: T, save?: boolean) => void, () => void, T | undefined, T];

export declare const useSelectionPath: (data: HvHeaderNavigationItemProp[], selectedId?: string) => string[];

export declare type UseTableStylesProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export { useTheme }

declare interface UseTreeViewContextValueBuilderParameters {
    /**
     * This prop is used to help implement the accessibility logic.
     * If you don't provide this prop. It falls back to a randomly generated id.
     */
    id?: string;
    /**
     * The default icon used to collapse the node.
     */
    defaultCollapseIcon?: React.ReactNode;
    /**
     * The default icon displayed next to a end node. This is applied to all
     * tree nodes and can be overridden by the TreeItem `icon` prop.
     */
    defaultEndIcon?: React.ReactNode;
    /**
     * The default icon used to expand the node.
     */
    defaultExpandIcon?: React.ReactNode;
    /**
     * The default icon displayed next to a parent node. This is applied to all
     * parent nodes and can be overridden by the TreeItem `icon` prop.
     */
    defaultParentIcon?: React.ReactNode;
}

declare interface UseTreeViewExpansionParameters {
    /**
     * Expanded node ids.
     * Used when the item's expansion is controlled.
     */
    expanded?: string[];
    /**
     * Expanded node ids.
     * Used when the item's expansion is not controlled.
     * @default []
     */
    defaultExpanded?: string[];
    /**
     * Callback fired when tree items are expanded/collapsed.
     * @param {React.SyntheticEvent} event The event source of the callback.
     * @param {array} nodeIds The ids of the expanded nodes.
     */
    onNodeToggle?: (event: React_2.SyntheticEvent, nodeIds: string[]) => void;
}

declare interface UseTreeViewFocusParameters {
    /**
     * Callback fired when tree items are focused.
     * @param {React.SyntheticEvent} event The event source of the callback **Warning**: This is a generic event not a focus event.
     * @param {string} nodeId The id of the node focused.
     * @param {string} value of the focused node.
     */
    onNodeFocus?: (event: React_2.SyntheticEvent, nodeId: string) => void;
}

declare interface UseTreeViewNodesParameters {
    /**
     * If `true`, will allow focus on disabled items.
     * @default false
     */
    disabledItemsFocusable?: boolean;
}

declare interface UseTreeViewSelectionParameters<Multiple extends boolean | undefined> {
    /**
     * If `true` selection is disabled.
     * @default false
     */
    disableSelection?: boolean;
    /**
     * Selected node ids. (Uncontrolled)
     * When `multiSelect` is true this takes an array of strings; when false (default) a string.
     * @default []
     */
    defaultSelected?: TreeViewSelectionValue<Multiple>;
    /**
     * Selected node ids. (Controlled)
     * When `multiSelect` is true this takes an array of strings; when false (default) a string.
     */
    selected?: TreeViewSelectionValue<Multiple>;
    /**
     * If true `ctrl` and `shift` will trigger multiselect.
     * @default false
     */
    multiSelect?: Multiple;
    /**
     * Callback fired when tree items are selected/unselected.
     * @param {React.SyntheticEvent} event The event source of the callback
     * @param {string[] | string} nodeIds Ids of the selected nodes. When `multiSelect` is true
     * this is an array of strings; when false (default) a string.
     */
    onNodeSelect?: (event: React_2.SyntheticEvent, nodeIds: Exclude<TreeViewSelectionValue<Multiple>, null>) => void;
}

export declare const useUniqueId: (deterministicId?: string, idPrefix?: string) => string;

export declare const useWidth: () => Breakpoint_2;

declare type ValueOf<T> = T[keyof T];

declare type ValueRenderer = React.FC<HvQueryBuilderRendererProps> | Record<string, React.FC<HvQueryBuilderRendererProps>>;

export declare const verticalNavigationClasses: {
    root: string;
    collapsed: string;
    slider: string;
    childData: string;
};

export declare const VerticalNavigationContext: Context<VerticalNavigationContextValue>;

declare interface VerticalNavigationContextValue {
    isOpen: boolean;
    useIcons: boolean;
    slider?: boolean;
    headerTitle?: string;
    parentItem?: any;
    setParentItem?: React.Dispatch<React.SetStateAction<any>>;
    withParentData?: any;
    navigateToChildHandler?: (event: any, item: any) => void;
    navigateToParentHandler?: () => void;
    parentData?: NavigationData[];
    setParentData?: React.Dispatch<React.SetStateAction<any>>;
    parentSelected?: any;
    setParentSelected?: React.Dispatch<React.SetStateAction<any>>;
    hasAnyChildWithData?: boolean;
}

export declare const verticalNavigationHeaderClasses: {
    root: string;
    minimized: string;
    collapseButton: string;
    backButton: string;
    title: string;
};

export declare const verticalNavigationSliderClasses: {
    root: string;
    listItemSelected: string;
    listItemFocus: string;
    forwardButton: string;
    listContainer: string;
    listItemDisabled: string;
};

export declare const verticalNavigationTreeClasses: {
    root: string;
    list: string;
    listItem: string;
    collapsed: string;
    popup: string;
    navigationPopup: string;
};

export declare const verticalScrollListItemClasses: {
    root: string;
    icon: string;
    notSelected: string;
    text: string;
    button: string;
};

export declare type VisibilitySelectorActions = "previous_month" | "next_month" | "previous_year" | "next_year" | "month" | "month_year";

export declare const warningTextClasses: {
    root: string;
    defaultIcon: string;
    warningText: string;
    show: string;
    topGutter: string;
    hideText: string;
    topBorder: string;
};

/** @deprecated wrap your component with `HvTooltip` */
export declare const withTooltip: (Component: React.FunctionComponent, label: string | undefined, placement: HvTooltipPlacementType, hideTooltip?: (event: React.MouseEvent<HTMLDivElement>) => boolean, tooltipProps?: Partial<HvTooltipProps>, tooltipContainerProps?: HvBaseProps) => (props: any) => JSX_2.Element;

/** @deprecated */
export declare const wrapperTooltip: (hasTooltips: boolean, Component: any, label: any) => ((props: any) => JSX_2.Element) | (() => any);

export { }
