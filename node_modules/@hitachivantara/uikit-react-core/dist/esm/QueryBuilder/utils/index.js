import { uniqueId, isEqual } from "../../utils/helpers.js";
const isBigList = (values) => values != null && values?.length > 10;
const ID_PREFIX = "@hv_";
const createId = () => uniqueId(ID_PREFIX);
const emptyRule = () => ({
  id: createId()
});
const emptyGroup = (createEmptyRule = false) => ({
  id: createId(),
  combinator: "and",
  rules: createEmptyRule ? [emptyRule()] : []
});
const clearNodeIds = (original, full = false) => {
  const rule = { ...original };
  if (!full && rule.id?.toString().startsWith(ID_PREFIX) || full) {
    delete rule.id;
  }
  if ("rules" in rule) {
    rule.rules = rule.rules.map((r) => clearNodeIds(r, full));
  }
  return rule;
};
const isQueryGroup = (value) => "rules" in value;
const setNodeIds = (query, prevQuery) => {
  if (!query.id) {
    query.id = prevQuery?.id && isEqual(
      clearNodeIds(structuredClone(query)),
      clearNodeIds(structuredClone(prevQuery))
    ) ? prevQuery.id : createId();
  }
  if (isQueryGroup(query)) {
    query.rules = query.rules.map(
      (item, idx) => setNodeIds(
        item,
        prevQuery && isQueryGroup(prevQuery) ? prevQuery.rules[idx] : void 0
      )
    );
  }
  return query;
};
const findNodeById = (id, node) => {
  if (node.id === id) {
    return node;
  }
  if ("rules" in node) {
    for (let i = 0; i < node.rules.length; ++i) {
      const rule = node.rules[i];
      const found = findNodeById(id, rule);
      if (found) {
        return found;
      }
    }
  }
  return null;
};
const findParentById = (id, node, parent) => {
  if (node.id === id) {
    return parent ?? null;
  }
  if ("rules" in node) {
    const group = node;
    for (let i = 0; i < group.rules.length; ++i) {
      const rule = group.rules[i];
      const found = findParentById(id, rule, group);
      if (found) {
        return found;
      }
    }
  }
  return null;
};
export {
  clearNodeIds,
  emptyGroup,
  emptyRule,
  findNodeById,
  findParentById,
  isBigList,
  setNodeIds
};
