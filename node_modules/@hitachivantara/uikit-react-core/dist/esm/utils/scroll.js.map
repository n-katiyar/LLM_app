{"version":3,"file":"scroll.js","sources":["../../../src/utils/scroll.ts"],"sourcesContent":["import { HvScrollToOption } from \"../types/scroll\";\n\ntype ExtendedWindow = Window & typeof globalThis & HTMLElement;\n\nexport const getScrollTop = (\n  c: HTMLElement | (Window & typeof globalThis) | null = window,\n) => {\n  if (c === null) {\n    return 0;\n  }\n\n  if (c === window) {\n    return (\n      window.scrollY ||\n      window.pageYOffset ||\n      document.documentElement?.scrollTop ||\n      document.body.scrollTop\n    );\n  }\n\n  return (c as ExtendedWindow).scrollTop;\n};\n\nexport const verticalScrollOffset = (\n  t: HTMLElement | (Window & typeof globalThis),\n  c: HTMLElement | (Window & typeof globalThis) = window,\n) => {\n  if (c === window) {\n    return (\n      ((t as ExtendedWindow)?.getBoundingClientRect?.().top || 0) +\n      (window.scrollY || window.pageYOffset)\n    );\n  }\n  if (getComputedStyle(c as ExtendedWindow).position !== \"static\") {\n    return (t as ExtendedWindow).offsetTop;\n  }\n\n  return (t as ExtendedWindow).offsetTop - (c as ExtendedWindow).offsetTop;\n};\n\nexport const horizontalScrollOffset = (\n  t: HTMLElement,\n  c: HTMLElement | (Window & typeof globalThis) = window,\n) => {\n  if (c === window) {\n    return (\n      (t?.getBoundingClientRect?.().left || 0) +\n      (window.scrollX || window.pageXOffset)\n    );\n  }\n  if (getComputedStyle(c as ExtendedWindow).position !== \"static\") {\n    return t.offsetLeft;\n  }\n\n  return t.offsetLeft - (c as ExtendedWindow).offsetLeft;\n};\n\nexport const scrollElement = (\n  element: HTMLElement,\n  container: HTMLElement | (Window & typeof globalThis) | null,\n  offset = 0,\n  direction?: \"row\" | \"column\",\n) => {\n  if (container === null) {\n    return;\n  }\n\n  if (direction === \"row\") {\n    const elemLeft = horizontalScrollOffset(element, container);\n    container?.scrollTo?.({\n      left: elemLeft - offset,\n      behavior: \"smooth\",\n    });\n  } else {\n    const elemTop = verticalScrollOffset(element, container);\n    container?.scrollTo?.({\n      top: elemTop - offset,\n      behavior: \"smooth\",\n    });\n  }\n  element.focus({ preventScroll: true });\n};\n\nexport const isScrolledToTheBottom = (\n  container: HTMLElement | (Window & typeof globalThis) | null,\n) => {\n  if (container === null) {\n    return false;\n  }\n\n  const containerScrollTop = getScrollTop(container);\n\n  if (container === window) {\n    // Accounting for cases where html/body are set to height:100%\n    const scrollHeight =\n      document.documentElement?.scrollHeight || document.body.scrollHeight;\n\n    return containerScrollTop + window.innerHeight >= scrollHeight;\n  }\n\n  return (\n    containerScrollTop + (container as ExtendedWindow).offsetHeight >=\n    (container as ExtendedWindow).scrollHeight\n  );\n};\n\nexport const findFirstVisibleElement = (\n  container: HTMLElement | (Window & typeof globalThis) | null,\n  options: HvScrollToOption[],\n  offset: number,\n) => {\n  if (container === null) {\n    return -1;\n  }\n  const boundsTop = verticalScrollOffset(container);\n\n  let i = 0;\n\n  // Find index of first element whose top is still visible inside the container\n  for (; i < options.length; i += 1) {\n    const ele = document.getElementById(options[i].value);\n\n    if (ele) {\n      const elemTop = verticalScrollOffset(ele) - (options[i].offset || offset);\n\n      if (elemTop > boundsTop) {\n        break;\n      }\n    }\n  }\n\n  // Return the previous index, the element that last scrolled past the top\n  return i - 1;\n};\n"],"names":[],"mappings":"AAIa,MAAA,eAAe,CAC1B,IAAuD,WACpD;AACH,MAAI,MAAM,MAAM;AACP,WAAA;AAAA,EAAA;AAGT,MAAI,MAAM,QAAQ;AAEd,WAAA,OAAO,WACP,OAAO,eACP,SAAS,iBAAiB,aAC1B,SAAS,KAAK;AAAA,EAAA;AAIlB,SAAQ,EAAqB;AAC/B;AAEO,MAAM,uBAAuB,CAClC,GACA,IAAgD,WAC7C;AACH,MAAI,MAAM,QAAQ;AAChB,YACI,GAAsB,wBAAwB,EAAE,OAAO,MACxD,OAAO,WAAW,OAAO;AAAA,EAAA;AAG9B,MAAI,iBAAiB,CAAmB,EAAE,aAAa,UAAU;AAC/D,WAAQ,EAAqB;AAAA,EAAA;AAGvB,SAAA,EAAqB,YAAa,EAAqB;AACjE;AAEO,MAAM,yBAAyB,CACpC,GACA,IAAgD,WAC7C;AACH,MAAI,MAAM,QAAQ;AAChB,YACG,GAAG,wBAAwB,EAAE,QAAQ,MACrC,OAAO,WAAW,OAAO;AAAA,EAAA;AAG9B,MAAI,iBAAiB,CAAmB,EAAE,aAAa,UAAU;AAC/D,WAAO,EAAE;AAAA,EAAA;AAGJ,SAAA,EAAE,aAAc,EAAqB;AAC9C;AAEO,MAAM,gBAAgB,CAC3B,SACA,WACA,SAAS,GACT,cACG;AACH,MAAI,cAAc,MAAM;AACtB;AAAA,EAAA;AAGF,MAAI,cAAc,OAAO;AACjB,UAAA,WAAW,uBAAuB,SAAS,SAAS;AAC1D,eAAW,WAAW;AAAA,MACpB,MAAM,WAAW;AAAA,MACjB,UAAU;AAAA,IAAA,CACX;AAAA,EAAA,OACI;AACC,UAAA,UAAU,qBAAqB,SAAS,SAAS;AACvD,eAAW,WAAW;AAAA,MACpB,KAAK,UAAU;AAAA,MACf,UAAU;AAAA,IAAA,CACX;AAAA,EAAA;AAEH,UAAQ,MAAM,EAAE,eAAe,KAAA,CAAM;AACvC;AAEa,MAAA,wBAAwB,CACnC,cACG;AACH,MAAI,cAAc,MAAM;AACf,WAAA;AAAA,EAAA;AAGH,QAAA,qBAAqB,aAAa,SAAS;AAEjD,MAAI,cAAc,QAAQ;AAExB,UAAM,eACJ,SAAS,iBAAiB,gBAAgB,SAAS,KAAK;AAEnD,WAAA,qBAAqB,OAAO,eAAe;AAAA,EAAA;AAIlD,SAAA,qBAAsB,UAA6B,gBAClD,UAA6B;AAElC;AAEO,MAAM,0BAA0B,CACrC,WACA,SACA,WACG;AACH,MAAI,cAAc,MAAM;AACf,WAAA;AAAA,EAAA;AAEH,QAAA,YAAY,qBAAqB,SAAS;AAEhD,MAAI,IAAI;AAGR,SAAO,IAAI,QAAQ,QAAQ,KAAK,GAAG;AACjC,UAAM,MAAM,SAAS,eAAe,QAAQ,CAAC,EAAE,KAAK;AAEpD,QAAI,KAAK;AACP,YAAM,UAAU,qBAAqB,GAAG,KAAK,QAAQ,CAAC,EAAE,UAAU;AAElE,UAAI,UAAU,WAAW;AACvB;AAAA,MAAA;AAAA,IACF;AAAA,EACF;AAIF,SAAO,IAAI;AACb;"}