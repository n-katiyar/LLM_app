import { jsxs, jsx, Fragment } from "react/jsx-runtime";
import { forwardRef, useState, useRef, useMemo, useCallback, useEffect } from "react";
import { useForkRef } from "@mui/material/utils";
import { useDefaultProps } from "@hitachivantara/uikit-react-utils";
import { DEFAULT_ERROR_MESSAGES } from "../BaseInput/validations.js";
import { HvSuggestions } from "../FormElement/Suggestions/Suggestions.js";
import { useControlled } from "../hooks/useControlled.js";
import { useFocus } from "../hooks/useFocus.js";
import { useIsMounted } from "../hooks/useIsMounted.js";
import { useUniqueId } from "../hooks/useUniqueId.js";
import { isKey } from "../utils/keyboardUtils.js";
import { setId } from "../utils/setId.js";
import { useClasses } from "./TagsInput.styles.js";
import { staticClasses } from "./TagsInput.styles.js";
import { HvCharCounter } from "../FormElement/CharCounter/CharCounter.js";
import { validationStates } from "../FormElement/utils.js";
import { HvFormElement } from "../FormElement/FormElement.js";
import { HvLabel } from "../FormElement/Label/Label.js";
import { HvInfoMessage } from "../FormElement/InfoMessage/InfoMessage.js";
import { HvTag } from "../Tag/Tag.js";
import { HvWarningText } from "../FormElement/WarningText/WarningText.js";
const HvTagsInput = forwardRef(
  function HvTagsInput2(props, ref) {
    const {
      classes: classesProp,
      className,
      id,
      name,
      value: valueProp,
      defaultValue = [],
      readOnly,
      disabled,
      required,
      label: textAreaLabel,
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      description,
      "aria-describedby": ariaDescribedBy,
      onChange,
      onAdd,
      onDelete,
      onBlur,
      onFocus,
      placeholder,
      endAdornment,
      hideCounter,
      middleCountLabel = "/",
      maxTagsQuantity,
      resizable,
      inputProps,
      countCharProps,
      multiline,
      status,
      statusMessage,
      validationMessages,
      commitTagOn = ["Enter"],
      commitOnBlur,
      suggestionListCallback,
      suggestionValidation,
      suggestionsLoose,
      ...others
    } = useDefaultProps("HvTagsInput", props);
    const { classes, cx } = useClasses(classesProp);
    const elementId = useUniqueId(id);
    const hasLabel = textAreaLabel != null;
    const hasDescription = description != null;
    const [value, setValue] = useControlled(valueProp, defaultValue);
    const [validationState, setValidationState] = useControlled(
      status,
      "standBy"
    );
    const [validationMessage, setValidationMessage] = useControlled(
      statusMessage,
      ""
    );
    const [stateValid, setStateValid] = useState(true);
    const inputRef = useRef(null);
    const containerRef = useRef(null);
    const skipReset = useRef(false);
    const blurTimeout = useRef();
    const focusUtils = useFocus({ containerRef });
    const forkedContainerRef = useForkRef(ref, containerRef);
    const hasCounter = maxTagsQuantity != null && !hideCounter;
    const [suggestionValues, setSuggestionValues] = useState(null);
    const isStateInvalid = useMemo(() => {
      return hasCounter && value.length > maxTagsQuantity;
    }, [hasCounter, maxTagsQuantity, value.length]);
    const canShowSuggestions = suggestionListCallback != null;
    const hasSuggestions = !!suggestionValues;
    const errorMessages = useMemo(
      () => ({ ...DEFAULT_ERROR_MESSAGES, ...validationMessages }),
      [validationMessages]
    );
    const performValidation = useCallback(
      (currValue) => {
        if (maxTagsQuantity !== null && maxTagsQuantity !== void 0 && currValue.length > maxTagsQuantity) {
          setValidationState(validationStates.invalid);
          setValidationMessage(errorMessages.maxCharError);
          setStateValid(false);
        } else {
          setValidationState(validationStates.valid);
          setValidationMessage("");
          setStateValid(true);
        }
      },
      [
        errorMessages.maxCharError,
        maxTagsQuantity,
        setValidationMessage,
        setValidationState
      ]
    );
    const deleteTag = useCallback(
      (tagPos, event, refocus = false) => {
        const newTagsArr = [
          ...value.slice(0, tagPos),
          ...value.slice(tagPos + 1)
        ];
        setValue(newTagsArr);
        if (refocus) {
          setTimeout(() => focusUtils.focusChild(tagPos), 10);
        }
        performValidation(newTagsArr);
        onDelete?.(event, value[tagPos], tagPos);
        onChange?.(event, newTagsArr);
        skipReset.current = true;
      },
      [focusUtils, onChange, onDelete, performValidation, setValue, value]
    );
    const addTag = useCallback(
      (event, tagInput) => {
        event.preventDefault();
        const tag = tagInput ?? inputRef.current?.value ?? "";
        if (tag === "") return;
        const newTag = { label: tag, type: "semantic" };
        const newTagsArr = [...value, newTag];
        setValue(newTagsArr);
        performValidation(newTagsArr);
        onAdd?.(event, newTag, newTagsArr.length - 1);
        onChange?.(event, newTagsArr);
        inputRef.current.value = "";
      },
      [onAdd, onChange, performValidation, setValue, value]
    );
    const canShowError = status !== void 0 && status === "invalid" && statusMessage !== void 0 || !stateValid;
    useEffect(() => {
      if (skipReset.current || !inputRef.current) return;
      inputRef.current.value = "";
      skipReset.current = false;
    }, [value]);
    const isMounted = useIsMounted();
    const focusInput = () => {
      inputRef.current?.focus();
    };
    const getSuggestions = useCallback(
      (li) => {
        const listEl = document.getElementById(
          setId(elementId, "suggestions-list") || ""
        );
        return li != null ? listEl?.getElementsByTagName("li")?.[li] : listEl;
      },
      [elementId]
    );
    const suggestionClearHandler = useCallback(() => {
      if (isMounted.current) {
        setSuggestionValues(null);
      }
    }, [isMounted]);
    const suggestionHandler = useCallback(
      (val) => {
        const suggestionsArray = suggestionListCallback?.(val);
        if (suggestionsArray?.[0]?.label) {
          setSuggestionValues(suggestionsArray);
        } else {
          suggestionClearHandler();
        }
      },
      [suggestionClearHandler, suggestionListCallback]
    );
    const suggestionSelectedHandler = (event, item) => {
      addTag(event, item.value || String(item.label));
      focusInput();
      suggestionClearHandler();
    };
    const onSuggestionKeyDown = (event) => {
      if (isKey(event, "Esc")) {
        suggestionClearHandler();
        focusInput();
      } else if (isKey(event, "Tab")) {
        suggestionClearHandler();
      }
    };
    const onChangeHandler = useCallback(
      (event) => {
        if (canShowSuggestions) {
          suggestionHandler(event.target.value);
        }
      },
      [canShowSuggestions, suggestionHandler]
    );
    const onInputKeyDownHandler = useCallback(
      (event) => {
        if (!canShowSuggestions && commitTagOn.includes(event.code)) {
          addTag(event);
        }
      },
      [addTag, canShowSuggestions, commitTagOn]
    );
    const onKeyDownHandler = useCallback(
      (event) => {
        const tagInput = inputRef.current?.value || "";
        if (tagInput === "") {
          switch (event.code) {
            case "ArrowLeft":
              focusUtils.focusPrevious();
              return;
            case "ArrowRight":
              focusUtils.focusNext();
              return;
            case "End":
              focusUtils.focusLast();
              return;
            case "Home":
              focusUtils.focusFirst();
              return;
            case "Backspace":
            case "Delete": {
              if (document.activeElement === inputRef.current) {
                deleteTag(value.length - 1, event);
              }
              return;
            }
            default:
              return;
          }
        }
        switch (event.code) {
          case "ArrowDown":
            getSuggestions(0)?.focus();
            return;
          case "Enter":
            if (canShowSuggestions && suggestionsLoose && (suggestionValidation?.(tagInput) || !suggestionValidation)) {
              addTag(event);
              focusInput();
              suggestionClearHandler();
            }
            return;
          default:
            return;
        }
      },
      [
        addTag,
        canShowSuggestions,
        deleteTag,
        focusUtils,
        getSuggestions,
        suggestionClearHandler,
        suggestionValidation,
        suggestionsLoose,
        value.length
      ]
    );
    const onDeleteTagHandler = useCallback(
      (event, i) => {
        deleteTag(i, event, true);
        setValidationState(validationStates.standBy);
      },
      [deleteTag, setValidationState]
    );
    const onContainerClickHandler = useCallback(() => {
      inputRef.current?.focus();
      clearTimeout(blurTimeout.current);
    }, []);
    const onBlurHandler = (evt) => {
      blurTimeout.current = setTimeout(() => {
        if (commitOnBlur) {
          addTag(evt);
        }
        onBlur?.(evt, inputRef.current?.value || "");
      }, 10);
    };
    const onFocusHandler = (evt) => {
      clearTimeout(blurTimeout.current);
      onFocus?.(evt, inputRef.current?.value || "");
    };
    return /* @__PURE__ */ jsxs(
      HvFormElement,
      {
        id,
        name,
        disabled,
        readOnly,
        status: validationState,
        required,
        onBlur: onBlurHandler,
        onFocus: onFocusHandler,
        className: cx(
          classes.root,
          {
            [classes.disabled]: disabled,
            [classes.readOnly]: readOnly
          },
          className
        ),
        children: [
          (hasLabel || hasDescription) && /* @__PURE__ */ jsxs("div", { className: classes.labelContainer, children: [
            hasLabel && /* @__PURE__ */ jsx(
              HvLabel,
              {
                showGutter: true,
                className: classes.label,
                id: setId(id, "label"),
                htmlFor: setId(elementId, "input"),
                label: textAreaLabel
              }
            ),
            hasDescription && /* @__PURE__ */ jsx(
              HvInfoMessage,
              {
                className: classes.description,
                id: setId(elementId, "description"),
                children: description
              }
            )
          ] }),
          hasCounter && /* @__PURE__ */ jsx(
            HvCharCounter,
            {
              id: setId(elementId, "charCounter"),
              className: classes.characterCounter,
              separator: middleCountLabel,
              currentCharQuantity: value.length,
              maxCharQuantity: maxTagsQuantity,
              ...countCharProps
            }
          ),
          /* @__PURE__ */ jsxs(
            "div",
            {
              ref: forkedContainerRef,
              className: cx(classes.tagsList, {
                [classes.error]: canShowError,
                [classes.resizable]: resizable && multiline,
                [classes.invalid]: isStateInvalid,
                [classes.singleLine]: !multiline
              }),
              onKeyDown: onKeyDownHandler,
              onClick: onContainerClickHandler,
              children: [
                value?.map((t, i) => {
                  const tag = typeof t === "string" ? { label: t, type: "semantic" } : t;
                  const { label, type, ...otherProps } = tag;
                  return /* @__PURE__ */ jsx(
                    HvTag,
                    {
                      type,
                      label,
                      disabled,
                      tabIndex: -1,
                      className: cx(classes.chipRoot, classes.listItemRoot),
                      ...!(readOnly || disabled || type === "categorical") && {
                        onDelete: (event) => onDeleteTagHandler(event, i)
                      },
                      ...otherProps
                    },
                    `${label}-${i}`
                  );
                }),
                !disabled && !readOnly && /* @__PURE__ */ jsx(
                  "input",
                  {
                    id: setId(elementId, "input"),
                    onChange: onChangeHandler,
                    autoComplete: "off",
                    onKeyDown: onInputKeyDownHandler,
                    placeholder: value.length === 0 ? placeholder : "",
                    className: cx(
                      classes.tagInputContainerRoot,
                      classes.tagInputRoot,
                      classes.input
                    ),
                    ref: inputRef,
                    "aria-label": ariaLabel,
                    "aria-labelledby": ariaLabelledBy,
                    "aria-describedby": ariaDescribedBy ?? (description ? setId(elementId, "description") : void 0),
                    ...inputProps,
                    ...others
                  }
                ),
                !disabled && !readOnly && endAdornment
              ]
            }
          ),
          canShowSuggestions && /* @__PURE__ */ jsxs(Fragment, { children: [
            hasSuggestions && /* @__PURE__ */ jsx("div", { role: "presentation", className: classes.inputExtension }),
            /* @__PURE__ */ jsx(
              HvSuggestions,
              {
                id: setId(elementId, "suggestions"),
                classes: {
                  root: classes.suggestionsContainer,
                  list: classes.suggestionList
                },
                open: hasSuggestions,
                anchorEl: containerRef?.current,
                onClose: suggestionClearHandler,
                onKeyDown: onSuggestionKeyDown,
                onSuggestionSelected: suggestionSelectedHandler,
                suggestionValues
              }
            )
          ] }),
          canShowError && /* @__PURE__ */ jsx(
            HvWarningText,
            {
              id: setId(elementId, "error"),
              disableBorder: true,
              className: classes.error,
              children: validationMessage
            }
          )
        ]
      }
    );
  }
);
export {
  HvTagsInput,
  staticClasses as tagsInputClasses
};
