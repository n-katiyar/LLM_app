{"version":3,"file":"validations.js","sources":["../../../src/BaseInput/validations.ts"],"sourcesContent":["import { InputBaseComponentProps } from \"@mui/material/InputBase\";\n\nimport { validationStates } from \"../FormElement\";\n\n/** Checks if the value is a number. */\nconst isNumeric = (num: string) =>\n  // to prevent Number( <spaces> ) = 0\n  num.trim().length > 0 && !Number.isNaN(Number(num));\n\n/** Checks if the value is an email */\nconst isEmail = (email: string) => {\n  const regexp =\n    /^[^\\\\s]+[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?[.])+[a-z0-9](?:[a-z0-9-]*[a-z0-9])$/i;\n  return regexp.test(email);\n};\n\nexport const validationTypes = Object.freeze({\n  none: \"none\",\n  number: \"number\",\n  email: \"email\",\n});\n\n/** Returns the input's validation type based in the type of the input. */\nexport const computeValidationType = (type: React.HTMLInputTypeAttribute) => {\n  switch (type) {\n    case \"number\":\n      return validationTypes.number;\n    case \"email\":\n      return validationTypes.email;\n\n    default:\n      return validationTypes.none;\n  }\n};\n\n/**\n * Checks whether any integrated validation, native or not, is active.\n */\nexport const hasBuiltInValidations = (\n  required: boolean | undefined,\n  validationType: React.HTMLInputTypeAttribute,\n  minCharQuantity: number | null | undefined,\n  maxCharQuantity: number | null | undefined,\n  validation?: (value: string) => boolean,\n  inputProps?: InputBaseComponentProps,\n) =>\n  required ||\n  validationType !== validationTypes.none ||\n  minCharQuantity != null ||\n  maxCharQuantity != null ||\n  validation != null ||\n  inputProps?.required != null ||\n  inputProps?.minLength != null ||\n  inputProps?.maxLength != null ||\n  inputProps?.min != null ||\n  inputProps?.max != null ||\n  (inputProps?.type != null &&\n    inputProps?.type !== \"text\" &&\n    inputProps?.type !== \"password\") ||\n  inputProps?.pattern != null;\n\n/** Returns the form element's validation state based in the validity state of the input. */\nexport const computeValidationState = (\n  inputValidity: HvInputValidity,\n  isEmptyValue: boolean,\n) => {\n  // to keep 2.x behaviour,\n  // consider that if the value is empty (and not required) we're returning to the standBy state.\n  // might not make sense, as it makes impossible to say if the user explicitly cleared the input.\n  if (inputValidity.valid && isEmptyValue) {\n    return validationStates.standBy;\n  }\n\n  return inputValidity.valid\n    ? validationStates.valid\n    : validationStates.invalid;\n};\n\n/**\n * Returns a error message based in the validity state of the input.\n *\n * Only one error message is returned even if multiple validations fail.\n * Also, only required, minCharQuantity, maxCharQuantity and validationType have specific error messages.\n *\n * For further customization both status and statusMessage should be controlled and\n * set using the onBlur callback that receives both the value and the input validity object.\n */\nexport const computeValidationMessage = (\n  inputValidity: HvInputValidity,\n  /** The available localized error messages. */\n  errorMessages: Record<string, string>,\n) => {\n  if (inputValidity.valid) {\n    return \"\";\n  }\n\n  if (inputValidity.valueMissing) {\n    return errorMessages.requiredError;\n  }\n  if (inputValidity.tooLong) {\n    return errorMessages.maxCharError;\n  }\n  if (inputValidity.tooShort) {\n    return errorMessages.minCharError;\n  }\n  if (inputValidity.typeMismatch) {\n    return errorMessages.typeMismatchError;\n  }\n\n  return errorMessages.error;\n};\n\n/**\n * Returns a object describing the validity state of the input.\n *\n * It implements the native browser's ValidityState interface:\n * https://developer.mozilla.org/en-US/docs/Web/API/ValidityState\n */\nexport const validateInput = (\n  input: HTMLInputElement | HTMLTextAreaElement | null,\n  required: boolean | undefined,\n  minCharQuantity: any,\n  maxCharQuantity: any,\n  validationType: string,\n  validation?: (value: string) => boolean,\n): HvInputValidity => {\n  // bootstrap validity object using browser's built-in validation\n  const inputValidity: HvInputValidity = {\n    valid: input?.validity?.valid ?? true,\n    badInput: input?.validity?.badInput,\n    customError: input?.validity?.customError,\n    patternMismatch: input?.validity?.patternMismatch,\n    rangeOverflow: input?.validity?.rangeOverflow,\n    rangeUnderflow: input?.validity?.rangeUnderflow,\n    stepMismatch: input?.validity?.stepMismatch,\n    tooLong: input?.validity?.tooLong,\n    tooShort: input?.validity?.tooShort,\n    typeMismatch: input?.validity?.typeMismatch,\n    valueMissing: input?.validity?.valueMissing,\n  };\n\n  const value = input?.value;\n\n  if (!value) {\n    if (required) {\n      // this is redundant because we're setting the required property in the native input\n      inputValidity.valueMissing = true;\n      inputValidity.valid = false;\n    }\n  } else {\n    // we're not setting minlength and maxlength in the native input\n    // to avoid different browser's behaviours and keep the user experience consistent\n    if (minCharQuantity !== null && value.length < minCharQuantity) {\n      inputValidity.tooShort = true;\n      inputValidity.valid = false;\n    }\n\n    if (maxCharQuantity !== null && value.length > maxCharQuantity) {\n      inputValidity.tooLong = true;\n      inputValidity.valid = false;\n    }\n\n    // the validationType is used instead of type\n    // for the same reason stated above\n    switch (validationType) {\n      case validationTypes.number:\n        if (!isNumeric(value)) {\n          inputValidity.typeMismatch = true;\n          inputValidity.valid = false;\n        }\n        break;\n\n      case validationTypes.email:\n        if (!isEmail(value)) {\n          inputValidity.typeMismatch = true;\n          inputValidity.valid = false;\n        }\n        break;\n\n      default:\n    }\n\n    if (validation != null && !validation(value)) {\n      inputValidity.customError = true;\n      inputValidity.valid = false;\n    }\n  }\n\n  return inputValidity;\n};\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\nexport interface HvInputValidity extends Partial<Mutable<ValidityState>> {}\n\nexport const DEFAULT_ERROR_MESSAGES = {\n  error: \"Invalid value\",\n  requiredError: \"The value is required\",\n  minCharError: \"The value is too short\",\n  maxCharError: \"The value is too long\",\n  typeMismatchError: \"Invalid value\",\n};\n"],"names":[],"mappings":"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"}