import { validationStates } from "../FormElement/utils.js";
const isNumeric = (num) => (
  // to prevent Number( <spaces> ) = 0
  num.trim().length > 0 && !Number.isNaN(Number(num))
);
const isEmail = (email) => {
  const regexp = /^[^\\s]+[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?[.])+[a-z0-9](?:[a-z0-9-]*[a-z0-9])$/i;
  return regexp.test(email);
};
const validationTypes = Object.freeze({
  none: "none",
  number: "number",
  email: "email"
});
const computeValidationType = (type) => {
  switch (type) {
    case "number":
      return validationTypes.number;
    case "email":
      return validationTypes.email;
    default:
      return validationTypes.none;
  }
};
const hasBuiltInValidations = (required, validationType, minCharQuantity, maxCharQuantity, validation, inputProps) => required || validationType !== validationTypes.none || minCharQuantity != null || maxCharQuantity != null || validation != null || inputProps?.required != null || inputProps?.minLength != null || inputProps?.maxLength != null || inputProps?.min != null || inputProps?.max != null || inputProps?.type != null && inputProps?.type !== "text" && inputProps?.type !== "password" || inputProps?.pattern != null;
const computeValidationState = (inputValidity, isEmptyValue) => {
  if (inputValidity.valid && isEmptyValue) {
    return validationStates.standBy;
  }
  return inputValidity.valid ? validationStates.valid : validationStates.invalid;
};
const computeValidationMessage = (inputValidity, errorMessages) => {
  if (inputValidity.valid) {
    return "";
  }
  if (inputValidity.valueMissing) {
    return errorMessages.requiredError;
  }
  if (inputValidity.tooLong) {
    return errorMessages.maxCharError;
  }
  if (inputValidity.tooShort) {
    return errorMessages.minCharError;
  }
  if (inputValidity.typeMismatch) {
    return errorMessages.typeMismatchError;
  }
  return errorMessages.error;
};
const validateInput = (input, required, minCharQuantity, maxCharQuantity, validationType, validation) => {
  const inputValidity = {
    valid: input?.validity?.valid ?? true,
    badInput: input?.validity?.badInput,
    customError: input?.validity?.customError,
    patternMismatch: input?.validity?.patternMismatch,
    rangeOverflow: input?.validity?.rangeOverflow,
    rangeUnderflow: input?.validity?.rangeUnderflow,
    stepMismatch: input?.validity?.stepMismatch,
    tooLong: input?.validity?.tooLong,
    tooShort: input?.validity?.tooShort,
    typeMismatch: input?.validity?.typeMismatch,
    valueMissing: input?.validity?.valueMissing
  };
  const value = input?.value;
  if (!value) {
    if (required) {
      inputValidity.valueMissing = true;
      inputValidity.valid = false;
    }
  } else {
    if (minCharQuantity !== null && value.length < minCharQuantity) {
      inputValidity.tooShort = true;
      inputValidity.valid = false;
    }
    if (maxCharQuantity !== null && value.length > maxCharQuantity) {
      inputValidity.tooLong = true;
      inputValidity.valid = false;
    }
    switch (validationType) {
      case validationTypes.number:
        if (!isNumeric(value)) {
          inputValidity.typeMismatch = true;
          inputValidity.valid = false;
        }
        break;
      case validationTypes.email:
        if (!isEmail(value)) {
          inputValidity.typeMismatch = true;
          inputValidity.valid = false;
        }
        break;
    }
    if (validation != null && !validation(value)) {
      inputValidity.customError = true;
      inputValidity.valid = false;
    }
  }
  return inputValidity;
};
const DEFAULT_ERROR_MESSAGES = {
  error: "Invalid value",
  requiredError: "The value is required",
  minCharError: "The value is too short",
  maxCharError: "The value is too long",
  typeMismatchError: "Invalid value"
};
export {
  DEFAULT_ERROR_MESSAGES,
  computeValidationMessage,
  computeValidationState,
  computeValidationType,
  hasBuiltInValidations,
  validateInput,
  validationTypes
};
