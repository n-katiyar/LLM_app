{"version":3,"file":"TreeView.js","sources":["../../../../src/VerticalNavigation/TreeView/TreeView.tsx"],"sourcesContent":["import { forwardRef, useCallback, useMemo, useRef, useState } from \"react\";\nimport {\n  useDefaultProps,\n  type ExtractNames,\n} from \"@hitachivantara/uikit-react-utils\";\n\nimport { useControlled } from \"../../hooks/useControlled\";\nimport { useForkRef } from \"../../hooks/useForkRef\";\nimport { useUniqueId } from \"../../hooks/useUniqueId\";\nimport { DescendantProvider } from \"../../TreeView/internals/DescendantProvider\";\nimport { HvBaseProps } from \"../../types/generic\";\nimport { staticClasses, useClasses } from \"./TreeView.styles\";\nimport {\n  NavigationMode,\n  TreeViewControlContext,\n  TreeViewStateContext,\n} from \"./TreeViewContext\";\n\nexport { staticClasses as treeViewClasses };\n\nexport type HvVerticalNavigationTreeViewClasses = ExtractNames<\n  typeof useClasses\n>;\n\nexport interface HvVerticalNavigationTreeViewProps\n  extends HvBaseProps<HTMLUListElement, \"onChange\" | \"onToggle\"> {\n  /** A Jss Object used to override or extend the styles applied to the component. */\n  classes?: HvVerticalNavigationTreeViewClasses;\n  /** Modus operandi (role) of the widget instance. */\n  mode?: NavigationMode;\n  /** Enables selection. @default false */\n  selectable?: boolean;\n  /** Enables the simultaneous selection of multiple items. @default false */\n  multiSelect?: boolean;\n  /** The selected nodes' ids. When `multiSelect` is true this takes an array of strings; when false (default) a string. */\n  selected?: string[] | string;\n  /**\n   * When uncontrolled, defines the initial selected nodes' ids.\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   * @default []\n   */\n  defaultSelected?: string[] | string;\n  /** Can non-leaf nodes be collapsed / expanded. */\n  collapsible?: boolean;\n  /** Callback fired when a tree item is selected. */\n  onChange?: (\n    event: React.KeyboardEvent<HTMLUListElement>,\n    nodeId: string | string[],\n    payloads: any,\n  ) => void;\n  /** Expanded nodes' ids. */\n  expanded?: string[];\n  /** When uncontrolled, defines the initial expanded nodes' ids. @default [] */\n  defaultExpanded?: string[];\n  /** Callback fired when tree items are expanded/collapsed. */\n  onToggle?: (\n    event: React.KeyboardEvent<HTMLUListElement>,\n    nodeIds: string[],\n  ) => void;\n  /** If `true`, will allow focus on disabled items. @default false */\n  disabledItemsFocusable?: boolean;\n}\nfunction isPrintableCharacter(string: string) {\n  return string && string.length === 1 && string.match(/\\S/);\n}\n\nfunction findNextFirstChar(\n  firstChars: string[],\n  startIndex: number,\n  char: string,\n) {\n  return firstChars.slice(startIndex).findIndex((c) => c === char);\n}\n\nfunction noopSelection() {\n  return false;\n}\n\nexport const HvVerticalNavigationTreeView = forwardRef<\n  HTMLUListElement,\n  HvVerticalNavigationTreeViewProps\n>(function HvVerticalNavigationTreeView(props, ref) {\n  const {\n    id: idProp,\n    className,\n    classes: classesProp,\n    mode = \"treeview\",\n    collapsible = false,\n    expanded: expandedProp,\n    defaultExpanded = [],\n    onToggle,\n    selectable = false,\n    multiSelect: multiSelectProp = false,\n    selected: selectedProp,\n    defaultSelected = [],\n    onChange,\n    disabledItemsFocusable = false,\n    onFocus,\n    onBlur,\n    onKeyDown,\n    children,\n    ...others\n  } = useDefaultProps(\"HvVerticalNavigationTreeView\", props);\n\n  const { classes, cx } = useClasses(classesProp);\n\n  const treeviewMode = mode === \"treeview\";\n  const multiSelect = selectable && multiSelectProp;\n\n  const treeId = useUniqueId(idProp);\n  const treeRef = useRef<HTMLDivElement>(null);\n  const handleRef = useForkRef(treeRef, ref);\n\n  const [expanded, setExpandedState] = useControlled(\n    expandedProp,\n    defaultExpanded,\n  );\n\n  const [selected, setSelectedState] = useControlled(\n    selectedProp,\n    defaultSelected,\n  );\n\n  const [focusedNodeId, setFocusedNodeId] = useState<string | null>(null);\n\n  const nodeMap = useRef<Record<string, any>>({});\n\n  const firstCharMap = useRef<Record<string, any>>({});\n\n  const isExpanded = useCallback(\n    (id: string) =>\n      !collapsible ||\n      (Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false),\n    [collapsible, expanded],\n  );\n\n  const isExpandable = useCallback(\n    (id: string) =>\n      collapsible && nodeMap.current[id] && nodeMap.current[id].expandable,\n    [collapsible],\n  );\n\n  const isSelected = useCallback(\n    (id: string) =>\n      selectable &&\n      (Array.isArray(selected) ? selected.indexOf(id) !== -1 : selected === id),\n    [selectable, selected],\n  );\n\n  const isSelectable = useCallback(\n    (id: string) =>\n      selectable && nodeMap.current[id] && nodeMap.current[id].selectable,\n    [selectable],\n  );\n\n  const isDisabled = useCallback((id: string) => {\n    let node = nodeMap.current[id];\n\n    // This can be called before the node has been added to the node map.\n    if (!node) {\n      return false;\n    }\n\n    if (node.disabled) {\n      return true;\n    }\n\n    while (node.parentId != null) {\n      node = nodeMap.current[node.parentId];\n      if (node.disabled) {\n        return true;\n      }\n    }\n\n    return false;\n  }, []);\n\n  const isFocused = useCallback(\n    (id: string) => focusedNodeId === id,\n    [focusedNodeId],\n  );\n\n  const isChildSelected = useCallback(\n    // the second part of the condition is to ensure that the id we're\n    // looking at is actually of a child (ie, there's at least one \"-\")\n    (id: string) => {\n      return Array<string>()\n        .concat(selected)\n        .some((s) => s.startsWith(id) && s.includes(\"-\"));\n    },\n    [selected],\n  );\n\n  const getChildrenIds = (id: string | null) =>\n    Object.keys(nodeMap.current)\n      .map((key) => {\n        return nodeMap.current[key];\n      })\n      .filter((node) => node.parentId === id)\n      .sort((a, b) => a.index - b.index)\n      .map((child) => child.id);\n\n  const getNavigableChildrenIds = useCallback(\n    (id: string | null) => {\n      let childrenIds = getChildrenIds(id);\n\n      if (!disabledItemsFocusable) {\n        childrenIds = childrenIds.filter((node) => !isDisabled(node));\n      }\n      return childrenIds;\n    },\n    [disabledItemsFocusable, isDisabled],\n  );\n\n  const getNextNode = useCallback(\n    (id: string) => {\n      // If expanded get first child\n      if (isExpanded(id) && getNavigableChildrenIds(id).length > 0) {\n        return getNavigableChildrenIds(id)[0];\n      }\n\n      let node = nodeMap.current[id];\n      while (node != null) {\n        // Try to get next sibling\n        const siblings = getNavigableChildrenIds(node.parentId);\n        const nextSibling = siblings[siblings.indexOf(node.id) + 1];\n\n        if (nextSibling) {\n          return nextSibling;\n        }\n\n        // If the sibling does not exist, go up a level to the parent and try again.\n        node = nodeMap.current[node.parentId];\n      }\n\n      return null;\n    },\n    [getNavigableChildrenIds, isExpanded],\n  );\n\n  const getPreviousNode = (id: string) => {\n    const node = nodeMap.current[id];\n    const siblings = getNavigableChildrenIds(node.parentId);\n    const nodeIndex = siblings.indexOf(id);\n\n    if (nodeIndex === 0) {\n      return node.parentId;\n    }\n\n    let currentNode = siblings[nodeIndex - 1];\n    while (\n      isExpanded(currentNode) &&\n      getNavigableChildrenIds(currentNode).length > 0\n    ) {\n      currentNode = getNavigableChildrenIds(currentNode).pop();\n    }\n\n    return currentNode;\n  };\n\n  const getLastNode = () => {\n    let lastNode = getNavigableChildrenIds(null).pop();\n\n    while (isExpanded(lastNode)) {\n      lastNode = getNavigableChildrenIds(lastNode).pop();\n    }\n    return lastNode;\n  };\n  const getFirstNode = () => getNavigableChildrenIds(null)[0];\n  const getParent = (id: any) => nodeMap.current[id].parentId;\n\n  /**\n   * This is used to determine the start and end of a selection range so\n   * we can get the nodes between the two border nodes.\n   *\n   * It finds the nodes' common ancestor using\n   * a naive implementation of a lowest common ancestor algorithm\n   * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n   * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n   * so we can compare their indexes to work out which node comes first in a depth first search.\n   * (https://en.wikipedia.org/wiki/Depth-first_search)\n   *\n   * Another way to put it is which node is shallower in a trÃ©maux tree\n   * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n   */\n  const findOrderInTremauxTree = useCallback(\n    (nodeAId: string, nodeBId: string) => {\n      if (nodeAId === nodeBId) {\n        return [nodeAId, nodeBId];\n      }\n\n      const nodeA = nodeMap.current[nodeAId];\n      const nodeB = nodeMap.current[nodeBId];\n\n      if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n        return nodeB.parentId === nodeA.id\n          ? [nodeA.id, nodeB.id]\n          : [nodeB.id, nodeA.id];\n      }\n\n      const aFamily = [nodeA.id];\n      const bFamily = [nodeB.id];\n\n      let aAncestor = nodeA.parentId;\n      let bAncestor = nodeB.parentId;\n\n      let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n      let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n\n      let continueA = true;\n      let continueB = true;\n\n      while (!bAncestorIsCommon && !aAncestorIsCommon) {\n        if (continueA) {\n          aFamily.push(aAncestor);\n          aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n          continueA = aAncestor !== null;\n          if (!aAncestorIsCommon && continueA) {\n            aAncestor = nodeMap.current[aAncestor].parentId;\n          }\n        }\n\n        if (continueB && !aAncestorIsCommon) {\n          bFamily.push(bAncestor);\n          bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n          continueB = bAncestor !== null;\n          if (!bAncestorIsCommon && continueB) {\n            bAncestor = nodeMap.current[bAncestor].parentId;\n          }\n        }\n      }\n\n      const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n      const ancestorFamily = getChildrenIds(commonAncestor);\n\n      const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n      const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n\n      return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide)\n        ? [nodeAId, nodeBId]\n        : [nodeBId, nodeAId];\n    },\n    [],\n  );\n\n  const getNodesInRange = useCallback(\n    (nodeA: string, nodeB: string) => {\n      if (nodeA && nodeB) {\n        const [first, last] = findOrderInTremauxTree(nodeA, nodeB);\n        const nodes = [first];\n\n        let current = first;\n\n        while (current !== last) {\n          current = getNextNode(current);\n          nodes.push(current);\n        }\n\n        return nodes;\n      }\n      return [];\n    },\n    [findOrderInTremauxTree, getNextNode],\n  );\n\n  const focus = (\n    event:\n      | React.KeyboardEvent<HTMLUListElement>\n      | React.FocusEvent<HTMLUListElement>,\n    id: any,\n  ) => {\n    if (id) {\n      setFocusedNodeId(id);\n\n      if (nodeMap.current[id]?.onFocus) {\n        nodeMap.current[id].onFocus(event);\n      }\n    }\n  };\n\n  const focusNextNode = (\n    event: React.KeyboardEvent<HTMLUListElement>,\n    id: any,\n  ) => focus(event, getNextNode(id));\n  const focusPreviousNode = (\n    event: React.KeyboardEvent<HTMLUListElement>,\n    id: any,\n  ) => focus(event, getPreviousNode(id));\n  const focusFirstNode = (event: React.KeyboardEvent<HTMLUListElement>) =>\n    focus(event, getFirstNode());\n  const focusLastNode = (event: React.KeyboardEvent<HTMLUListElement>) =>\n    focus(event, getLastNode());\n\n  const focusByFirstCharacter = (\n    event: React.KeyboardEvent<HTMLUListElement>,\n    id: any,\n    char: any,\n  ) => {\n    let start;\n    let index;\n    const lowercaseChar = char.toLowerCase();\n\n    const firstCharIds: string[] = [];\n    const firstChars: string[] = [];\n    // This really only works since the ids are strings\n    Object.keys(firstCharMap.current).forEach((nodeId) => {\n      const firstChar = firstCharMap.current[nodeId];\n      const map = nodeMap.current[nodeId];\n      const visible = map.parentId ? isExpanded(map.parentId) : true;\n      const shouldBeSkipped = disabledItemsFocusable\n        ? false\n        : isDisabled(nodeId);\n\n      if (visible && !shouldBeSkipped) {\n        firstCharIds.push(nodeId);\n        firstChars.push(firstChar);\n      }\n    });\n\n    // Get start index for search based on position of currentItem\n    start = firstCharIds.indexOf(id) + 1;\n    if (start >= firstCharIds.length) {\n      start = 0;\n    }\n\n    // Check remaining slots in the menu\n    index = findNextFirstChar(firstChars, start, lowercaseChar);\n\n    // If not found in remaining slots, check from beginning\n    if (index === -1) {\n      index = findNextFirstChar(firstChars, 0, lowercaseChar);\n    }\n\n    // If match was found...\n    if (index > -1) {\n      focus(event, firstCharIds[index]);\n    }\n  };\n\n  const toggleExpansion = useCallback(\n    (event: React.KeyboardEvent<HTMLUListElement>, value = focusedNodeId) => {\n      if (!value) return;\n\n      const newExpanded = expanded.includes(value)\n        ? expanded.filter((id) => id !== value)\n        : [value].concat(expanded);\n\n      onToggle?.(event, newExpanded);\n\n      setExpandedState(newExpanded);\n    },\n    [expanded, focusedNodeId, onToggle, setExpandedState],\n  );\n\n  const expandAllSiblings = (\n    event: React.KeyboardEvent<HTMLUListElement>,\n    id: any,\n  ) => {\n    const map = nodeMap.current[id];\n    const siblings = getChildrenIds(map.parentId);\n\n    const diff = siblings.filter(\n      (child) => isExpandable(child) && !isExpanded(child),\n    );\n\n    const newExpanded = expanded.concat(diff);\n\n    if (diff.length > 0) {\n      setExpandedState(newExpanded);\n      onToggle?.(event, newExpanded);\n    }\n  };\n\n  const lastSelectedNode = useRef<HTMLDivElement | null>(null);\n  const lastSelectionWasRange = useRef(false);\n  const currentRangeSelection = useRef<HTMLDivElement[]>([]);\n\n  const isDivElement = (element: any): element is HTMLDivElement => {\n    return (element as HTMLDivElement).nodeType === 1;\n  };\n\n  const handleRangeArrowSelect = useCallback(\n    (\n      event: React.KeyboardEvent<HTMLUListElement>,\n      nodes: { start?: any; next?: any; current?: any },\n    ) => {\n      let base = Array<string>().concat(selected);\n      const { start, next, current } = nodes;\n\n      if (!next || !current) {\n        return;\n      }\n\n      if (\n        isDivElement(current) &&\n        currentRangeSelection.current.indexOf(current) === -1\n      ) {\n        currentRangeSelection.current = [];\n      }\n\n      if (lastSelectionWasRange.current) {\n        if (\n          isDivElement(next) &&\n          currentRangeSelection.current.indexOf(next) !== -1\n        ) {\n          base = base.filter((id) => id === start || id !== current);\n          currentRangeSelection.current = currentRangeSelection.current.filter(\n            (id) => id === start || id !== current,\n          );\n        } else {\n          base.push(next);\n          currentRangeSelection.current.push(next);\n        }\n      } else {\n        base.push(next);\n        currentRangeSelection.current.push(current, next);\n      }\n      onChange?.(\n        event,\n        base,\n        base.map((id) => nodeMap.current[id]?.payload),\n      );\n      setSelectedState(base);\n    },\n    [onChange, selected, setSelectedState],\n  );\n\n  const handleRangeSelect = useCallback(\n    (\n      event: React.KeyboardEvent<HTMLUListElement>,\n      nodes: { start?: any; end?: any; current?: any },\n    ) => {\n      let base = Array<string>().concat(selected);\n      const { start, end } = nodes;\n      // If last selection was a range selection ignore nodes that were selected.\n      if (lastSelectionWasRange.current) {\n        base = base.filter(\n          (id) => !currentRangeSelection.current.includes(id as any),\n        );\n      }\n\n      let range = getNodesInRange(start, end);\n      range = range.filter((node) => !isDisabled(node));\n      currentRangeSelection.current = range;\n      let newSelected = base.concat(range);\n      newSelected = newSelected.filter(\n        (id, i) => newSelected.indexOf(id) === i,\n      );\n\n      onChange?.(\n        event,\n        newSelected,\n        newSelected.map((id) => nodeMap.current[id]?.payload),\n      );\n\n      setSelectedState(newSelected);\n    },\n    [getNodesInRange, isDisabled, onChange, selected, setSelectedState],\n  );\n\n  const handleMultipleSelect = useCallback(\n    (event: React.KeyboardEvent<HTMLUListElement>, value: any) => {\n      const newSelected = selected.includes(value)\n        ? (selected as string[]).filter((id) => id !== value)\n        : [value].concat(selected);\n      onChange?.(\n        event,\n        newSelected,\n        newSelected.map((id) => nodeMap.current[id]?.payload),\n      );\n      setSelectedState(newSelected);\n    },\n    [onChange, selected, setSelectedState],\n  );\n\n  const handleSingleSelect = useCallback(\n    (event: React.KeyboardEvent<HTMLUListElement>, value: any) => {\n      const newSelected = multiSelect ? [value] : value;\n      if (onChange) {\n        const nodeValue = nodeMap.current[newSelected]?.payload;\n        onChange(event, newSelected, multiSelect ? [nodeValue] : nodeValue);\n      }\n\n      setSelectedState(newSelected);\n    },\n    [multiSelect, onChange, setSelectedState],\n  );\n\n  const selectNode = useCallback(\n    (\n      event: React.KeyboardEvent<HTMLUListElement>,\n      id: any,\n      multiple = false,\n    ) => {\n      if (id && isSelectable(id)) {\n        if (multiple) {\n          handleMultipleSelect(event, id);\n        } else {\n          handleSingleSelect(event, id);\n        }\n        lastSelectedNode.current = id;\n        lastSelectionWasRange.current = false;\n        currentRangeSelection.current = [];\n\n        return true;\n      }\n      return false;\n    },\n    [handleMultipleSelect, handleSingleSelect, isSelectable],\n  );\n\n  const selectRange = useCallback(\n    (\n      event: React.KeyboardEvent<HTMLUListElement>,\n      nodes: { start?: any; end?: any; current?: HTMLDivElement | null },\n      stacked = false,\n    ) => {\n      const { start = lastSelectedNode.current, end, current } = nodes;\n      if (stacked) {\n        handleRangeArrowSelect(event, { start, next: end, current });\n      } else if (start != null && end != null) {\n        handleRangeSelect(event, { start, end });\n      }\n      lastSelectionWasRange.current = true;\n    },\n    [handleRangeArrowSelect, handleRangeSelect],\n  );\n\n  const rangeSelectToFirst = (\n    event: React.KeyboardEvent<HTMLUListElement>,\n    id: any,\n  ) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n\n    selectRange(event, {\n      start,\n      end: getFirstNode(),\n    });\n  };\n\n  const rangeSelectToLast = (\n    event: React.KeyboardEvent<HTMLUListElement>,\n    id: any,\n  ) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n\n    selectRange(event, {\n      start,\n      end: getLastNode(),\n    });\n  };\n\n  const selectNextNode = (\n    event: React.KeyboardEvent<HTMLUListElement>,\n    id: any,\n  ) => {\n    if (!isDisabled(getNextNode(id))) {\n      selectRange(\n        event,\n        {\n          end: getNextNode(id),\n          current: id,\n        },\n        true,\n      );\n    }\n  };\n\n  const selectPreviousNode = (\n    event: React.KeyboardEvent<HTMLUListElement>,\n    id: any,\n  ) => {\n    if (!isDisabled(getPreviousNode(id))) {\n      selectRange(\n        event,\n        {\n          end: getPreviousNode(id),\n          current: id,\n        },\n        true,\n      );\n    }\n  };\n\n  const selectAllNodes = (event: React.KeyboardEvent<HTMLUListElement>) => {\n    selectRange(event, { start: getFirstNode(), end: getLastNode() });\n  };\n\n  /*\n   * Mapping Helpers\n   */\n  const registerNode = useCallback((node: any) => {\n    const {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled,\n      selectable: nodeSelectable,\n      onFocus: nodeOnFocus,\n      payload,\n    } = node;\n\n    nodeMap.current[id] = {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled,\n      selectable: nodeSelectable,\n      onFocus: nodeOnFocus,\n      payload,\n    };\n  }, []);\n\n  const unregisterNode = useCallback((id: any) => {\n    const newMap = { ...nodeMap.current };\n    delete newMap[id];\n    nodeMap.current = newMap;\n\n    setFocusedNodeId((oldFocusedNodeId) => {\n      if (\n        oldFocusedNodeId === id &&\n        treeRef.current &&\n        treeRef.current ===\n          (treeRef.current.ownerDocument || document).activeElement\n      ) {\n        return getChildrenIds(null)[0];\n      }\n      return oldFocusedNodeId;\n    });\n  }, []);\n\n  const mapFirstChar = useCallback((id: any, firstChar: any) => {\n    firstCharMap.current[id] = firstChar;\n  }, []);\n\n  const unMapFirstChar = useCallback((id: any) => {\n    const newMap = { ...firstCharMap.current };\n    delete newMap[id];\n    firstCharMap.current = newMap;\n  }, []);\n\n  /**\n   * Event handlers and Navigation\n   */\n  const handleNextArrow = (event: React.KeyboardEvent<HTMLUListElement>) => {\n    if (!focusedNodeId) return false;\n    if (isExpandable(focusedNodeId)) {\n      if (isExpanded(focusedNodeId)) {\n        focusNextNode(event, focusedNodeId);\n      } else if (!isDisabled(focusedNodeId)) {\n        toggleExpansion(event);\n      }\n    }\n    return true;\n  };\n\n  const handlePreviousArrow = (\n    event: React.KeyboardEvent<HTMLUListElement>,\n  ) => {\n    if (!focusedNodeId) return false;\n    if (isExpanded(focusedNodeId) && !isDisabled(focusedNodeId)) {\n      toggleExpansion(event, focusedNodeId);\n      return true;\n    }\n\n    const parent = getParent(focusedNodeId);\n    if (parent) {\n      focus(event, parent);\n      return true;\n    }\n    return false;\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLUListElement>) => {\n    let flag = false;\n    const { key } = event;\n\n    // If the tree is empty there will be no focused node\n    if (\n      event.altKey ||\n      event.currentTarget !== event.target ||\n      !focusedNodeId\n    ) {\n      return;\n    }\n\n    const ctrlPressed = event.ctrlKey || event.metaKey;\n    switch (key) {\n      case \" \":\n        if (isSelectable(focusedNodeId) && !isDisabled(focusedNodeId)) {\n          if (multiSelect && event.shiftKey) {\n            selectRange(event, { end: focusedNodeId });\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n        event.stopPropagation();\n        break;\n      case \"Enter\":\n        if (!isDisabled(focusedNodeId)) {\n          if (isExpandable(focusedNodeId)) {\n            toggleExpansion(event);\n            flag = true;\n          } else if (isSelectable(focusedNodeId)) {\n            if (multiSelect && event.shiftKey) {\n              selectRange(event, { end: focusedNodeId });\n              flag = true;\n            } else if (multiSelect) {\n              flag = selectNode(event, focusedNodeId, true);\n            } else {\n              flag = selectNode(event, focusedNodeId);\n            }\n          }\n        }\n        event.stopPropagation();\n        break;\n      case \"ArrowDown\":\n        if (multiSelect && event.shiftKey) {\n          selectNextNode(event, focusedNodeId);\n        }\n        focusNextNode(event, focusedNodeId);\n        flag = true;\n        break;\n      case \"ArrowUp\":\n        if (multiSelect && event.shiftKey) {\n          selectPreviousNode(event, focusedNodeId);\n        }\n        focusPreviousNode(event, focusedNodeId);\n        flag = true;\n        break;\n      case \"ArrowRight\":\n        flag = handleNextArrow(event);\n        break;\n      case \"ArrowLeft\":\n        flag = handlePreviousArrow(event);\n        break;\n      case \"Home\":\n        if (\n          multiSelect &&\n          ctrlPressed &&\n          event.shiftKey &&\n          !isDisabled(focusedNodeId)\n        ) {\n          rangeSelectToFirst(event, focusedNodeId);\n        }\n        focusFirstNode(event);\n        flag = true;\n        break;\n      case \"End\":\n        if (\n          multiSelect &&\n          ctrlPressed &&\n          event.shiftKey &&\n          !isDisabled(focusedNodeId)\n        ) {\n          rangeSelectToLast(event, focusedNodeId);\n        }\n        focusLastNode(event);\n        flag = true;\n        break;\n      default:\n        if (key === \"*\") {\n          expandAllSiblings(event, focusedNodeId);\n          flag = true;\n        } else if (multiSelect && ctrlPressed && key.toLowerCase() === \"a\") {\n          selectAllNodes(event);\n          flag = true;\n        } else if (\n          !ctrlPressed &&\n          !event.shiftKey &&\n          isPrintableCharacter(key)\n        ) {\n          focusByFirstCharacter(event, focusedNodeId, key);\n          flag = true;\n        }\n    }\n    if (flag) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n    onKeyDown?.(event);\n  };\n\n  const handleFocus = (event: React.FocusEvent<HTMLUListElement>) => {\n    // if the event bubbled (which is React specific) we don't want to steal focus\n    if (event.target === event.currentTarget) {\n      const firstSelected = Array.isArray(selected) ? selected[0] : selected;\n      focus(event, firstSelected || getNavigableChildrenIds(null)[0]);\n    }\n    onFocus?.(event);\n  };\n\n  const handleBlur = (event: React.FocusEvent<HTMLUListElement>) => {\n    setFocusedNodeId(null);\n    onBlur?.(event);\n  };\n\n  const activeDescendant =\n    focusedNodeId && nodeMap.current[focusedNodeId]\n      ? nodeMap.current[focusedNodeId].idAttribute\n      : null;\n\n  const treeControlContext = useMemo(\n    () => ({\n      treeId,\n      mode,\n      collapsible,\n      toggleExpansion,\n      multiSelect,\n      selectNode: selectable ? selectNode : noopSelection,\n      selectRange: selectable ? selectRange : noopSelection,\n      disabledItemsFocusable,\n      registerNode,\n      unregisterNode,\n      mapFirstChar,\n      unMapFirstChar,\n      focus,\n    }),\n    [\n      registerNode,\n      unregisterNode,\n      mapFirstChar,\n      unMapFirstChar,\n      toggleExpansion,\n      selectable,\n      selectNode,\n      selectRange,\n      mode,\n      collapsible,\n      multiSelect,\n      disabledItemsFocusable,\n      treeId,\n    ],\n  );\n\n  const treeStateContext = useMemo(\n    () => ({\n      isExpanded,\n      isSelected,\n      isFocused,\n      isDisabled,\n      isChildSelected,\n    }),\n    [isDisabled, isExpanded, isFocused, isSelected, isChildSelected],\n  );\n\n  return (\n    <TreeViewControlContext.Provider value={treeControlContext}>\n      <TreeViewStateContext.Provider value={treeStateContext}>\n        <DescendantProvider>\n          <ul\n            ref={handleRef}\n            id={idProp}\n            className={cx(classes.root, className)}\n            {...(treeviewMode && {\n              id: treeId,\n              role: \"tree\",\n              \"aria-multiselectable\": multiSelect,\n              \"aria-activedescendant\": activeDescendant,\n              tabIndex: 0,\n              onFocus: handleFocus,\n              onBlur: handleBlur,\n              onKeyDown: handleKeyDown,\n            })}\n            {...others}\n          >\n            {children}\n          </ul>\n        </DescendantProvider>\n      </TreeViewStateContext.Provider>\n    </TreeViewControlContext.Provider>\n  );\n});\n"],"names":["HvVerticalNavigationTreeView"],"mappings":";;;;;;;;;;AA8DA,SAAS,qBAAqB,QAAgB;AAC5C,SAAO,UAAU,OAAO,WAAW,KAAK,OAAO,MAAM,IAAI;AAC3D;AAEA,SAAS,kBACP,YACA,YACA,MACA;AACO,SAAA,WAAW,MAAM,UAAU,EAAE,UAAU,CAAC,MAAM,MAAM,IAAI;AACjE;AAEA,SAAS,gBAAgB;AAChB,SAAA;AACT;AAEO,MAAM,+BAA+B,WAG1C,SAASA,8BAA6B,OAAO,KAAK;AAC5C,QAAA;AAAA,IACJ,IAAI;AAAA,IACJ;AAAA,IACA,SAAS;AAAA,IACT,OAAO;AAAA,IACP,cAAc;AAAA,IACd,UAAU;AAAA,IACV,kBAAkB,CAAC;AAAA,IACnB;AAAA,IACA,aAAa;AAAA,IACb,aAAa,kBAAkB;AAAA,IAC/B,UAAU;AAAA,IACV,kBAAkB,CAAC;AAAA,IACnB;AAAA,IACA,yBAAyB;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG;AAAA,EAAA,IACD,gBAAgB,gCAAgC,KAAK;AAEzD,QAAM,EAAE,SAAS,OAAO,WAAW,WAAW;AAE9C,QAAM,eAAe,SAAS;AAC9B,QAAM,cAAc,cAAc;AAE5B,QAAA,SAAS,YAAY,MAAM;AAC3B,QAAA,UAAU,OAAuB,IAAI;AACrC,QAAA,YAAY,WAAW,SAAS,GAAG;AAEnC,QAAA,CAAC,UAAU,gBAAgB,IAAI;AAAA,IACnC;AAAA,IACA;AAAA,EACF;AAEM,QAAA,CAAC,UAAU,gBAAgB,IAAI;AAAA,IACnC;AAAA,IACA;AAAA,EACF;AAEA,QAAM,CAAC,eAAe,gBAAgB,IAAI,SAAwB,IAAI;AAEhE,QAAA,UAAU,OAA4B,EAAE;AAExC,QAAA,eAAe,OAA4B,EAAE;AAEnD,QAAM,aAAa;AAAA,IACjB,CAAC,OACC,CAAC,gBACA,MAAM,QAAQ,QAAQ,IAAI,SAAS,QAAQ,EAAE,MAAM,KAAK;AAAA,IAC3D,CAAC,aAAa,QAAQ;AAAA,EACxB;AAEA,QAAM,eAAe;AAAA,IACnB,CAAC,OACC,eAAe,QAAQ,QAAQ,EAAE,KAAK,QAAQ,QAAQ,EAAE,EAAE;AAAA,IAC5D,CAAC,WAAW;AAAA,EACd;AAEA,QAAM,aAAa;AAAA,IACjB,CAAC,OACC,eACC,MAAM,QAAQ,QAAQ,IAAI,SAAS,QAAQ,EAAE,MAAM,KAAK,aAAa;AAAA,IACxE,CAAC,YAAY,QAAQ;AAAA,EACvB;AAEA,QAAM,eAAe;AAAA,IACnB,CAAC,OACC,cAAc,QAAQ,QAAQ,EAAE,KAAK,QAAQ,QAAQ,EAAE,EAAE;AAAA,IAC3D,CAAC,UAAU;AAAA,EACb;AAEM,QAAA,aAAa,YAAY,CAAC,OAAe;AACzC,QAAA,OAAO,QAAQ,QAAQ,EAAE;AAG7B,QAAI,CAAC,MAAM;AACF,aAAA;AAAA,IAAA;AAGT,QAAI,KAAK,UAAU;AACV,aAAA;AAAA,IAAA;AAGF,WAAA,KAAK,YAAY,MAAM;AACrB,aAAA,QAAQ,QAAQ,KAAK,QAAQ;AACpC,UAAI,KAAK,UAAU;AACV,eAAA;AAAA,MAAA;AAAA,IACT;AAGK,WAAA;AAAA,EACT,GAAG,EAAE;AAEL,QAAM,YAAY;AAAA,IAChB,CAAC,OAAe,kBAAkB;AAAA,IAClC,CAAC,aAAa;AAAA,EAChB;AAEA,QAAM,kBAAkB;AAAA;AAAA;AAAA,IAGtB,CAAC,OAAe;AACd,aAAO,MAAc,EAClB,OAAO,QAAQ,EACf,KAAK,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,GAAG,CAAC;AAAA,IACpD;AAAA,IACA,CAAC,QAAQ;AAAA,EACX;AAEM,QAAA,iBAAiB,CAAC,OACtB,OAAO,KAAK,QAAQ,OAAO,EACxB,IAAI,CAAC,QAAQ;AACL,WAAA,QAAQ,QAAQ,GAAG;AAAA,EAAA,CAC3B,EACA,OAAO,CAAC,SAAS,KAAK,aAAa,EAAE,EACrC,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,KAAK,EAChC,IAAI,CAAC,UAAU,MAAM,EAAE;AAE5B,QAAM,0BAA0B;AAAA,IAC9B,CAAC,OAAsB;AACjB,UAAA,cAAc,eAAe,EAAE;AAEnC,UAAI,CAAC,wBAAwB;AAC3B,sBAAc,YAAY,OAAO,CAAC,SAAS,CAAC,WAAW,IAAI,CAAC;AAAA,MAAA;AAEvD,aAAA;AAAA,IACT;AAAA,IACA,CAAC,wBAAwB,UAAU;AAAA,EACrC;AAEA,QAAM,cAAc;AAAA,IAClB,CAAC,OAAe;AAEd,UAAI,WAAW,EAAE,KAAK,wBAAwB,EAAE,EAAE,SAAS,GAAG;AACrD,eAAA,wBAAwB,EAAE,EAAE,CAAC;AAAA,MAAA;AAGlC,UAAA,OAAO,QAAQ,QAAQ,EAAE;AAC7B,aAAO,QAAQ,MAAM;AAEb,cAAA,WAAW,wBAAwB,KAAK,QAAQ;AACtD,cAAM,cAAc,SAAS,SAAS,QAAQ,KAAK,EAAE,IAAI,CAAC;AAE1D,YAAI,aAAa;AACR,iBAAA;AAAA,QAAA;AAIF,eAAA,QAAQ,QAAQ,KAAK,QAAQ;AAAA,MAAA;AAG/B,aAAA;AAAA,IACT;AAAA,IACA,CAAC,yBAAyB,UAAU;AAAA,EACtC;AAEM,QAAA,kBAAkB,CAAC,OAAe;AAChC,UAAA,OAAO,QAAQ,QAAQ,EAAE;AACzB,UAAA,WAAW,wBAAwB,KAAK,QAAQ;AAChD,UAAA,YAAY,SAAS,QAAQ,EAAE;AAErC,QAAI,cAAc,GAAG;AACnB,aAAO,KAAK;AAAA,IAAA;AAGV,QAAA,cAAc,SAAS,YAAY,CAAC;AACxC,WACE,WAAW,WAAW,KACtB,wBAAwB,WAAW,EAAE,SAAS,GAC9C;AACc,oBAAA,wBAAwB,WAAW,EAAE,IAAI;AAAA,IAAA;AAGlD,WAAA;AAAA,EACT;AAEA,QAAM,cAAc,MAAM;AACxB,QAAI,WAAW,wBAAwB,IAAI,EAAE,IAAI;AAE1C,WAAA,WAAW,QAAQ,GAAG;AAChB,iBAAA,wBAAwB,QAAQ,EAAE,IAAI;AAAA,IAAA;AAE5C,WAAA;AAAA,EACT;AACA,QAAM,eAAe,MAAM,wBAAwB,IAAI,EAAE,CAAC;AAC1D,QAAM,YAAY,CAAC,OAAY,QAAQ,QAAQ,EAAE,EAAE;AAgBnD,QAAM,yBAAyB;AAAA,IAC7B,CAAC,SAAiB,YAAoB;AACpC,UAAI,YAAY,SAAS;AAChB,eAAA,CAAC,SAAS,OAAO;AAAA,MAAA;AAGpB,YAAA,QAAQ,QAAQ,QAAQ,OAAO;AAC/B,YAAA,QAAQ,QAAQ,QAAQ,OAAO;AAErC,UAAI,MAAM,aAAa,MAAM,MAAM,MAAM,aAAa,MAAM,IAAI;AAC9D,eAAO,MAAM,aAAa,MAAM,KAC5B,CAAC,MAAM,IAAI,MAAM,EAAE,IACnB,CAAC,MAAM,IAAI,MAAM,EAAE;AAAA,MAAA;AAGnB,YAAA,UAAU,CAAC,MAAM,EAAE;AACnB,YAAA,UAAU,CAAC,MAAM,EAAE;AAEzB,UAAI,YAAY,MAAM;AACtB,UAAI,YAAY,MAAM;AAEtB,UAAI,oBAAoB,QAAQ,QAAQ,SAAS,MAAM;AACvD,UAAI,oBAAoB,QAAQ,QAAQ,SAAS,MAAM;AAEvD,UAAI,YAAY;AAChB,UAAI,YAAY;AAET,aAAA,CAAC,qBAAqB,CAAC,mBAAmB;AAC/C,YAAI,WAAW;AACb,kBAAQ,KAAK,SAAS;AACF,8BAAA,QAAQ,QAAQ,SAAS,MAAM;AACnD,sBAAY,cAAc;AACtB,cAAA,CAAC,qBAAqB,WAAW;AACvB,wBAAA,QAAQ,QAAQ,SAAS,EAAE;AAAA,UAAA;AAAA,QACzC;AAGE,YAAA,aAAa,CAAC,mBAAmB;AACnC,kBAAQ,KAAK,SAAS;AACF,8BAAA,QAAQ,QAAQ,SAAS,MAAM;AACnD,sBAAY,cAAc;AACtB,cAAA,CAAC,qBAAqB,WAAW;AACvB,wBAAA,QAAQ,QAAQ,SAAS,EAAE;AAAA,UAAA;AAAA,QACzC;AAAA,MACF;AAGI,YAAA,iBAAiB,oBAAoB,YAAY;AACjD,YAAA,iBAAiB,eAAe,cAAc;AAEpD,YAAM,QAAQ,QAAQ,QAAQ,QAAQ,cAAc,IAAI,CAAC;AACzD,YAAM,QAAQ,QAAQ,QAAQ,QAAQ,cAAc,IAAI,CAAC;AAEzD,aAAO,eAAe,QAAQ,KAAK,IAAI,eAAe,QAAQ,KAAK,IAC/D,CAAC,SAAS,OAAO,IACjB,CAAC,SAAS,OAAO;AAAA,IACvB;AAAA,IACA,CAAA;AAAA,EACF;AAEA,QAAM,kBAAkB;AAAA,IACtB,CAAC,OAAe,UAAkB;AAChC,UAAI,SAAS,OAAO;AAClB,cAAM,CAAC,OAAO,IAAI,IAAI,uBAAuB,OAAO,KAAK;AACnD,cAAA,QAAQ,CAAC,KAAK;AAEpB,YAAI,UAAU;AAEd,eAAO,YAAY,MAAM;AACvB,oBAAU,YAAY,OAAO;AAC7B,gBAAM,KAAK,OAAO;AAAA,QAAA;AAGb,eAAA;AAAA,MAAA;AAET,aAAO,CAAC;AAAA,IACV;AAAA,IACA,CAAC,wBAAwB,WAAW;AAAA,EACtC;AAEM,QAAA,QAAQ,CACZ,OAGA,OACG;AACH,QAAI,IAAI;AACN,uBAAiB,EAAE;AAEnB,UAAI,QAAQ,QAAQ,EAAE,GAAG,SAAS;AAChC,gBAAQ,QAAQ,EAAE,EAAE,QAAQ,KAAK;AAAA,MAAA;AAAA,IACnC;AAAA,EAEJ;AAEM,QAAA,gBAAgB,CACpB,OACA,OACG,MAAM,OAAO,YAAY,EAAE,CAAC;AAC3B,QAAA,oBAAoB,CACxB,OACA,OACG,MAAM,OAAO,gBAAgB,EAAE,CAAC;AACrC,QAAM,iBAAiB,CAAC,UACtB,MAAM,OAAO,cAAc;AAC7B,QAAM,gBAAgB,CAAC,UACrB,MAAM,OAAO,aAAa;AAE5B,QAAM,wBAAwB,CAC5B,OACA,IACA,SACG;AACC,QAAA;AACA,QAAA;AACE,UAAA,gBAAgB,KAAK,YAAY;AAEvC,UAAM,eAAyB,CAAC;AAChC,UAAM,aAAuB,CAAC;AAE9B,WAAO,KAAK,aAAa,OAAO,EAAE,QAAQ,CAAC,WAAW;AAC9C,YAAA,YAAY,aAAa,QAAQ,MAAM;AACvC,YAAA,MAAM,QAAQ,QAAQ,MAAM;AAClC,YAAM,UAAU,IAAI,WAAW,WAAW,IAAI,QAAQ,IAAI;AAC1D,YAAM,kBAAkB,yBACpB,QACA,WAAW,MAAM;AAEjB,UAAA,WAAW,CAAC,iBAAiB;AAC/B,qBAAa,KAAK,MAAM;AACxB,mBAAW,KAAK,SAAS;AAAA,MAAA;AAAA,IAC3B,CACD;AAGO,YAAA,aAAa,QAAQ,EAAE,IAAI;AAC/B,QAAA,SAAS,aAAa,QAAQ;AACxB,cAAA;AAAA,IAAA;AAIF,YAAA,kBAAkB,YAAY,OAAO,aAAa;AAG1D,QAAI,UAAU,IAAI;AACR,cAAA,kBAAkB,YAAY,GAAG,aAAa;AAAA,IAAA;AAIxD,QAAI,QAAQ,IAAI;AACR,YAAA,OAAO,aAAa,KAAK,CAAC;AAAA,IAAA;AAAA,EAEpC;AAEA,QAAM,kBAAkB;AAAA,IACtB,CAAC,OAA8C,QAAQ,kBAAkB;AACvE,UAAI,CAAC,MAAO;AAEZ,YAAM,cAAc,SAAS,SAAS,KAAK,IACvC,SAAS,OAAO,CAAC,OAAO,OAAO,KAAK,IACpC,CAAC,KAAK,EAAE,OAAO,QAAQ;AAE3B,iBAAW,OAAO,WAAW;AAE7B,uBAAiB,WAAW;AAAA,IAC9B;AAAA,IACA,CAAC,UAAU,eAAe,UAAU,gBAAgB;AAAA,EACtD;AAEM,QAAA,oBAAoB,CACxB,OACA,OACG;AACG,UAAA,MAAM,QAAQ,QAAQ,EAAE;AACxB,UAAA,WAAW,eAAe,IAAI,QAAQ;AAE5C,UAAM,OAAO,SAAS;AAAA,MACpB,CAAC,UAAU,aAAa,KAAK,KAAK,CAAC,WAAW,KAAK;AAAA,IACrD;AAEM,UAAA,cAAc,SAAS,OAAO,IAAI;AAEpC,QAAA,KAAK,SAAS,GAAG;AACnB,uBAAiB,WAAW;AAC5B,iBAAW,OAAO,WAAW;AAAA,IAAA;AAAA,EAEjC;AAEM,QAAA,mBAAmB,OAA8B,IAAI;AACrD,QAAA,wBAAwB,OAAO,KAAK;AACpC,QAAA,wBAAwB,OAAyB,EAAE;AAEnD,QAAA,eAAe,CAAC,YAA4C;AAChE,WAAQ,QAA2B,aAAa;AAAA,EAClD;AAEA,QAAM,yBAAyB;AAAA,IAC7B,CACE,OACA,UACG;AACH,UAAI,OAAO,QAAgB,OAAO,QAAQ;AAC1C,YAAM,EAAE,OAAO,MAAM,QAAY,IAAA;AAE7B,UAAA,CAAC,QAAQ,CAAC,SAAS;AACrB;AAAA,MAAA;AAIA,UAAA,aAAa,OAAO,KACpB,sBAAsB,QAAQ,QAAQ,OAAO,MAAM,IACnD;AACA,8BAAsB,UAAU,CAAC;AAAA,MAAA;AAGnC,UAAI,sBAAsB,SAAS;AAE/B,YAAA,aAAa,IAAI,KACjB,sBAAsB,QAAQ,QAAQ,IAAI,MAAM,IAChD;AACA,iBAAO,KAAK,OAAO,CAAC,OAAO,OAAO,SAAS,OAAO,OAAO;AACnC,gCAAA,UAAU,sBAAsB,QAAQ;AAAA,YAC5D,CAAC,OAAO,OAAO,SAAS,OAAO;AAAA,UACjC;AAAA,QAAA,OACK;AACL,eAAK,KAAK,IAAI;AACQ,gCAAA,QAAQ,KAAK,IAAI;AAAA,QAAA;AAAA,MACzC,OACK;AACL,aAAK,KAAK,IAAI;AACQ,8BAAA,QAAQ,KAAK,SAAS,IAAI;AAAA,MAAA;AAElD;AAAA,QACE;AAAA,QACA;AAAA,QACA,KAAK,IAAI,CAAC,OAAO,QAAQ,QAAQ,EAAE,GAAG,OAAO;AAAA,MAC/C;AACA,uBAAiB,IAAI;AAAA,IACvB;AAAA,IACA,CAAC,UAAU,UAAU,gBAAgB;AAAA,EACvC;AAEA,QAAM,oBAAoB;AAAA,IACxB,CACE,OACA,UACG;AACH,UAAI,OAAO,QAAgB,OAAO,QAAQ;AACpC,YAAA,EAAE,OAAO,IAAA,IAAQ;AAEvB,UAAI,sBAAsB,SAAS;AACjC,eAAO,KAAK;AAAA,UACV,CAAC,OAAO,CAAC,sBAAsB,QAAQ,SAAS,EAAS;AAAA,QAC3D;AAAA,MAAA;AAGE,UAAA,QAAQ,gBAAgB,OAAO,GAAG;AACtC,cAAQ,MAAM,OAAO,CAAC,SAAS,CAAC,WAAW,IAAI,CAAC;AAChD,4BAAsB,UAAU;AAC5B,UAAA,cAAc,KAAK,OAAO,KAAK;AACnC,oBAAc,YAAY;AAAA,QACxB,CAAC,IAAI,MAAM,YAAY,QAAQ,EAAE,MAAM;AAAA,MACzC;AAEA;AAAA,QACE;AAAA,QACA;AAAA,QACA,YAAY,IAAI,CAAC,OAAO,QAAQ,QAAQ,EAAE,GAAG,OAAO;AAAA,MACtD;AAEA,uBAAiB,WAAW;AAAA,IAC9B;AAAA,IACA,CAAC,iBAAiB,YAAY,UAAU,UAAU,gBAAgB;AAAA,EACpE;AAEA,QAAM,uBAAuB;AAAA,IAC3B,CAAC,OAA8C,UAAe;AAC5D,YAAM,cAAc,SAAS,SAAS,KAAK,IACtC,SAAsB,OAAO,CAAC,OAAO,OAAO,KAAK,IAClD,CAAC,KAAK,EAAE,OAAO,QAAQ;AAC3B;AAAA,QACE;AAAA,QACA;AAAA,QACA,YAAY,IAAI,CAAC,OAAO,QAAQ,QAAQ,EAAE,GAAG,OAAO;AAAA,MACtD;AACA,uBAAiB,WAAW;AAAA,IAC9B;AAAA,IACA,CAAC,UAAU,UAAU,gBAAgB;AAAA,EACvC;AAEA,QAAM,qBAAqB;AAAA,IACzB,CAAC,OAA8C,UAAe;AAC5D,YAAM,cAAc,cAAc,CAAC,KAAK,IAAI;AAC5C,UAAI,UAAU;AACZ,cAAM,YAAY,QAAQ,QAAQ,WAAW,GAAG;AAChD,iBAAS,OAAO,aAAa,cAAc,CAAC,SAAS,IAAI,SAAS;AAAA,MAAA;AAGpE,uBAAiB,WAAW;AAAA,IAC9B;AAAA,IACA,CAAC,aAAa,UAAU,gBAAgB;AAAA,EAC1C;AAEA,QAAM,aAAa;AAAA,IACjB,CACE,OACA,IACA,WAAW,UACR;AACC,UAAA,MAAM,aAAa,EAAE,GAAG;AAC1B,YAAI,UAAU;AACZ,+BAAqB,OAAO,EAAE;AAAA,QAAA,OACzB;AACL,6BAAmB,OAAO,EAAE;AAAA,QAAA;AAE9B,yBAAiB,UAAU;AAC3B,8BAAsB,UAAU;AAChC,8BAAsB,UAAU,CAAC;AAE1B,eAAA;AAAA,MAAA;AAEF,aAAA;AAAA,IACT;AAAA,IACA,CAAC,sBAAsB,oBAAoB,YAAY;AAAA,EACzD;AAEA,QAAM,cAAc;AAAA,IAClB,CACE,OACA,OACA,UAAU,UACP;AACH,YAAM,EAAE,QAAQ,iBAAiB,SAAS,KAAK,YAAY;AAC3D,UAAI,SAAS;AACX,+BAAuB,OAAO,EAAE,OAAO,MAAM,KAAK,SAAS;AAAA,MAClD,WAAA,SAAS,QAAQ,OAAO,MAAM;AACvC,0BAAkB,OAAO,EAAE,OAAO,IAAA,CAAK;AAAA,MAAA;AAEzC,4BAAsB,UAAU;AAAA,IAClC;AAAA,IACA,CAAC,wBAAwB,iBAAiB;AAAA,EAC5C;AAEM,QAAA,qBAAqB,CACzB,OACA,OACG;AACC,QAAA,CAAC,iBAAiB,SAAS;AAC7B,uBAAiB,UAAU;AAAA,IAAA;AAG7B,UAAM,QAAQ,sBAAsB,UAAU,iBAAiB,UAAU;AAEzE,gBAAY,OAAO;AAAA,MACjB;AAAA,MACA,KAAK,aAAa;AAAA,IAAA,CACnB;AAAA,EACH;AAEM,QAAA,oBAAoB,CACxB,OACA,OACG;AACC,QAAA,CAAC,iBAAiB,SAAS;AAC7B,uBAAiB,UAAU;AAAA,IAAA;AAG7B,UAAM,QAAQ,sBAAsB,UAAU,iBAAiB,UAAU;AAEzE,gBAAY,OAAO;AAAA,MACjB;AAAA,MACA,KAAK,YAAY;AAAA,IAAA,CAClB;AAAA,EACH;AAEM,QAAA,iBAAiB,CACrB,OACA,OACG;AACH,QAAI,CAAC,WAAW,YAAY,EAAE,CAAC,GAAG;AAChC;AAAA,QACE;AAAA,QACA;AAAA,UACE,KAAK,YAAY,EAAE;AAAA,UACnB,SAAS;AAAA,QACX;AAAA,QACA;AAAA,MACF;AAAA,IAAA;AAAA,EAEJ;AAEM,QAAA,qBAAqB,CACzB,OACA,OACG;AACH,QAAI,CAAC,WAAW,gBAAgB,EAAE,CAAC,GAAG;AACpC;AAAA,QACE;AAAA,QACA;AAAA,UACE,KAAK,gBAAgB,EAAE;AAAA,UACvB,SAAS;AAAA,QACX;AAAA,QACA;AAAA,MACF;AAAA,IAAA;AAAA,EAEJ;AAEM,QAAA,iBAAiB,CAAC,UAAiD;AAC3D,gBAAA,OAAO,EAAE,OAAO,aAAA,GAAgB,KAAK,YAAA,GAAe;AAAA,EAClE;AAKM,QAAA,eAAe,YAAY,CAAC,SAAc;AACxC,UAAA;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,SAAS;AAAA,MACT;AAAA,IAAA,IACE;AAEI,YAAA,QAAQ,EAAE,IAAI;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAY;AAAA,MACZ,SAAS;AAAA,MACT;AAAA,IACF;AAAA,EACF,GAAG,EAAE;AAEC,QAAA,iBAAiB,YAAY,CAAC,OAAY;AAC9C,UAAM,SAAS,EAAE,GAAG,QAAQ,QAAQ;AACpC,WAAO,OAAO,EAAE;AAChB,YAAQ,UAAU;AAElB,qBAAiB,CAAC,qBAAqB;AAEnC,UAAA,qBAAqB,MACrB,QAAQ,WACR,QAAQ,aACL,QAAQ,QAAQ,iBAAiB,UAAU,eAC9C;AACO,eAAA,eAAe,IAAI,EAAE,CAAC;AAAA,MAAA;AAExB,aAAA;AAAA,IAAA,CACR;AAAA,EACH,GAAG,EAAE;AAEL,QAAM,eAAe,YAAY,CAAC,IAAS,cAAmB;AAC/C,iBAAA,QAAQ,EAAE,IAAI;AAAA,EAC7B,GAAG,EAAE;AAEC,QAAA,iBAAiB,YAAY,CAAC,OAAY;AAC9C,UAAM,SAAS,EAAE,GAAG,aAAa,QAAQ;AACzC,WAAO,OAAO,EAAE;AAChB,iBAAa,UAAU;AAAA,EACzB,GAAG,EAAE;AAKC,QAAA,kBAAkB,CAAC,UAAiD;AACpE,QAAA,CAAC,cAAsB,QAAA;AACvB,QAAA,aAAa,aAAa,GAAG;AAC3B,UAAA,WAAW,aAAa,GAAG;AAC7B,sBAAc,OAAO,aAAa;AAAA,MAAA,WACzB,CAAC,WAAW,aAAa,GAAG;AACrC,wBAAgB,KAAK;AAAA,MAAA;AAAA,IACvB;AAEK,WAAA;AAAA,EACT;AAEM,QAAA,sBAAsB,CAC1B,UACG;AACC,QAAA,CAAC,cAAsB,QAAA;AAC3B,QAAI,WAAW,aAAa,KAAK,CAAC,WAAW,aAAa,GAAG;AAC3D,sBAAgB,OAAO,aAAa;AAC7B,aAAA;AAAA,IAAA;AAGH,UAAA,SAAS,UAAU,aAAa;AACtC,QAAI,QAAQ;AACV,YAAM,OAAO,MAAM;AACZ,aAAA;AAAA,IAAA;AAEF,WAAA;AAAA,EACT;AAEM,QAAA,gBAAgB,CAAC,UAAiD;AACtE,QAAI,OAAO;AACL,UAAA,EAAE,QAAQ;AAGhB,QACE,MAAM,UACN,MAAM,kBAAkB,MAAM,UAC9B,CAAC,eACD;AACA;AAAA,IAAA;AAGI,UAAA,cAAc,MAAM,WAAW,MAAM;AAC3C,YAAQ,KAAK;AAAA,MACX,KAAK;AACH,YAAI,aAAa,aAAa,KAAK,CAAC,WAAW,aAAa,GAAG;AACzD,cAAA,eAAe,MAAM,UAAU;AACjC,wBAAY,OAAO,EAAE,KAAK,cAAA,CAAe;AAClC,mBAAA;AAAA,qBACE,aAAa;AACf,mBAAA,WAAW,OAAO,eAAe,IAAI;AAAA,UAAA,OACvC;AACE,mBAAA,WAAW,OAAO,aAAa;AAAA,UAAA;AAAA,QACxC;AAEF,cAAM,gBAAgB;AACtB;AAAA,MACF,KAAK;AACC,YAAA,CAAC,WAAW,aAAa,GAAG;AAC1B,cAAA,aAAa,aAAa,GAAG;AAC/B,4BAAgB,KAAK;AACd,mBAAA;AAAA,UAAA,WACE,aAAa,aAAa,GAAG;AAClC,gBAAA,eAAe,MAAM,UAAU;AACjC,0BAAY,OAAO,EAAE,KAAK,cAAA,CAAe;AAClC,qBAAA;AAAA,uBACE,aAAa;AACf,qBAAA,WAAW,OAAO,eAAe,IAAI;AAAA,YAAA,OACvC;AACE,qBAAA,WAAW,OAAO,aAAa;AAAA,YAAA;AAAA,UACxC;AAAA,QACF;AAEF,cAAM,gBAAgB;AACtB;AAAA,MACF,KAAK;AACC,YAAA,eAAe,MAAM,UAAU;AACjC,yBAAe,OAAO,aAAa;AAAA,QAAA;AAErC,sBAAc,OAAO,aAAa;AAC3B,eAAA;AACP;AAAA,MACF,KAAK;AACC,YAAA,eAAe,MAAM,UAAU;AACjC,6BAAmB,OAAO,aAAa;AAAA,QAAA;AAEzC,0BAAkB,OAAO,aAAa;AAC/B,eAAA;AACP;AAAA,MACF,KAAK;AACH,eAAO,gBAAgB,KAAK;AAC5B;AAAA,MACF,KAAK;AACH,eAAO,oBAAoB,KAAK;AAChC;AAAA,MACF,KAAK;AACH,YACE,eACA,eACA,MAAM,YACN,CAAC,WAAW,aAAa,GACzB;AACA,6BAAmB,OAAO,aAAa;AAAA,QAAA;AAEzC,uBAAe,KAAK;AACb,eAAA;AACP;AAAA,MACF,KAAK;AACH,YACE,eACA,eACA,MAAM,YACN,CAAC,WAAW,aAAa,GACzB;AACA,4BAAkB,OAAO,aAAa;AAAA,QAAA;AAExC,sBAAc,KAAK;AACZ,eAAA;AACP;AAAA,MACF;AACE,YAAI,QAAQ,KAAK;AACf,4BAAkB,OAAO,aAAa;AAC/B,iBAAA;AAAA,QAAA,WACE,eAAe,eAAe,IAAI,YAAA,MAAkB,KAAK;AAClE,yBAAe,KAAK;AACb,iBAAA;AAAA,QAAA,WAEP,CAAC,eACD,CAAC,MAAM,YACP,qBAAqB,GAAG,GACxB;AACsB,gCAAA,OAAO,eAAe,GAAG;AACxC,iBAAA;AAAA,QAAA;AAAA,IACT;AAEJ,QAAI,MAAM;AACR,YAAM,eAAe;AACrB,YAAM,gBAAgB;AAAA,IAAA;AAExB,gBAAY,KAAK;AAAA,EACnB;AAEM,QAAA,cAAc,CAAC,UAA8C;AAE7D,QAAA,MAAM,WAAW,MAAM,eAAe;AACxC,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,YAAM,OAAO,iBAAiB,wBAAwB,IAAI,EAAE,CAAC,CAAC;AAAA,IAAA;AAEhE,cAAU,KAAK;AAAA,EACjB;AAEM,QAAA,aAAa,CAAC,UAA8C;AAChE,qBAAiB,IAAI;AACrB,aAAS,KAAK;AAAA,EAChB;AAEM,QAAA,mBACJ,iBAAiB,QAAQ,QAAQ,aAAa,IAC1C,QAAQ,QAAQ,aAAa,EAAE,cAC/B;AAEN,QAAM,qBAAqB;AAAA,IACzB,OAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAY,aAAa,aAAa;AAAA,MACtC,aAAa,aAAa,cAAc;AAAA,MACxC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,IAEF;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,EAEJ;AAEA,QAAM,mBAAmB;AAAA,IACvB,OAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,IAEF,CAAC,YAAY,YAAY,WAAW,YAAY,eAAe;AAAA,EACjE;AAEA,SACG,oBAAA,uBAAuB,UAAvB,EAAgC,OAAO,oBACtC,UAAC,oBAAA,qBAAqB,UAArB,EAA8B,OAAO,kBACpC,8BAAC,oBACC,EAAA,UAAA;AAAA,IAAC;AAAA,IAAA;AAAA,MACC,KAAK;AAAA,MACL,IAAI;AAAA,MACJ,WAAW,GAAG,QAAQ,MAAM,SAAS;AAAA,MACpC,GAAI,gBAAgB;AAAA,QACnB,IAAI;AAAA,QACJ,MAAM;AAAA,QACN,wBAAwB;AAAA,QACxB,yBAAyB;AAAA,QACzB,UAAU;AAAA,QACV,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,WAAW;AAAA,MACb;AAAA,MACC,GAAG;AAAA,MAEH;AAAA,IAAA;AAAA,EAAA,EAEL,CAAA,EACF,CAAA,GACF;AAEJ,CAAC;"}