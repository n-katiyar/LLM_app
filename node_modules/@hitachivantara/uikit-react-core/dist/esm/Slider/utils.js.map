{"version":3,"file":"utils.js","sources":["../../../src/Slider/utils.ts"],"sourcesContent":["import { theme } from \"@hitachivantara/uikit-styles\";\n\nimport { HvFormStatus, validationStates } from \"../FormElement\";\nimport { sliderStyles as styles } from \"./Slider.styles\";\nimport { HvKnobProperty, HvMarkProperty } from \"./types\";\n\n/**\n * Transform the scaled values into knobs positions.\n *\n * @param {*} sliderValue - he value of the slider to be scaled\n * @param {*} minPointVlue - The value of the first point in the slider from left to right.\n * @param {*} stepVlue - The calculated separation between the values of the slider.\n */\nexport const knobsPositionToScaledValue = (\n  sliderValue: number,\n  minPointValue: number,\n  stepValue: number,\n): number => minPointValue + stepValue * sliderValue;\n\n/**\n * Transform the scaled values into knobs positions.\n *\n * @param {*} scaledValue - The value of the slider to be scaled\n * @param {*} minPointValue - The value of the first point in\n * the slider from left to right.\n * @param {*} inverseStepValue - The inverse of calculated separation between\n * the value of the points that compose the slider.\n */\nexport const scaledValueToKnobsPositionValue = (\n  scaledValue: number | undefined,\n  minPointValue: number,\n  inverseStepValue: number,\n): number =>\n  typeof scaledValue === \"number\"\n    ? Math.floor((scaledValue - minPointValue) * inverseStepValue)\n    : NaN;\n\n/**\n * Transform the received knobs values into knob positions\n *\n * @param {Object} values - The values of the slider.\n * @param {Number} inverseStepValue - The inverse of calculated separation between\n * the value of the points that compose the slider.\n * @param {Integer} minPointValue - The value of the first point in the slider from\n * left to right.\n * @returns {Array} - The position of the knobs.\n */\nexport const knobsValuesToKnobsPositions = (\n  values: (number | undefined)[],\n  inverseStepValue: number,\n  minPointValue: number,\n): number[] => {\n  const knobsPositions: number[] = [];\n\n  values.forEach((value, index) => {\n    knobsPositions[index] = scaledValueToKnobsPositionValue(\n      value,\n      minPointValue,\n      inverseStepValue,\n    );\n  });\n\n  return knobsPositions;\n};\n\n/**\n * Transform the received knobs positions into knob values\n *\n * @param {Object} knobPositions - The values of the slider.\n * @param {Number} stepValue - The calculated separation between\n * the value of the points that compose the slider.\n * @param {Integer} minPointValue - The value of the first point in the slider from\n * left to right.\n * @returns {Array} - The position of the knobs.\n */\nexport const knobsPositionsToKnobsValues = (\n  knobPositions: number[],\n  stepValue: number,\n  minPointValue: number,\n): number[] => {\n  const knobsValues: number[] = [];\n\n  knobPositions.forEach((value, index) => {\n    knobsValues[index] = knobsPositionToScaledValue(\n      value,\n      minPointValue,\n      stepValue,\n    );\n  });\n\n  return knobsValues;\n};\n\n/**\n * Calculates the separation between each value in the slider.\n *\n * @param {*} maxPointValue - The value of the last point in the slider from left to right.\n * @param {*} minPointValue - The value of the first point in the slider from left to right.\n * @param {*} divisionQuantity - How many subdivisions there are in the slider.\n */\nexport const calculateStepValue = (\n  maxPointValue: number,\n  minPointValue: number,\n  divisionQuantity: number,\n): number => Math.abs(maxPointValue - minPointValue) / divisionQuantity;\n\n/**\n * Generates the inline styles used for the track of each knob, applying colors if necessary.\n *\n * @param {Object} markProperties - The object provided by the user with\n * the desired configuration for the marks.\n * @param {Integer} markStep - The separation between marks.\n * @param {Integer} divisionQuantity - How many subdivisions there are in the slider.\n * @param {Integer} minPointValue - The value of the first point in the slider from\n * left to right.\n * @param {Integer} stepValue - The calculated separation between the values of the slider.\n * @param {Integer} markDigits - How many decimals the mark will show.\n * @param {Function} formatMark - A function provided by the user that is going to\n * be executed to format the mark text.\n * @param {Object} styles - the default styles for the marks.\n * @returns {Object} - An object with the for the marks.\n * @memberof HvSlider\n */\nexport const createMark = (\n  markProperties: HvMarkProperty[],\n  markStep: number,\n  divisionQuantity: number,\n  minPointValue: number,\n  maxPointValue: number,\n  stepValue: number,\n  markDigits: number,\n  disabled: boolean,\n  formatMark: (label: React.ReactNode) => React.ReactNode = (mark) => mark,\n): Record<number, { label: string; style: React.CSSProperties }> => {\n  const marks: Record<number, { label: string; style: React.CSSProperties }> =\n    {};\n\n  const values: string[] = [];\n\n  if (markProperties.length > 0) {\n    markProperties.forEach((markProperty) => {\n      if (typeof markProperty.position === \"number\") {\n        marks[markProperty.position] = disabled\n          ? {\n              label: `${markProperty.label}`,\n              style: {\n                ...styles.disabledMark,\n              },\n            }\n          : {\n              label: `${markProperty.label}`,\n              style: {\n                ...styles.mark,\n              },\n            };\n      }\n    });\n  } else {\n    const roundedMarkStep = Math.max(1, Math.floor(markStep));\n\n    for (let index = 0; index <= divisionQuantity; index += roundedMarkStep) {\n      let labelValue: React.ReactNode = knobsPositionToScaledValue(\n        index,\n        minPointValue,\n        stepValue,\n      ).toFixed(Math.max(0, Math.min(8, markDigits)));\n\n      values.push(labelValue as string);\n      labelValue = formatMark?.(labelValue) || labelValue;\n\n      marks[index] = disabled\n        ? {\n            label: `${labelValue}`,\n            style: {\n              ...styles.disabledMark,\n            },\n          }\n        : {\n            label: `${labelValue}`,\n            style: {\n              ...styles.mark,\n            },\n          };\n    }\n\n    if (!values.includes(maxPointValue.toString())) {\n      const lastMarkPosition = knobsValuesToKnobsPositions(\n        [maxPointValue],\n        1 / stepValue,\n        minPointValue,\n      );\n\n      const lastMarkLabel = formatMark?.(maxPointValue.toFixed(markDigits));\n      marks[lastMarkPosition[0]] = disabled\n        ? {\n            label: `${lastMarkLabel}`,\n            style: {\n              ...styles.disabledMark,\n            },\n          }\n        : {\n            label: `${lastMarkLabel}`,\n            style: {\n              ...styles.mark,\n            },\n          };\n    }\n  }\n\n  return marks;\n};\n\n/**\n * Generates the inline styles used for the track of each knob, applying colors if necessary.\n *\n * @param {Object} knobProperties - The object provided by the user with\n * the desired configuration for the knobs.\n * @param {Object} styles - the default styles for the tracks.\n * @returns {Object} - An object with the style for each track.\n * @memberof HvSlider\n */\nexport const createTrackStyles = (\n  knobProperties: HvKnobProperty[],\n): React.CSSProperties[] => {\n  const trackStyles: React.CSSProperties[] = [];\n\n  if (knobProperties.length > 0) {\n    knobProperties.forEach((knobProperty, index) => {\n      trackStyles[index] = { ...styles.track };\n      if (knobProperty.color) {\n        trackStyles[index].backgroundColor = knobProperty.trackColor;\n      }\n    });\n  }\n\n  return trackStyles;\n};\n\n/**\n * Generates the inline styles used for each knob, applying colors if specified.\n *\n * @param {Object} knobProperties - The object provided by the user with\n * the desired configuration for the knobs.\n * @param {Object} styles - the default styles for the knobs.\n * @returns {Object} - An object with both the inner and outer styles for the knob.\n * @memberof HvSlider\n */\nexport const createKnobStyles = (\n  knobProperties: HvKnobProperty[],\n): {\n  knobInner: React.CSSProperties[];\n  knobOuterStyle: React.CSSProperties[];\n} => {\n  const knobInner: React.CSSProperties[] = [];\n  const knobOuterStyle: React.CSSProperties[] = [];\n\n  const lastItem = knobProperties.length - 1;\n  if (knobProperties.length > 0) {\n    knobProperties.forEach((knobProperty, index) => {\n      knobInner[index] = { ...styles.knobInner };\n      knobOuterStyle[index] = { ...styles.knobOuter };\n\n      if (knobProperty.color) {\n        knobInner[index].backgroundColor = knobProperty.color;\n        knobOuterStyle[index].backgroundColor = \"transparent\";\n      }\n\n      if (knobProperty.hidden) {\n        knobInner[index] = styles.knobHidden;\n        if (index === lastItem) {\n          knobInner[index] = { ...styles.knobHiddenLast };\n          knobInner[index].backgroundColor = knobProperty.color;\n          knobOuterStyle[index] = { ...styles.knobHidden };\n          knobOuterStyle[index].backgroundColor = knobProperty.color;\n        }\n      }\n    });\n  }\n\n  return {\n    knobInner,\n    knobOuterStyle,\n  };\n};\n\n/**\n * Analyzes both the values and the default values to determine whether the slider is working in single mode.\n *\n * @param {Array} values - the values where the knobs are positioned when controlled.\n * @param {Array} defaultValues - the values where the knobs start when uncontrolled.\n * @returns {Boolean} - if true the slider should work as single slider\n */\nexport const isSingleSlider = (\n  values: number[],\n  defaultValues: (number | undefined)[],\n): boolean => {\n  if (!(values?.length > 1)) {\n    return defaultValues.length === 1;\n  }\n  return values.length === 1;\n};\n\n/**\n * Generates the default knob styles for each knob\n *\n * @param {Object} knobProperties - The object provided by the user with\n * the desired configuration for the knobs.\n * @param {Integer} numberOfKnobs - the default styles for the knobs.\n * @param {Object} theme - The theme to extract the colors.\n *\n * @returns {Object} - An object with both the inner and outer styles for the knob.\n * @memberof HvSlider\n */\nexport const generateDefaultKnobProperties = (\n  numberOfKnobs = 1,\n  disabled = false,\n  knobPropertiesProp?: HvKnobProperty[],\n): HvKnobProperty[] => {\n  let knobProperties = knobPropertiesProp || [];\n\n  const defaultKnobStyles = {\n    color: theme.colors.secondary,\n    hoverColor: theme.colors.secondary,\n    trackColor: theme.colors.secondary,\n    dragColor: theme.colors.secondary,\n    knobRingColor: theme.colors.atmo1,\n  };\n\n  const disabledKnobStyles = {\n    color: theme.colors.secondary_60,\n    hoverColor: theme.colors.secondary_60,\n    trackColor: theme.colors.secondary_60,\n    dragColor: theme.colors.secondary_60,\n    knobRingColor: theme.colors.secondary_60,\n  };\n\n  if (knobProperties.length > 0) {\n    knobProperties = knobProperties.slice(0, numberOfKnobs);\n    knobProperties = knobProperties.map((knobProperty) => {\n      if (!disabled) {\n        return {\n          ...disabledKnobStyles,\n          ...knobProperty,\n        };\n      }\n      return {\n        ...defaultKnobStyles,\n        ...knobProperty,\n      };\n    });\n  } else {\n    for (let i = 0; i < numberOfKnobs; i += 1) {\n      if (!disabled) knobProperties.push(defaultKnobStyles);\n      if (disabled) knobProperties.push(disabledKnobStyles);\n    }\n  }\n\n  return knobProperties;\n};\n\nconst pushSlider = (\n  index: number,\n  inputIndex: number,\n  inputValue: number,\n): number => {\n  const difference = index - inputIndex;\n\n  return inputValue + difference;\n};\n\nexport const ensureValuesConsistency = (\n  knobPositions: number[],\n  inputIndex: number,\n): number[] => {\n  const newKnobsPosition: number[] = [...knobPositions];\n\n  newKnobsPosition.forEach((value, index) => {\n    if (Number.isNaN(value) || value == null) {\n      newKnobsPosition[index] = pushSlider(\n        index,\n        inputIndex,\n        newKnobsPosition[inputIndex],\n      );\n    } else if (index < inputIndex && value > newKnobsPosition[inputIndex]) {\n      newKnobsPosition[index] = pushSlider(\n        index,\n        inputIndex,\n        newKnobsPosition[inputIndex],\n      );\n    } else if (index > inputIndex && value < newKnobsPosition[inputIndex]) {\n      newKnobsPosition[index] = pushSlider(\n        index,\n        inputIndex,\n        newKnobsPosition[inputIndex],\n      );\n    }\n  });\n\n  return newKnobsPosition;\n};\n\nexport const convertStatusToArray = (\n  length: number,\n  status?: HvFormStatus | HvFormStatus[],\n): {\n  arrayStatus?: HvFormStatus[];\n  arrayDefaultStatus: (keyof typeof validationStates)[];\n} => {\n  const result: {\n    arrayStatus?: HvFormStatus[];\n    arrayDefaultStatus: (keyof typeof validationStates)[];\n  } = {\n    arrayDefaultStatus: Array.from({ length }, () => validationStates.standBy),\n  };\n\n  if (status == null) {\n    return result;\n  }\n  if (!Array.isArray(status)) {\n    result.arrayStatus = Array.from({ length }, () => status);\n    return result;\n  }\n  result.arrayStatus = status;\n\n  return result;\n};\n\nexport const statusArrayToFormStatus = (\n  arrayStatus: HvFormStatus[],\n): keyof typeof validationStates => {\n  const invalid = arrayStatus.some(\n    (status) => status === validationStates.invalid,\n  );\n\n  if (invalid) return validationStates.invalid;\n\n  const valid = arrayStatus.some((status) => status === validationStates.valid);\n\n  if (valid) return validationStates.valid;\n\n  return validationStates.standBy;\n};\n\nexport const knobsValuesToString = (\n  knobsValues: number[],\n  markDigits: number,\n): string[] =>\n  knobsValues.map((knobValue) =>\n    Number.isNaN(knobValue) ? \"\" : knobValue.toFixed(markDigits),\n  );\n\nexport const stringValuesToKnobs = (inputsValues: string[]): number[] =>\n  inputsValues.map((inputValue) => parseFloat(inputValue));\n"],"names":["styles"],"mappings":"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"}