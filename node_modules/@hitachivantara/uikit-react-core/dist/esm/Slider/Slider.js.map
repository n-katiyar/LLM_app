{"version":3,"file":"Slider.js","sources":["../../../src/Slider/Slider.tsx"],"sourcesContent":["import {\n  forwardRef,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport Slider, { SliderProps, SliderRef } from \"rc-slider\";\nimport Tooltip from \"rc-tooltip\";\nimport {\n  useDefaultProps,\n  type ExtractNames,\n} from \"@hitachivantara/uikit-react-utils\";\n\nimport {\n  HvFormElement,\n  HvFormStatus,\n  HvLabel,\n  HvWarningText,\n  validationStates,\n} from \"../FormElement\";\nimport { useControlled } from \"../hooks/useControlled\";\nimport { useUniqueId } from \"../hooks/useUniqueId\";\nimport { HvInputProps } from \"../Input\";\nimport { HvBaseProps } from \"../types/generic\";\nimport { getElementById } from \"../utils/document\";\nimport { setId } from \"../utils/setId\";\nimport { sliderStyles, staticClasses, useClasses } from \"./Slider.styles\";\nimport { HvSliderInput } from \"./SliderInput/SliderInput\";\nimport { HvKnobProperty, HvMarkProperty } from \"./types\";\nimport {\n  calculateStepValue,\n  convertStatusToArray,\n  createKnobStyles,\n  createMark,\n  createTrackStyles,\n  ensureValuesConsistency,\n  generateDefaultKnobProperties,\n  isSingleSlider,\n  knobsPositionsToKnobsValues,\n  knobsPositionToScaledValue,\n  knobsValuesToKnobsPositions,\n  scaledValueToKnobsPositionValue,\n  statusArrayToFormStatus,\n} from \"./utils\";\n\nexport { staticClasses as sliderClasses };\n\nexport type HvSliderClasses = ExtractNames<typeof useClasses>;\n\nexport interface HvSliderProps\n  extends HvBaseProps<HTMLDivElement, \"onChange\" | \"onBlur\"> {\n  /** The slider name. */\n  name?: string;\n  /** The label of the slider. If not provided, an aria-label or aria-labelledby must be inputted via sliderProps. */\n  label?: React.ReactNode;\n  /** Indicates that the slider is disabled. */\n  disabled?: boolean;\n  /** Indicates that the slider is not editable. */\n  readOnly?: boolean;\n  /** Indicates that user slider is required on the form element. */\n  required?: boolean;\n  /** Error message to render when the value is required. */\n  requiredMessage?: string;\n  /** If `true` the input that controls the slider is hidden. */\n  hideInput?: boolean;\n  /** Attributes applied to the slider element. */\n  sliderProps?: SliderProps;\n  /**\n   * The status of the slider element.\n   *\n   * Valid is correct, invalid is incorrect and standBy means no validations have run.\n   *\n   * When uncontrolled and unspecified it will default to \"standBy\" and change to either \"valid\"\n   * or \"invalid\" after any change to the state.\n   */\n  status?: HvFormStatus | HvFormStatus[];\n  /** The error message to show when `status` is \"invalid\". */\n  statusMessage?: React.ReactNode;\n  /** The values array to apply to the component */\n  values?: number[];\n  /** The default values array to apply to the component */\n  defaultValues?: (number | undefined)[];\n  /**\n   * The object used to set the knob properties,\n   * for every item in the array a new knob will be created.\n   */\n  knobProperties?: HvKnobProperty[];\n  /** The object used to set the mark properties individually. */\n  markProperties?: HvMarkProperty[];\n  /**\n   * The function executed before a change will occur in the slider.\n   * @deprecated It's always better to use onChange instead\n   */\n  onBeforeChange?: (value: number[]) => void;\n  /** The function executed while a change is occurring in the slider. */\n  onChange?: (value: number[]) => void;\n  /**\n   * The function executed after a change ocurred in the slider.\n   * @deprecated It's always better to use onChange instead\n   */\n  onAfterChange?: (value: number[]) => void;\n  /** The function executed after a blur ocurred in the slider. */\n  onBlur?: (\n    event: React.FocusEvent,\n    knobsValues: number[],\n    status?: HvFormStatus | HvFormStatus[],\n  ) => void;\n  /**\n   * The separation in points between marks.\n   * example: if 10 divisions and a markstep of 2 there will be 5 marks.\n   */\n  markStep?: number;\n  /** How many subdivisions there are in the slider. */\n  divisionQuantity?: number;\n  /** The value of the first point in the slider from left to right. */\n  minPointValue?: number;\n  /** The value of the last point in the slider from left to right. */\n  maxPointValue?: number;\n  /** Error message to render when the value is higher than maxPointValue or lower than minPointValue. */\n  outOfRangeMessage?: string;\n  /** The max number of decimals if no format function is applied */\n  markDigits?: number;\n  /**\n   * A formatting function used to add format to the marks in the track,\n   * the function receives the mark text\n   */\n  formatMark?: (label: React.ReactNode) => React.ReactNode;\n  /**\n   * A formatting function used to add format to the tooltip in the track,\n   * the function receives the mark text\n   */\n  formatTooltip?: (label: React.ReactNode) => React.ReactNode;\n  /** If `true` the knobs can't have the same value, if `false` knobs can have the same value. */\n  noOverlap?: boolean;\n  /** Attributes applied to the input element. */\n  inputProps?: HvInputProps[];\n  /** Attributes applied to the knob element. */\n  knobProps?: React.HTMLAttributes<HTMLDivElement>[];\n  /** The classes object to be applied into the root object. */\n  classes?: HvSliderClasses;\n}\n\n/**\n * Sliders reflect a range of values along a bar, from which users may select a single value. They are ideal for adjusting settings such as volume, brightness, or applying image filters.\n */\nexport const HvSlider = forwardRef<\n  // no-indent\n  SliderRef,\n  HvSliderProps\n>(function HvSlider(props, ref) {\n  const {\n    id,\n    className,\n    name,\n    label,\n    status,\n    statusMessage,\n    disabled,\n    classes: classesProp,\n    sliderProps,\n    knobProps,\n    inputProps,\n    requiredMessage = \"The value is required\",\n    outOfRangeMessage = \"The value is out of range\",\n    noOverlap = true,\n    hideInput,\n    required,\n    readOnly,\n    markProperties = [],\n    defaultValues = [undefined],\n    values: valuesProp = [],\n    knobProperties: knobPropertiesProp,\n    \"aria-errormessage\": ariaErrorMessage,\n    maxPointValue = 100,\n    minPointValue = 0,\n    divisionQuantity = 100,\n    markStep = 20,\n    markDigits = 0,\n    formatMark,\n    onChange,\n    onBlur,\n    onBeforeChange,\n    onAfterChange,\n    formatTooltip,\n    ...others\n  } = useDefaultProps(\"HvSlider\", props);\n  const { classes, cx } = useClasses(classesProp);\n\n  // Miscellaneous state\n  const hasLabel = label != null;\n\n  // Signals that the user has manually edited the input value\n  const isDirty = useRef(false);\n\n  const elementId = useUniqueId(id);\n\n  const sliderInputId = setId(elementId, \"input\");\n\n  const stepValue = useMemo(\n    () => calculateStepValue(maxPointValue, minPointValue, divisionQuantity),\n    [divisionQuantity, maxPointValue, minPointValue],\n  );\n\n  const inverseStepValue = 1 / stepValue;\n\n  const marks = useMemo(\n    () =>\n      createMark(\n        markProperties,\n        markStep,\n        divisionQuantity,\n        minPointValue,\n        maxPointValue,\n        stepValue,\n        markDigits,\n        !!disabled,\n        formatMark,\n      ),\n    [\n      disabled,\n      divisionQuantity,\n      formatMark,\n      markDigits,\n      markProperties,\n      markStep,\n      minPointValue,\n      maxPointValue,\n      stepValue,\n    ],\n  );\n\n  const canShowError =\n    ariaErrorMessage == null &&\n    ((status !== undefined && statusMessage !== undefined) ||\n      // We always show an error when the value(s) are not between maxPointValue and minPointValue; and when required is true (set by user).\n      status === undefined);\n\n  const isSingle: boolean = useMemo(\n    () => isSingleSlider(valuesProp, defaultValues),\n    [defaultValues, valuesProp],\n  );\n\n  const value: number[] | undefined = useMemo(\n    () =>\n      valuesProp?.length > 0\n        ? knobsValuesToKnobsPositions(\n            valuesProp,\n            inverseStepValue,\n            minPointValue,\n          )\n        : undefined,\n    [inverseStepValue, minPointValue, valuesProp],\n  );\n\n  const defaultKnobsPositions: number[] = useMemo(\n    () =>\n      knobsValuesToKnobsPositions(\n        defaultValues,\n        inverseStepValue,\n        minPointValue,\n      ),\n    [defaultValues, inverseStepValue, minPointValue],\n  );\n\n  const [knobsPositions, setKnobsPositions] = useControlled(\n    value,\n    defaultKnobsPositions,\n  );\n\n  // Validation related state\n  const { arrayStatus, arrayDefaultStatus } = useMemo(\n    () => convertStatusToArray(knobsPositions.length, status),\n    [knobsPositions.length, status],\n  );\n\n  const [validationStatus, setValidationState] = useControlled(\n    arrayStatus,\n    arrayDefaultStatus,\n  );\n\n  const [validationMessage, setValidationMessage] = useControlled(\n    statusMessage,\n    \"\",\n  );\n\n  const [isDraggingTrack, setIsDraggingTrack] = useState(false);\n\n  const knobProperties = generateDefaultKnobProperties(\n    knobsPositions.length,\n    disabled,\n    knobPropertiesProp,\n  );\n\n  const rangesCount = knobProperties.length - 1;\n\n  const trackStyles = createTrackStyles(knobProperties);\n\n  const knobStyles = createKnobStyles(knobProperties);\n\n  /**\n   * Generates an object which posses the current value and position of the knobs.\n   *\n   * @param {Array} knobsCurrentPosition - An array containing the current positions of the knobs.\n   * @returns {Object} - An object with the positions and values of the knobs.\n   * @memberof HvSlider\n   */\n  const generateKnobsPositionAndValues = useCallback(\n    (\n      knobsCurrentPosition: number[],\n    ): { knobsPosition: number[]; knobsValues: number[] } => {\n      const newKnobsPosition: number[] = knobsCurrentPosition.slice();\n      const knobsValues: number[] = [];\n\n      let duplicatedValue: number | null = null;\n\n      const findDuplicated: number[] = newKnobsPosition.filter(\n        (item, index) => newKnobsPosition.indexOf(item) !== index,\n      );\n\n      if (noOverlap && findDuplicated.length > 0) {\n        [duplicatedValue] = findDuplicated;\n      }\n\n      newKnobsPosition.forEach((position, index, array) => {\n        const newArray: number[] = array;\n        let newPosition: number = position;\n\n        if (noOverlap && newPosition === duplicatedValue) {\n          const previousValue = knobsPositions[index];\n          if (previousValue !== newPosition) {\n            newPosition += newPosition > previousValue ? -1 : 1;\n            newArray[index] = newPosition;\n          }\n        }\n\n        knobsValues[index] = knobsPositionToScaledValue(\n          newPosition,\n          minPointValue,\n          stepValue,\n        );\n      });\n\n      return {\n        knobsPosition: newKnobsPosition,\n        knobsValues,\n      };\n    },\n    [knobsPositions, minPointValue, noOverlap, stepValue],\n  );\n\n  const performValidation = useCallback(() => {\n    let invalid = false;\n    let requiredMsg = false;\n\n    const mappedValues =\n      generateKnobsPositionAndValues(knobsPositions).knobsValues;\n\n    const newValidationState = mappedValues.map((knobValue) => {\n      if (required && (knobValue == null || Number.isNaN(knobValue))) {\n        invalid = true;\n        requiredMsg = true;\n        return validationStates.invalid;\n      }\n\n      if (knobValue < minPointValue || knobValue > maxPointValue) {\n        invalid = true;\n        return validationStates.invalid;\n      }\n\n      return validationStates.valid;\n    });\n\n    setValidationState([...newValidationState]);\n\n    if (invalid) {\n      setValidationMessage(requiredMsg ? requiredMessage : outOfRangeMessage);\n      return;\n    }\n\n    setValidationMessage(\"\");\n  }, [\n    generateKnobsPositionAndValues,\n    knobsPositions,\n    maxPointValue,\n    minPointValue,\n    outOfRangeMessage,\n    required,\n    requiredMessage,\n    setValidationMessage,\n    setValidationState,\n  ]);\n\n  useEffect(() => {\n    const stepVl = calculateStepValue(\n      maxPointValue,\n      minPointValue,\n      divisionQuantity,\n    );\n\n    const inverseStepVl = 1 / stepVl;\n\n    if (valuesProp?.length > 0) {\n      setKnobsPositions(\n        knobsValuesToKnobsPositions(\n          valuesProp.length > 0 ? valuesProp : defaultValues,\n          inverseStepVl,\n          minPointValue,\n        ),\n      );\n    }\n  }, [\n    defaultValues,\n    divisionQuantity,\n    maxPointValue,\n    minPointValue,\n    setKnobsPositions,\n    valuesProp,\n  ]);\n\n  useEffect(() => {\n    if (!isDirty.current) {\n      // Skip validation if currently focused or if empty and\n      // the user never manually edited the input value\n      return;\n    }\n\n    performValidation();\n  }, [knobsPositions, requiredMessage, performValidation]);\n\n  const onMouseDownHandler = (event: React.MouseEvent<HTMLDivElement>) => {\n    if ((event.target as HTMLDivElement).className.includes(\"track\")) {\n      setIsDraggingTrack(true);\n    }\n  };\n\n  const onMouseUpHandler = () => {\n    setIsDraggingTrack(false);\n  };\n\n  const onBlurHandler = (event: React.FocusEvent) => {\n    const knobs = generateKnobsPositionAndValues(knobsPositions);\n\n    performValidation();\n\n    onBlur?.(event, knobs.knobsValues, status);\n  };\n\n  /**\n   * Function executed while the knobs changes.\n   *\n   * executes the callback provided by the user with the values and position of the knobs,\n   * also lock the value of the knob in case one is fixed.\n   */\n  const onChangeHandler = (knobsPosition: number[]) => {\n    isDirty.current = true;\n\n    const knobs = generateKnobsPositionAndValues(knobsPosition);\n\n    knobProperties.forEach((knobProperty, index) => {\n      if (knobProperty.fixed) {\n        knobs.knobsPosition[index] = scaledValueToKnobsPositionValue(\n          defaultValues[index],\n          minPointValue,\n          inverseStepValue,\n        );\n      }\n    });\n\n    if (disabled || readOnly) return;\n    onChange?.(knobs.knobsValues);\n\n    setKnobsPositions(knobs.knobsPosition);\n  };\n\n  const onInputChangeHandler = (inputValues: number[], index: number) => {\n    let newKnobPositions = knobsValuesToKnobsPositions(\n      inputValues,\n      inverseStepValue,\n      minPointValue,\n    );\n\n    newKnobPositions = ensureValuesConsistency(newKnobPositions, index);\n\n    onChangeHandler(newKnobPositions);\n  };\n\n  /**\n   * Function executed before a change.\n   *\n   * executes the callback provided by the user with the values and position of the knobs\n   */\n  const onBeforeChangeHandler = (knobsPosition: number[]) => {\n    const knobs = generateKnobsPositionAndValues(knobsPosition);\n\n    onBeforeChange?.(knobs.knobsValues);\n  };\n\n  /**\n   * Function executed after a change.\n   *\n   * executes the callback provided by the user with the values and position of the knobs\n   */\n  const onAfterChangeHandler = (knobsPosition: number[]) => {\n    const knobs = generateKnobsPositionAndValues(knobsPosition);\n\n    onAfterChange?.(knobs.knobsValues);\n  };\n\n  /**\n   * Function used to create a custom knob for the slider.\n   *\n   * TODO: This should be isolated because is creating a sub component,\n   * but there were some problems regarding the underlying component losing\n   * references of the handlers disabling the focus.\n   */\n  const createKnob: SliderProps[\"handleRender\"] = (knobNode, params) => {\n    const { value: knobValue, dragging, index } = params;\n    const { style = {}, ...restProps } = knobNode.props;\n    const scaledKnobValue = knobsPositionToScaledValue(\n      knobValue,\n      minPointValue,\n      stepValue,\n    ).toFixed(markDigits);\n    if (dragging) {\n      style.backgroundColor = knobProperties[index]?.dragColor;\n    } else {\n      style.backgroundColor = knobProperties[index]?.color;\n    }\n\n    const isEmpty =\n      Number.isNaN(knobsPositions[index]) || knobsPositions[index] == null;\n    const handleId = setId(elementId, \"knob\");\n    const indexedHandleId = setId(handleId, index);\n\n    return (\n      <div\n        key={index}\n        className={cx({\n          [classes.handleContainer]: !!(!disabled && !isEmpty),\n          [classes.handleContainerDisabled]: !!(disabled && !isEmpty),\n          [classes.handleHiddenContainer]: isEmpty || readOnly,\n        })}\n      >\n        <Tooltip\n          prefixCls=\"rc-slider-tooltip\"\n          overlay={formatTooltip?.(scaledKnobValue) || scaledKnobValue}\n          visible={dragging}\n          placement=\"top\"\n          overlayClassName={classes.sliderTooltip}\n          getTooltipContainer={() => getElementById(indexedHandleId)!}\n        >\n          <div\n            id={indexedHandleId}\n            style={style}\n            className={classes.handle}\n            {...restProps}\n            aria-label={`${label}-knob-${index}`}\n            aria-valuenow={knobsPositionToScaledValue(\n              knobValue,\n              minPointValue,\n              stepValue,\n            )}\n            aria-valuemin={minPointValue}\n            aria-valuemax={maxPointValue}\n            {...knobProps?.[index]}\n          />\n        </Tooltip>\n      </div>\n    );\n  };\n\n  const knobsValuesArray = knobsPositionsToKnobsValues(\n    knobsPositions,\n    stepValue,\n    minPointValue,\n  );\n\n  const knobsValues = knobsValuesArray.map((v) =>\n    Number(v.toFixed(markDigits)),\n  );\n\n  return (\n    <HvFormElement\n      className={cx(\n        classes.root,\n        {\n          [classes.trackStandBy]:\n            !readOnly && !disabled && !isSingle && !isDraggingTrack,\n          [classes.trackDragging]:\n            !readOnly && !disabled && !isSingle && isDraggingTrack,\n          [classes.rootDisabled]: !!disabled,\n        },\n        className,\n      )}\n      id={id}\n      name={name}\n      status={statusArrayToFormStatus(validationStatus)}\n      disabled={disabled}\n      required={required}\n      readOnly={readOnly}\n      onMouseDown={onMouseDownHandler}\n      onMouseUp={onMouseUpHandler}\n      onBlur={onBlurHandler}\n      {...others}\n    >\n      {(hasLabel || !hideInput) && (\n        <div\n          className={cx(classes.labelContainer, {\n            [classes.labelIncluded]: hasLabel,\n            [classes.onlyInput]: !hasLabel,\n          })}\n        >\n          {hasLabel && (\n            <HvLabel\n              id={setId(elementId, \"label\")}\n              className={classes.label}\n              htmlFor={sliderInputId}\n              label={label}\n            />\n          )}\n\n          {!hideInput && (\n            <HvSliderInput\n              id={sliderInputId}\n              label={label}\n              values={knobsValues}\n              onChange={onInputChangeHandler}\n              status={validationStatus}\n              disabled={disabled}\n              readOnly={readOnly}\n              markDigits={markDigits}\n              inputProps={inputProps}\n            />\n          )}\n        </div>\n      )}\n\n      <div className={cx(classes.sliderBase, classes.sliderContainer)}>\n        <Slider\n          ref={ref}\n          range={!isSingle}\n          handleRender={createKnob}\n          className={cx(classes.sliderRoot, {\n            [classes.rootRange]: !isSingle,\n          })}\n          min={0}\n          max={divisionQuantity}\n          step={1}\n          marks={marks}\n          dotStyle={disabled ? sliderStyles.dotDisabled : sliderStyles.dot}\n          onChange={(singleValue) =>\n            onChangeHandler(Array<number>().concat(singleValue))\n          }\n          onBeforeChange={(singleValue) =>\n            onBeforeChangeHandler(Array<number>().concat(singleValue))\n          }\n          onAfterChange={(singleValue) =>\n            onAfterChangeHandler(Array<number>().concat(singleValue))\n          }\n          value={\n            knobsPositions.length === 0\n              ? undefined\n              : isSingle\n                ? knobsPositions[0]\n                : [...knobsPositions]\n          }\n          allowCross={false}\n          disabled={disabled}\n          count={rangesCount}\n          railStyle={sliderStyles.rail}\n          handleStyle={knobStyles.knobInner}\n          trackStyle={trackStyles}\n          draggableTrack={!readOnly && !isSingle}\n          {...sliderProps}\n        />\n      </div>\n\n      {canShowError && (\n        <HvWarningText\n          id={setId(elementId, \"error\")}\n          className={classes.error}\n          disableBorder\n        >\n          {validationMessage}\n        </HvWarningText>\n      )}\n    </HvFormElement>\n  );\n});\n"],"names":["HvSlider","knobsValues"],"mappings":"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"}