{"version":3,"file":"utils.js","sources":["../../../src/FormElement/utils.ts"],"sourcesContent":["import { Children } from \"react\";\nimport type { InputBaseComponentProps } from \"@mui/material/InputBase\";\n\nimport type {\n  HvFormElementContextValue,\n  HvFormElementDescriptorsContextValue,\n} from \"./context\";\nimport type { HvFormStatus } from \"./FormElement\";\n\ninterface Descriptor {\n  id?: string;\n  htmlFor?: string;\n}\n/**\n * Scans the element's children looking for the children IDs that match the different form element types.\n * This function will produce an object that has a key for each provided name\n * Inside each key there will be an array with each id of the found descriptor.\n *\n * @param {Array} children - The children inside the form element to scan.\n * @param {Object} descriptors - Initial descriptors map (used for recursion).\n *\n */\nexport const findDescriptors = (\n  children: React.ReactNode,\n  descriptors: {\n    input: Descriptor[];\n    label: Descriptor[];\n    description: Descriptor[];\n    controlled: Descriptor[];\n    errormessage: Descriptor[];\n    HvCalendarHeader?: Descriptor[];\n  } = {\n    input: [],\n    label: [],\n    description: [],\n    controlled: [],\n    errormessage: [],\n\n    // TODO: refactor this out\n    HvCalendarHeader: [],\n  },\n) => {\n  Children.forEach(children, (child: any) => {\n    if (child?.type?.formElementType && child.props?.id) {\n      descriptors[child.type.formElementType as keyof typeof descriptors]?.push(\n        {\n          id: child.props?.id,\n          htmlFor: child.props?.htmlFor,\n        },\n      );\n    }\n\n    if (child?.type?.formElementType !== \"formelement\") {\n      findDescriptors(child?.props?.children, descriptors);\n    }\n  });\n\n  return descriptors;\n};\n\nexport const getIdReferenceListFor = (\n  formElementType: string,\n  descriptors: any,\n  filterFor: string | null = null,\n) => {\n  const referenceList = descriptors?.[formElementType]\n    ?.filter((d: any) => d.htmlFor !== filterFor)\n    ?.map((d: any) => d.id)\n    .join(\" \")\n    .trim();\n\n  return referenceList !== \"\" ? referenceList : undefined;\n};\n\nexport const getIdReferenceFor = (\n  formElementType: string,\n  descriptors: any,\n  filterFor = null,\n) => {\n  const referenceList = descriptors?.[formElementType]\n    ?.filter((d: any) => d.htmlFor !== filterFor)\n    ?.map((d: any) => d.id)?.[0];\n\n  return referenceList !== \"\" ? referenceList : undefined;\n};\n\nexport const buildFormElementPropsFromContext = (\n  name?: string,\n  disabled?: boolean,\n  readOnly?: boolean,\n  required?: boolean,\n  context?: HvFormElementContextValue,\n) => {\n  return {\n    name: name || context?.name,\n    disabled: disabled ?? context?.disabled,\n    readOnly: readOnly ?? context?.readOnly,\n    required: required ?? context?.required,\n    status: context?.status,\n  };\n};\n\nexport const buildAriaPropsFromContext = (\n  props: InputBaseComponentProps,\n  context: HvFormElementDescriptorsContextValue,\n  isInvalid: boolean,\n  inputId?: string,\n) => {\n  const arias: React.AriaAttributes = {\n    \"aria-labelledby\":\n      props?.[\"aria-labelledby\"] !== undefined\n        ? props?.[\"aria-labelledby\"]\n        : getIdReferenceListFor(\"label\", context?.descriptors, inputId),\n    \"aria-describedby\":\n      props?.[\"aria-describedby\"] !== undefined\n        ? props?.[\"aria-describedby\"]\n        : getIdReferenceListFor(\"description\", context?.descriptors),\n    \"aria-controls\":\n      props?.[\"aria-controls\"] !== undefined\n        ? props?.[\"aria-controls\"]\n        : getIdReferenceListFor(\"controlled\", context?.descriptors),\n  };\n\n  if (isInvalid) {\n    arias[\"aria-invalid\"] = isInvalid;\n    arias[\"aria-errormessage\"] =\n      props?.[\"aria-errormessage\"] !== undefined\n        ? props?.[\"aria-errormessage\"]\n        : getIdReferenceFor(\"errormessage\", context?.descriptors);\n  }\n\n  return arias;\n};\n\nexport const validationStates = Object.freeze({\n  standBy: \"standBy\",\n  valid: \"valid\",\n  invalid: \"invalid\",\n});\n\nexport const isValid = (state: HvFormStatus) =>\n  state === validationStates.valid;\nexport const isInvalid = (state: HvFormStatus) =>\n  state === validationStates.invalid;\n"],"names":["isInvalid"],"mappings":";AAsBa,MAAA,kBAAkB,CAC7B,UACA,cAOI;AAAA,EACF,OAAO,CAAC;AAAA,EACR,OAAO,CAAC;AAAA,EACR,aAAa,CAAC;AAAA,EACd,YAAY,CAAC;AAAA,EACb,cAAc,CAAC;AAAA;AAAA,EAGf,kBAAkB,CAAA;AACpB,MACG;AACM,WAAA,QAAQ,UAAU,CAAC,UAAe;AACzC,QAAI,OAAO,MAAM,mBAAmB,MAAM,OAAO,IAAI;AACvC,kBAAA,MAAM,KAAK,eAA2C,GAAG;AAAA,QACnE;AAAA,UACE,IAAI,MAAM,OAAO;AAAA,UACjB,SAAS,MAAM,OAAO;AAAA,QAAA;AAAA,MAE1B;AAAA,IAAA;AAGE,QAAA,OAAO,MAAM,oBAAoB,eAAe;AAClC,sBAAA,OAAO,OAAO,UAAU,WAAW;AAAA,IAAA;AAAA,EACrD,CACD;AAEM,SAAA;AACT;AAEO,MAAM,wBAAwB,CACnC,iBACA,aACA,YAA2B,SACxB;AACG,QAAA,gBAAgB,cAAc,eAAe,GAC/C,OAAO,CAAC,MAAW,EAAE,YAAY,SAAS,GAC1C,IAAI,CAAC,MAAW,EAAE,EAAE,EACrB,KAAK,GAAG,EACR,KAAK;AAED,SAAA,kBAAkB,KAAK,gBAAgB;AAChD;AAEO,MAAM,oBAAoB,CAC/B,iBACA,aACA,YAAY,SACT;AACH,QAAM,gBAAgB,cAAc,eAAe,GAC/C,OAAO,CAAC,MAAW,EAAE,YAAY,SAAS,GAC1C,IAAI,CAAC,MAAW,EAAE,EAAE,IAAI,CAAC;AAEtB,SAAA,kBAAkB,KAAK,gBAAgB;AAChD;AAEO,MAAM,mCAAmC,CAC9C,MACA,UACA,UACA,UACA,YACG;AACI,SAAA;AAAA,IACL,MAAM,QAAQ,SAAS;AAAA,IACvB,UAAU,YAAY,SAAS;AAAA,IAC/B,UAAU,YAAY,SAAS;AAAA,IAC/B,UAAU,YAAY,SAAS;AAAA,IAC/B,QAAQ,SAAS;AAAA,EACnB;AACF;AAEO,MAAM,4BAA4B,CACvC,OACA,SACAA,YACA,YACG;AACH,QAAM,QAA8B;AAAA,IAClC,mBACE,QAAQ,iBAAiB,MAAM,SAC3B,QAAQ,iBAAiB,IACzB,sBAAsB,SAAS,SAAS,aAAa,OAAO;AAAA,IAClE,oBACE,QAAQ,kBAAkB,MAAM,SAC5B,QAAQ,kBAAkB,IAC1B,sBAAsB,eAAe,SAAS,WAAW;AAAA,IAC/D,iBACE,QAAQ,eAAe,MAAM,SACzB,QAAQ,eAAe,IACvB,sBAAsB,cAAc,SAAS,WAAW;AAAA,EAChE;AAEA,MAAIA,YAAW;AACb,UAAM,cAAc,IAAIA;AACxB,UAAM,mBAAmB,IACvB,QAAQ,mBAAmB,MAAM,SAC7B,QAAQ,mBAAmB,IAC3B,kBAAkB,gBAAgB,SAAS,WAAW;AAAA,EAAA;AAGvD,SAAA;AACT;AAEa,MAAA,mBAAmB,OAAO,OAAO;AAAA,EAC5C,SAAS;AAAA,EACT,OAAO;AAAA,EACP,SAAS;AACX,CAAC;AAEM,MAAM,UAAU,CAAC,UACtB,UAAU,iBAAiB;AACtB,MAAM,YAAY,CAAC,UACxB,UAAU,iBAAiB;"}