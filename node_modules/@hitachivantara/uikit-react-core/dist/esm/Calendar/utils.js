import { capitalize } from "../utils/helpers.js";
const CALENDAR_WEEKS = 6;
const DEFAULT_LOCALE = "en";
const getMonthDays = (month, year) => new Date(year, month, 0).getDate();
const getMonthFirstWeekday = (month, year) => new Date(year, month - 1, 1).getDay();
const makeUTCDate = (year, monthIndex, day, hour = 1) => new Date(Date.UTC(year, monthIndex, day, hour));
const isDate = (date) => Object.prototype.toString.call(date) === "[object Date]" && !Number.isNaN(date.valueOf());
const isDateRangeProp = (date) => "startDate" in date;
const isSameMonth = (date1, date2) => {
  if (!(isDate(date1) && isDate(date2))) return false;
  return date1.getMonth() === date2.getMonth() && date1.getFullYear() === date2.getFullYear();
};
const isSameDay = (date1, date2) => {
  if (!(isDate(date1) && isDate(date2))) return false;
  return date1.getDate() === date2.getDate() && date1.getMonth() === date2.getMonth() && date1.getFullYear() === date2.getFullYear();
};
const getDateISO = (date) => {
  return new Date(date).toISOString().slice(0, 10);
};
const getPreviousMonth = (month, year) => {
  const prevMonth = month > 1 ? month - 1 : 12;
  const prevMonthYear = month > 1 ? year : year - 1;
  return { month: prevMonth, year: prevMonthYear };
};
const getNextMonth = (month, year) => {
  const nextMonth = month < 12 ? month + 1 : 1;
  const nextMonthYear = month < 12 ? year : year + 1;
  return { month: nextMonth, year: nextMonthYear };
};
const getMonthNamesList = (locale, representationValue = "long") => {
  const options = { month: representationValue, timeZone: "UTC" };
  return [...Array(12).keys()].map((index) => {
    const auxDate = makeUTCDate(1970, index, 1);
    return capitalize(Intl.DateTimeFormat(locale, options).format(auxDate));
  });
};
const getWeekdayNamesList = (locale) => {
  const formatter = new Intl.DateTimeFormat(locale, {
    weekday: "narrow",
    timeZone: "UTC"
  });
  return [...Array(7).keys()].map((index) => {
    return formatter.format(makeUTCDate(1970, 0, 4 + index));
  });
};
const getMonthName = (date, locale, representationValue = "long") => new Intl.DateTimeFormat(locale, { month: representationValue }).format(date);
const getFormattedDate = (date, locale) => {
  const formatter = new Intl.DateTimeFormat(locale, { dateStyle: "medium" });
  return formatter.format(date);
};
const createDatesArray = (month, year) => {
  const monthDays = getMonthDays(month, year);
  const daysFromPrevMonth = getMonthFirstWeekday(month, year);
  const daysFromNextMonth = CALENDAR_WEEKS * 7 - (daysFromPrevMonth + monthDays);
  const prevMonthYear = getPreviousMonth(month, year);
  const nextMonthYear = getNextMonth(month, year);
  const prevMonthDays = getMonthDays(prevMonthYear.month, prevMonthYear.year);
  const prevMonthDates = [...Array(daysFromPrevMonth).keys()].map((index) => {
    const day = index + 1 + (prevMonthDays - daysFromPrevMonth);
    return new Date(prevMonthYear.year, prevMonthYear.month - 1, day);
  });
  const currentMonthDates = [...Array(monthDays).keys()].map((index) => {
    const day = index + 1;
    return new Date(year, month - 1, day);
  });
  const nextMonthDates = [...Array(daysFromNextMonth).keys()].map((index) => {
    const day = index + 1;
    return new Date(nextMonthYear.year, nextMonthYear.month - 1, day);
  });
  return [...prevMonthDates, ...currentMonthDates, ...nextMonthDates];
};
const isRange = (date) => date != null && typeof date === "object" && "startDate" in date;
const dateInProvidedValueRange = (date, dateRange) => {
  if (!isRange(dateRange) || !dateRange?.endDate) return false;
  const { startDate, endDate } = dateRange;
  const modStartDate = getDateISO(startDate);
  const modEndDate = getDateISO(endDate);
  const convertedDate = getDateISO(date ?? /* @__PURE__ */ new Date());
  return convertedDate >= modStartDate && convertedDate <= modEndDate;
};
const checkIfDateIsDisabled = (date, minimumDate, maximumDate) => {
  if (!minimumDate && !maximumDate) return false;
  const modStartDate = minimumDate && getDateISO(minimumDate);
  const modEndDate = maximumDate && getDateISO(maximumDate);
  const convertedDate = getDateISO(date ?? /* @__PURE__ */ new Date());
  return modStartDate !== void 0 && convertedDate < modStartDate || modEndDate !== void 0 && convertedDate > modEndDate;
};
function getEditableDateFormatter(locale) {
  return new Intl.DateTimeFormat(locale, {
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  });
}
function getStringFromDate(date, locale) {
  return getEditableDateFormatter(locale).format(date);
}
function parseDateString(dateString, locale) {
  const dateParts = dateString.split(/\D+/).map(Number);
  if (dateParts.length !== 3) return null;
  if (!dateParts.every(Boolean)) return null;
  const formatter = getEditableDateFormatter(locale);
  const formatOrder = formatter.formatToParts(new Date(2020, 4, 4)).filter((part) => ["year", "month", "day"].includes(part.type)).map((part) => part.type);
  const dateObject = { year: 2020, month: 4, day: 4 };
  formatOrder.forEach((type, index) => {
    dateObject[type] = dateParts[index];
  });
  return new Date(dateObject.year, dateObject.month - 1, dateObject.day);
}
function getLocaleDateFormat(locale) {
  const formatter = getEditableDateFormatter(locale);
  const getPartType = (part) => {
    if (part.type === "year") return "YYYY";
    if (part.type === "month") return "MM";
    if (part.type === "day") return "DD";
    return part.value;
  };
  return formatter.formatToParts(new Date(2020, 4, 4)).reduce((acc, part) => acc + getPartType(part), "");
}
export {
  CALENDAR_WEEKS,
  DEFAULT_LOCALE,
  checkIfDateIsDisabled,
  createDatesArray,
  dateInProvidedValueRange,
  getDateISO,
  getFormattedDate,
  getLocaleDateFormat,
  getMonthDays,
  getMonthFirstWeekday,
  getMonthName,
  getMonthNamesList,
  getNextMonth,
  getPreviousMonth,
  getStringFromDate,
  getWeekdayNamesList,
  isDate,
  isDateRangeProp,
  isRange,
  isSameDay,
  isSameMonth,
  makeUTCDate,
  parseDateString
};
