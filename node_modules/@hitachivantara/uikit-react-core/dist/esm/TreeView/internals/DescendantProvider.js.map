{"version":3,"file":"DescendantProvider.js","sources":["../../../../src/TreeView/internals/DescendantProvider.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { unstable_useEnhancedEffect as useEnhancedEffect } from \"@mui/material/utils\";\n\n/** Credit: https://github.com/reach/reach-ui/blob/86a046f54d53b6420e392b3fa56dd991d9d4e458/packages/descendants/README.md\n *  Modified slightly to suit our purposes.\n */\n\nfunction binaryFindElement(\n  array: TreeItemDescendant[],\n  element: HTMLLIElement,\n) {\n  let start = 0;\n  let end = array.length - 1;\n\n  while (start <= end) {\n    const middle = Math.floor((start + end) / 2);\n\n    if (array[middle].element === element) {\n      return middle;\n    }\n\n    if (\n      // eslint-disable-next-line no-bitwise\n      array[middle].element.compareDocumentPosition(element) &\n      Node.DOCUMENT_POSITION_PRECEDING\n    ) {\n      end = middle - 1;\n    } else {\n      start = middle + 1;\n    }\n  }\n\n  return start;\n}\n\nexport interface TreeItemDescendant {\n  element: HTMLLIElement;\n  id: string;\n}\n\ninterface DescendantContextValue {\n  registerDescendant?: (params: TreeItemDescendant & { index: number }) => void;\n  unregisterDescendant?: (params: HTMLLIElement) => void;\n  descendants?: TreeItemDescendant[];\n  parentId?: string | null;\n  level?: number;\n}\n\nexport const DescendantContext = React.createContext<DescendantContextValue>({\n  level: 0,\n});\n\nfunction usePrevious<T>(value: T) {\n  const ref = React.useRef<T | null>(null);\n  React.useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\nconst noop = () => {};\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation.\n */\nexport function useDescendant(descendant: TreeItemDescendant) {\n  const [, forceUpdate] = React.useState<{}>();\n  const {\n    registerDescendant = noop,\n    unregisterDescendant = noop,\n    descendants = [],\n    parentId = null,\n    level = 0,\n  } = React.useContext(DescendantContext);\n\n  // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render, and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n  const index = descendants.findIndex(\n    (item) => item.element === descendant.element,\n  );\n\n  const previousDescendants = usePrevious(descendants);\n\n  // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n  const someDescendantsHaveChanged = descendants.some(\n    (newDescendant, position) => {\n      return (\n        previousDescendants?.[position] &&\n        previousDescendants[position].element !== newDescendant.element\n      );\n    },\n  );\n\n  // Prevent any flashing\n  useEnhancedEffect(() => {\n    if (descendant.element) {\n      registerDescendant({\n        ...descendant,\n        index,\n      });\n      return () => {\n        unregisterDescendant(descendant.element!);\n      };\n    }\n    forceUpdate({});\n\n    return undefined;\n  }, [\n    registerDescendant,\n    unregisterDescendant,\n    index,\n    someDescendantsHaveChanged,\n    descendant,\n  ]);\n\n  return { parentId, index, level };\n}\n\ninterface DescendantProviderProps {\n  id?: string;\n  level?: number;\n  children: React.ReactNode;\n}\n\nexport const DescendantProvider = (props: DescendantProviderProps) => {\n  const { children, id, level } = props;\n\n  const [items, set] = React.useState<\n    (TreeItemDescendant & { index: number })[]\n  >([]);\n\n  const registerDescendant = React.useCallback(\n    ({ element, ...other }: TreeItemDescendant) => {\n      set((oldItems) => {\n        if (oldItems.length === 0) {\n          // If there are no items, register at index 0 and bail.\n          return [\n            {\n              ...other,\n              element,\n              index: 0,\n            },\n          ];\n        }\n\n        const index = binaryFindElement(oldItems, element);\n        let newItems: typeof oldItems;\n\n        if (oldItems[index] && oldItems[index].element === element) {\n          // If the element is already registered, just use the same array\n          newItems = oldItems;\n        } else {\n          // When registering a descendant, we need to make sure we insert in\n          // into the array in the same order that it appears in the DOM. So as\n          // new descendants are added or maybe some are removed, we always know\n          // that the array is up-to-date and correct.\n          //\n          // So here we look at our registered descendants and see if the new\n          // element we are adding appears earlier than an existing descendant's\n          // DOM node via `node.compareDocumentPosition`. If it does, we insert\n          // the new element at this index. Because `registerDescendant` will be\n          // called in an effect every time the descendants state value changes,\n          // we should be sure that this index is accurate when descendent\n          // elements come or go from our component.\n\n          const newItem = {\n            ...other,\n            element,\n            index,\n          };\n\n          // If an index is not found we will push the element to the end.\n          newItems = oldItems.slice();\n          newItems.splice(index, 0, newItem);\n        }\n        newItems.forEach((item, position) => {\n          item.index = position;\n        });\n        return newItems;\n      });\n    },\n    [],\n  );\n\n  const unregisterDescendant = React.useCallback((element: HTMLLIElement) => {\n    set((oldItems) => oldItems.filter((item) => element !== item.element));\n  }, []);\n\n  const value = React.useMemo(\n    () => ({\n      descendants: items,\n      registerDescendant,\n      unregisterDescendant,\n      parentId: id,\n      level,\n    }),\n    [items, registerDescendant, unregisterDescendant, id, level],\n  );\n\n  return (\n    <DescendantContext.Provider value={value}>\n      {children}\n    </DescendantContext.Provider>\n  );\n};\n"],"names":["useEnhancedEffect"],"mappings":"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"}