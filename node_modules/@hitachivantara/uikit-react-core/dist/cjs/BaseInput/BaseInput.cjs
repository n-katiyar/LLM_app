"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("react/jsx-runtime");
const React = require("react");
const MuiInputBase = require("@mui/material/InputBase");
const utils$1 = require("@mui/material/utils");
const uikitReactUtils = require("@hitachivantara/uikit-react-utils");
const BaseInput_styles = require("./BaseInput.styles.cjs");
const context = require("../FormElement/context.cjs");
const utils = require("../FormElement/utils.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const MuiInputBase__default = /* @__PURE__ */ _interopDefault(MuiInputBase);
const HvBaseInput = React.forwardRef(function HvBaseInput2(props, ref) {
  const {
    classes: classesProp,
    className = "",
    id,
    name,
    value,
    defaultValue,
    required,
    readOnly,
    disabled,
    onChange,
    type = "text",
    placeholder,
    multiline,
    resizable,
    invalid: invalidProp,
    inputRef,
    inputProps = {},
    ...others
  } = uikitReactUtils.useDefaultProps("HvBaseInput", props);
  const { classes, cx } = BaseInput_styles.useClasses(classesProp);
  const formElementContext = React.useContext(context.HvFormElementContext);
  const formElementProps = utils.buildFormElementPropsFromContext(
    name,
    disabled,
    readOnly,
    required,
    formElementContext
  );
  const forkedRef = utils$1.useForkRef(ref, inputRef);
  const invalid = invalidProp || formElementProps.status === "invalid";
  const formElementDescriptorsContext = React.useContext(
    context.HvFormElementDescriptorsContext
  );
  const ariaProps = utils.buildAriaPropsFromContext(
    inputProps,
    formElementDescriptorsContext,
    invalid,
    id
  );
  return /* @__PURE__ */ jsxRuntime.jsx(
    MuiInputBase__default.default,
    {
      id,
      name: formElementProps.name,
      value,
      defaultValue,
      placeholder,
      readOnly: !!formElementProps.readOnly,
      disabled: formElementProps.disabled,
      onChange: (event) => onChange?.(event, event.target.value),
      className: cx(classes.root, classes.inputRoot, className, {
        [classes.inputRootMultiline]: multiline,
        [classes.multiline]: multiline,
        [classes.inputRootInvalid]: invalid,
        [classes.invalid]: invalid,
        [classes.inputRootReadOnly]: formElementProps.readOnly,
        [classes.readOnly]: formElementProps.readOnly,
        [classes.inputRootDisabled]: formElementProps.disabled,
        [classes.disabled]: formElementProps.disabled
      }),
      classes: {
        focused: cx(classes.focused, classes.inputRootFocused),
        input: cx(classes.input, {
          [classes.inputResizable]: !formElementProps.disabled && resizable,
          [classes.inputDisabled]: formElementProps.disabled,
          [classes.inputReadOnly]: formElementProps.readOnly
        })
      },
      inputProps: {
        // Avoid the required attribute at the root node
        required: formElementProps.required,
        ...inputProps,
        ...ariaProps
      },
      inputRef: forkedRef,
      multiline,
      ...multiline ? { rows: 10 } : { type },
      ...others
    }
  );
});
exports.baseInputClasses = BaseInput_styles.staticClasses;
exports.HvBaseInput = HvBaseInput;
