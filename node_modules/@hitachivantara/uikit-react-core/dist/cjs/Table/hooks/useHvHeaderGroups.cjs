"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const replaceHeaderPlaceholders = (headerGroups) => {
  const [headerGroup] = headerGroups;
  const hasPlaceholderHeaders = headerGroup.headers.some(
    (h) => h.placeholderOf != null
  );
  if (!hasPlaceholderHeaders) {
    return;
  }
  const maxDepth = headerGroups.length - 1;
  const leafGroup = headerGroups[maxDepth];
  headerGroup.headers.forEach((header, position) => {
    const { placeholderOf } = header;
    const isPlaceholderHeader = placeholderOf != null;
    if (isPlaceholderHeader) {
      const leafIndex = leafGroup.headers.slice(position).findIndex(({ id }) => id === placeholderOf.id) + position;
      header.variant = placeholderOf.variant;
      header.depth = maxDepth;
      leafGroup.headers[leafIndex] = header;
      placeholderOf.rowSpan = maxDepth + 1;
      headerGroup.headers[position] = placeholderOf;
    }
  });
};
const getCellProps = (column, isHeaderCell = false) => ({
  groupColumnMostLeft: column.isGroupLeftColumn,
  groupColumnMostRight: column.isGroupRightColumn,
  rowSpan: isHeaderCell && column.rowSpan != null ? column.rowSpan : 1
});
const getHeaderPropsHook = (props, { instance, column }) => {
  const nextProps = instance.hasGroupedColumns ? getCellProps(column, true) : {};
  if (instance.hasGroupedColumns) {
    const isPlaceholder = column.placeholderOf != null;
    nextProps.style = {
      display: isPlaceholder ? "none" : props.style?.display
    };
    if (instance.hasStickyColumns) {
      if (isPlaceholder) {
        nextProps.style.display = "inline-flex";
        nextProps.style.visibility = "hidden";
      }
      if (column.parent || isPlaceholder) {
        nextProps.style.marginTop = `calc(var(--cell-height) * -1)`;
      }
      if (column.rowSpan > 1) {
        nextProps.style.height = `calc(var(--first-row-cell-height) + var(--cell-height) * ${column.rowSpan - 1})`;
      }
    }
  }
  return [props, nextProps];
};
const getCellPropsHook = (props, { instance, cell }) => {
  const nextProps = instance.hasGroupedColumns ? getCellProps(cell.column) : {};
  return [props, nextProps];
};
const visibleColumnsHook = (visibleColumns, { instance }) => {
  const parentList = /* @__PURE__ */ new Set();
  visibleColumns.forEach(({ parent }) => {
    if (parent != null && !parentList.has(parent)) {
      parentList.add(parent);
    }
  });
  const hasGroupedColumns = parentList.size > 0;
  if (hasGroupedColumns) {
    parentList.forEach((parent) => {
      parent.align = "center";
      parent.isGroupLeftColumn = true;
      parent.isGroupRightColumn = true;
      const { columns } = parent;
      columns[0].isGroupLeftColumn = true;
      columns[columns.length - 1].isGroupRightColumn = true;
    });
  }
  Object.assign(instance, { hasGroupedColumns });
  return visibleColumns;
};
const useInstanceHook = (instance) => {
  if (instance.hasGroupedColumns) {
    replaceHeaderPlaceholders(instance.headerGroups);
  }
};
const useHvHeaderGroups = (hooks) => {
  hooks.visibleColumns.push(visibleColumnsHook);
  hooks.useInstance.push(useInstanceHook);
  hooks.getHeaderProps.push(getHeaderPropsHook);
  hooks.getCellProps.push(getCellPropsHook);
};
useHvHeaderGroups.pluginName = "useHvHeaderGroups";
exports.useHvHeaderGroups = useHvHeaderGroups;
