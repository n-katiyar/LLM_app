"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const CLEANUP_TIMER_LOOP_MILLIS = 1e3;
class TimerBasedCleanupTracking {
  timeouts = /* @__PURE__ */ new Map();
  cleanupTimeout = CLEANUP_TIMER_LOOP_MILLIS;
  constructor(timeout = CLEANUP_TIMER_LOOP_MILLIS) {
    this.cleanupTimeout = timeout;
  }
  register(object, unsubscribe, unregisterToken) {
    if (!this.timeouts) {
      this.timeouts = /* @__PURE__ */ new Map();
    }
    const timeout = setTimeout(() => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
      this.timeouts.delete(unregisterToken.cleanupToken);
    }, this.cleanupTimeout);
    this.timeouts.set(unregisterToken.cleanupToken, timeout);
  }
  unregister(unregisterToken) {
    const timeout = this.timeouts.get(unregisterToken.cleanupToken);
    if (timeout) {
      this.timeouts.delete(unregisterToken.cleanupToken);
      clearTimeout(timeout);
    }
  }
  reset() {
    if (this.timeouts) {
      this.timeouts.forEach((value, key) => {
        this.unregister({ cleanupToken: key });
      });
      this.timeouts = void 0;
    }
  }
}
exports.TimerBasedCleanupTracking = TimerBasedCleanupTracking;
